(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __knownSymbol = (name, symbol) => {
    return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  };
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target2 = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target2[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target2[prop] = source[prop];
      }
    return target2;
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __asyncGenerator = (__this, __arguments, generator) => {
    var resume = (k, v, yes, no) => {
      try {
        var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
        Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
      } catch (e) {
        no(e);
      }
    };
    var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));
    var it = {};
    return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
  };
  var __yieldStar = (value) => {
    var obj = value[__knownSymbol("asyncIterator")];
    var isAwait = false;
    var method;
    var it = {};
    if (obj == null) {
      obj = value[__knownSymbol("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw")
            throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object))
              throw TypeError("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };
  var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

  // lib/shorten.js
  function likelyDID(text) {
    return text && (!text.trim().indexOf("did:") || text.trim().length === 24 && !/[^\sa-z0-9]/i.test(text));
  }
  function shortenDID(did) {
    return did && /** @type {T} */
    (did.replace(_shortenDID_Regex, "").toLowerCase() || void 0);
  }
  function unwrapShortDID(shortDID) {
    return !shortDID ? void 0 : shortDID.indexOf(":") < 0 ? "did:plc:" + shortDID.toLowerCase() : shortDID.toLowerCase();
  }
  function shortenHandle(handle) {
    handle = cheapNormalizeHandle(handle);
    return handle && /** @type {T} */
    (handle.replace(_shortenHandle_Regex, "").toLowerCase() || void 0);
  }
  function unwrapShortHandle(shortHandle) {
    shortHandle = cheapNormalizeHandle(shortHandle);
    return !shortHandle ? void 0 : shortHandle.indexOf(".") < 0 ? shortHandle.toLowerCase() + ".bsky.social" : shortHandle.toLowerCase();
  }
  function cheapNormalizeHandle(handle) {
    handle = handle && handle.trim().toLowerCase();
    if (handle && handle.charCodeAt(0) === 64)
      handle = handle.slice(1);
    const urlprefix = "https://bsky.app/";
    if (handle && handle.lastIndexOf(urlprefix, 0) === 0) {
      const postURL = breakPostURL(handle);
      if (postURL && postURL.shortDID)
        return postURL.shortDID;
    }
    if (handle && handle.lastIndexOf("at:", 0) === 0) {
      const feedUri = breakFeedUri(handle);
      if (feedUri && feedUri.shortDID)
        return feedUri.shortDID;
    }
    return handle || void 0;
  }
  function breakPostURL(url) {
    if (!url)
      return;
    const match = _breakPostURL_Regex.exec(url);
    if (!match)
      return;
    return { shortDID: match[1], postID: match[2] };
  }
  function breakFeedUri(uri) {
    if (!uri)
      return;
    const match = _breakFeedUri_Regex.exec(uri);
    if (!match || !match[3])
      return;
    return { shortDID: match[2], postID: match[3] };
  }
  var _shortenDID_Regex, _shortenHandle_Regex, _breakPostURL_Regex, _breakFeedUri_Regex;
  var init_shorten = __esm({
    "lib/shorten.js"() {
      _shortenDID_Regex = /^did\:plc\:/;
      _shortenHandle_Regex = /\.bsky\.social$/;
      _breakPostURL_Regex = /^http[s]?\:\/\/bsky\.app\/profile\/([a-z0-9\.\:]+)\/post\/([a-z0-9]+)$/;
      _breakFeedUri_Regex = /^at\:\/\/(did:plc:)?([a-z0-9]+)\/[a-z\.]+\/?(.*)?$/;
    }
  });

  // lib/is-promise.js
  function isPromise(x) {
    if (!x || typeof x !== "object")
      return false;
    else
      return typeof x.then === "function";
  }
  var init_is_promise = __esm({
    "lib/is-promise.js"() {
    }
  });

  // node_modules/@atproto/api/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@atproto/api/dist/index.js"(exports, module) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require2() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export = (target2, all) => {
        for (var name2 in all)
          __defProp2(target2, name2, { get: all[name2], enumerable: true });
      };
      var __copyProps2 = (to, from3, except, desc) => {
        if (from3 && typeof from3 === "object" || typeof from3 === "function") {
          for (let key of __getOwnPropNames2(from3))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc2(from3, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target2) => (target2 = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target2, "default", { value: mod, enumerable: true }) : target2, mod));
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var require_boundaries = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/boundaries.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.EXTENDED_PICTOGRAPHIC = exports2.CLUSTER_BREAK = void 0;
          var CLUSTER_BREAK;
          (function(CLUSTER_BREAK2) {
            CLUSTER_BREAK2[CLUSTER_BREAK2["CR"] = 0] = "CR";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LF"] = 1] = "LF";
            CLUSTER_BREAK2[CLUSTER_BREAK2["CONTROL"] = 2] = "CONTROL";
            CLUSTER_BREAK2[CLUSTER_BREAK2["EXTEND"] = 3] = "EXTEND";
            CLUSTER_BREAK2[CLUSTER_BREAK2["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
            CLUSTER_BREAK2[CLUSTER_BREAK2["SPACINGMARK"] = 5] = "SPACINGMARK";
            CLUSTER_BREAK2[CLUSTER_BREAK2["L"] = 6] = "L";
            CLUSTER_BREAK2[CLUSTER_BREAK2["V"] = 7] = "V";
            CLUSTER_BREAK2[CLUSTER_BREAK2["T"] = 8] = "T";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LV"] = 9] = "LV";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LVT"] = 10] = "LVT";
            CLUSTER_BREAK2[CLUSTER_BREAK2["OTHER"] = 11] = "OTHER";
            CLUSTER_BREAK2[CLUSTER_BREAK2["PREPEND"] = 12] = "PREPEND";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE"] = 13] = "E_BASE";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_MODIFIER"] = 14] = "E_MODIFIER";
            CLUSTER_BREAK2[CLUSTER_BREAK2["ZWJ"] = 15] = "ZWJ";
            CLUSTER_BREAK2[CLUSTER_BREAK2["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
          })(CLUSTER_BREAK = exports2.CLUSTER_BREAK || (exports2.CLUSTER_BREAK = {}));
          exports2.EXTENDED_PICTOGRAPHIC = 101;
        }
      });
      var require_GraphemerHelper = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerHelper.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var boundaries_1 = require_boundaries();
          var NotBreak = 0;
          var BreakStart = 1;
          var Break = 2;
          var BreakLastRegional = 3;
          var BreakPenultimateRegional = 4;
          var GraphemerHelper = class {
            static isSurrogate(str, pos) {
              return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
            }
            static codePointAt(str, idx) {
              if (idx === void 0) {
                idx = 0;
              }
              const code2 = str.charCodeAt(idx);
              if (55296 <= code2 && code2 <= 56319 && idx < str.length - 1) {
                const hi = code2;
                const low = str.charCodeAt(idx + 1);
                if (56320 <= low && low <= 57343) {
                  return (hi - 55296) * 1024 + (low - 56320) + 65536;
                }
                return hi;
              }
              if (56320 <= code2 && code2 <= 57343 && idx >= 1) {
                const hi = str.charCodeAt(idx - 1);
                const low = code2;
                if (55296 <= hi && hi <= 56319) {
                  return (hi - 55296) * 1024 + (low - 56320) + 65536;
                }
                return low;
              }
              return code2;
            }
            static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
              const all = [start].concat(mid).concat([end]);
              const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
              const previous = all[all.length - 2];
              const next = end;
              const nextEmoji = endEmoji;
              const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
              if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
              }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
                if (all.filter(function(c) {
                  return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                }).length % 2 === 1) {
                  return BreakLastRegional;
                } else {
                  return BreakPenultimateRegional;
                }
              }
              if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
                return NotBreak;
              } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
                return BreakStart;
              } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
                return BreakStart;
              } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
                return NotBreak;
              } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
                return NotBreak;
              } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
                return NotBreak;
              } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
                return NotBreak;
              } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
                return NotBreak;
              } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
                return NotBreak;
              }
              const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
              if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.EXTEND;
              }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
                return NotBreak;
              }
              if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
                return Break;
              }
              if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
                return NotBreak;
              }
              return BreakStart;
            }
          };
          exports2.default = GraphemerHelper;
        }
      });
      var require_GraphemerIterator = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerIterator.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var GraphemerIterator = class {
            constructor(str, nextBreak) {
              this._index = 0;
              this._str = str;
              this._nextBreak = nextBreak;
            }
            [Symbol.iterator]() {
              return this;
            }
            next() {
              let brk;
              if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
                const value = this._str.slice(this._index, brk);
                this._index = brk;
                return { value, done: false };
              }
              if (this._index < this._str.length) {
                const value = this._str.slice(this._index);
                this._index = this._str.length;
                return { value, done: false };
              }
              return { value: void 0, done: true };
            }
          };
          exports2.default = GraphemerIterator;
        }
      });
      var require_Graphemer = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/Graphemer.js"(exports2) {
          "use strict";
          var __importDefault = exports2 && exports2.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var boundaries_1 = require_boundaries();
          var GraphemerHelper_1 = __importDefault(require_GraphemerHelper());
          var GraphemerIterator_1 = __importDefault(require_GraphemerIterator());
          var Graphemer2 = class {
            static nextBreak(string3, index) {
              if (index === void 0) {
                index = 0;
              }
              if (index < 0) {
                return 0;
              }
              if (index >= string3.length - 1) {
                return string3.length;
              }
              const prevCP = GraphemerHelper_1.default.codePointAt(string3, index);
              const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
              const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
              const mid = [];
              const midEmoji = [];
              for (let i = index + 1; i < string3.length; i++) {
                if (GraphemerHelper_1.default.isSurrogate(string3, i - 1)) {
                  continue;
                }
                const nextCP = GraphemerHelper_1.default.codePointAt(string3, i);
                const next = Graphemer2.getGraphemeBreakProperty(nextCP);
                const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
                if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
                  return i;
                }
                mid.push(next);
                midEmoji.push(nextEmoji);
              }
              return string3.length;
            }
            splitGraphemes(str) {
              const res = [];
              let index = 0;
              let brk;
              while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
                res.push(str.slice(index, brk));
                index = brk;
              }
              if (index < str.length) {
                res.push(str.slice(index));
              }
              return res;
            }
            iterateGraphemes(str) {
              return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
            }
            countGraphemes(str) {
              let count = 0;
              let index = 0;
              let brk;
              while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
                index = brk;
                count++;
              }
              if (index < str.length) {
                count++;
              }
              return count;
            }
            static getGraphemeBreakProperty(code2) {
              if (code2 < 48905) {
                if (code2 < 44116) {
                  if (code2 < 4141) {
                    if (code2 < 2818) {
                      if (code2 < 2363) {
                        if (code2 < 1759) {
                          if (code2 < 1471) {
                            if (code2 < 127) {
                              if (code2 < 11) {
                                if (code2 < 10) {
                                  if (0 <= code2 && code2 <= 9) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 === 10) {
                                    return boundaries_1.CLUSTER_BREAK.LF;
                                  }
                                }
                              } else {
                                if (code2 < 13) {
                                  if (11 <= code2 && code2 <= 12) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 14) {
                                    if (code2 === 13) {
                                      return boundaries_1.CLUSTER_BREAK.CR;
                                    }
                                  } else {
                                    if (14 <= code2 && code2 <= 31) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 768) {
                                if (code2 < 173) {
                                  if (127 <= code2 && code2 <= 159) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 === 173) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              } else {
                                if (code2 < 1155) {
                                  if (768 <= code2 && code2 <= 879) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1425) {
                                    if (1155 <= code2 && code2 <= 1161) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (1425 <= code2 && code2 <= 1469) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 1552) {
                              if (code2 < 1476) {
                                if (code2 < 1473) {
                                  if (code2 === 1471) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1473 <= code2 && code2 <= 1474) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 1479) {
                                  if (1476 <= code2 && code2 <= 1477) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1536) {
                                    if (code2 === 1479) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (1536 <= code2 && code2 <= 1541) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 1648) {
                                if (code2 < 1564) {
                                  if (1552 <= code2 && code2 <= 1562) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1611) {
                                    if (code2 === 1564) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (1611 <= code2 && code2 <= 1631) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 1750) {
                                  if (code2 === 1648) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1757) {
                                    if (1750 <= code2 && code2 <= 1756) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 1757) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2075) {
                            if (code2 < 1840) {
                              if (code2 < 1770) {
                                if (code2 < 1767) {
                                  if (1759 <= code2 && code2 <= 1764) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1767 <= code2 && code2 <= 1768) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 1807) {
                                  if (1770 <= code2 && code2 <= 1773) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 1807) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                  if (code2 === 1809) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2027) {
                                if (code2 < 1958) {
                                  if (1840 <= code2 && code2 <= 1866) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1958 <= code2 && code2 <= 1968) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2045) {
                                  if (2027 <= code2 && code2 <= 2035) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2070) {
                                    if (code2 === 2045) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2070 <= code2 && code2 <= 2073) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2200) {
                              if (code2 < 2089) {
                                if (code2 < 2085) {
                                  if (2075 <= code2 && code2 <= 2083) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2085 <= code2 && code2 <= 2087) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2137) {
                                  if (2089 <= code2 && code2 <= 2093) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2192) {
                                    if (2137 <= code2 && code2 <= 2139) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2192 <= code2 && code2 <= 2193) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2275) {
                                if (code2 < 2250) {
                                  if (2200 <= code2 && code2 <= 2207) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2274) {
                                    if (2250 <= code2 && code2 <= 2273) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2274) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2307) {
                                  if (2275 <= code2 && code2 <= 2306) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2307) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 2362) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 2561) {
                          if (code2 < 2434) {
                            if (code2 < 2381) {
                              if (code2 < 2366) {
                                if (code2 === 2363) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 2364) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2369) {
                                  if (2366 <= code2 && code2 <= 2368) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2377) {
                                    if (2369 <= code2 && code2 <= 2376) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2377 <= code2 && code2 <= 2380) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2385) {
                                if (code2 < 2382) {
                                  if (code2 === 2381) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2382 <= code2 && code2 <= 2383) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2402) {
                                  if (2385 <= code2 && code2 <= 2391) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2433) {
                                    if (2402 <= code2 && code2 <= 2403) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2433) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2503) {
                              if (code2 < 2494) {
                                if (code2 < 2492) {
                                  if (2434 <= code2 && code2 <= 2435) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 2492) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2495) {
                                  if (code2 === 2494) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2497) {
                                    if (2495 <= code2 && code2 <= 2496) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2497 <= code2 && code2 <= 2500) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2519) {
                                if (code2 < 2507) {
                                  if (2503 <= code2 && code2 <= 2504) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2509) {
                                    if (2507 <= code2 && code2 <= 2508) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 2509) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2530) {
                                  if (code2 === 2519) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2558) {
                                    if (2530 <= code2 && code2 <= 2531) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2558) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2691) {
                            if (code2 < 2631) {
                              if (code2 < 2620) {
                                if (code2 < 2563) {
                                  if (2561 <= code2 && code2 <= 2562) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2563) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2622) {
                                  if (code2 === 2620) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2625) {
                                    if (2622 <= code2 && code2 <= 2624) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2625 <= code2 && code2 <= 2626) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2672) {
                                if (code2 < 2635) {
                                  if (2631 <= code2 && code2 <= 2632) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2641) {
                                    if (2635 <= code2 && code2 <= 2637) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2641) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2677) {
                                  if (2672 <= code2 && code2 <= 2673) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2689) {
                                    if (code2 === 2677) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2689 <= code2 && code2 <= 2690) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2761) {
                              if (code2 < 2750) {
                                if (code2 === 2691) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 2748) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2753) {
                                  if (2750 <= code2 && code2 <= 2752) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2759) {
                                    if (2753 <= code2 && code2 <= 2757) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2759 <= code2 && code2 <= 2760) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2786) {
                                if (code2 < 2763) {
                                  if (code2 === 2761) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2765) {
                                    if (2763 <= code2 && code2 <= 2764) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 2765) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2810) {
                                  if (2786 <= code2 && code2 <= 2787) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2817) {
                                    if (2810 <= code2 && code2 <= 2815) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2817) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 3315) {
                        if (code2 < 3076) {
                          if (code2 < 2946) {
                            if (code2 < 2887) {
                              if (code2 < 2878) {
                                if (code2 < 2876) {
                                  if (2818 <= code2 && code2 <= 2819) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 2876) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2880) {
                                  if (2878 <= code2 && code2 <= 2879) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2881) {
                                    if (code2 === 2880) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2881 <= code2 && code2 <= 2884) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2893) {
                                if (code2 < 2891) {
                                  if (2887 <= code2 && code2 <= 2888) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2891 <= code2 && code2 <= 2892) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2901) {
                                  if (code2 === 2893) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2914) {
                                    if (2901 <= code2 && code2 <= 2903) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2914 <= code2 && code2 <= 2915) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3014) {
                              if (code2 < 3007) {
                                if (code2 === 2946) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3006) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3008) {
                                  if (code2 === 3007) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3009) {
                                    if (code2 === 3008) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3009 <= code2 && code2 <= 3010) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3031) {
                                if (code2 < 3018) {
                                  if (3014 <= code2 && code2 <= 3016) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3021) {
                                    if (3018 <= code2 && code2 <= 3020) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3021) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3072) {
                                  if (code2 === 3031) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3073) {
                                    if (code2 === 3072) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3073 <= code2 && code2 <= 3075) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3262) {
                            if (code2 < 3146) {
                              if (code2 < 3134) {
                                if (code2 === 3076) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3132) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3137) {
                                  if (3134 <= code2 && code2 <= 3136) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3142) {
                                    if (3137 <= code2 && code2 <= 3140) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3142 <= code2 && code2 <= 3144) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3201) {
                                if (code2 < 3157) {
                                  if (3146 <= code2 && code2 <= 3149) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3170) {
                                    if (3157 <= code2 && code2 <= 3158) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3170 <= code2 && code2 <= 3171) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3202) {
                                  if (code2 === 3201) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3260) {
                                    if (3202 <= code2 && code2 <= 3203) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3260) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3270) {
                              if (code2 < 3264) {
                                if (code2 === 3262) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 3263) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3266) {
                                  if (3264 <= code2 && code2 <= 3265) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3267) {
                                    if (code2 === 3266) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3267 <= code2 && code2 <= 3268) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3276) {
                                if (code2 < 3271) {
                                  if (code2 === 3270) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3274) {
                                    if (3271 <= code2 && code2 <= 3272) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3274 <= code2 && code2 <= 3275) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3285) {
                                  if (3276 <= code2 && code2 <= 3277) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3298) {
                                    if (3285 <= code2 && code2 <= 3286) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3298 <= code2 && code2 <= 3299) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 3551) {
                          if (code2 < 3406) {
                            if (code2 < 3391) {
                              if (code2 < 3330) {
                                if (code2 < 3328) {
                                  if (code2 === 3315) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3328 <= code2 && code2 <= 3329) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 3387) {
                                  if (3330 <= code2 && code2 <= 3331) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3390) {
                                    if (3387 <= code2 && code2 <= 3388) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 3390) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3398) {
                                if (code2 < 3393) {
                                  if (3391 <= code2 && code2 <= 3392) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3393 <= code2 && code2 <= 3396) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 3402) {
                                  if (3398 <= code2 && code2 <= 3400) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3405) {
                                    if (3402 <= code2 && code2 <= 3404) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3405) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3530) {
                              if (code2 < 3426) {
                                if (code2 === 3406) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code2 === 3415) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3457) {
                                  if (3426 <= code2 && code2 <= 3427) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3458) {
                                    if (code2 === 3457) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3458 <= code2 && code2 <= 3459) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3538) {
                                if (code2 < 3535) {
                                  if (code2 === 3530) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3536) {
                                    if (code2 === 3535) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3536 <= code2 && code2 <= 3537) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3542) {
                                  if (3538 <= code2 && code2 <= 3540) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3544) {
                                    if (code2 === 3542) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3544 <= code2 && code2 <= 3550) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3893) {
                            if (code2 < 3655) {
                              if (code2 < 3633) {
                                if (code2 < 3570) {
                                  if (code2 === 3551) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3570 <= code2 && code2 <= 3571) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 3635) {
                                  if (code2 === 3633) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3636) {
                                    if (code2 === 3635) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3636 <= code2 && code2 <= 3642) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3764) {
                                if (code2 < 3761) {
                                  if (3655 <= code2 && code2 <= 3662) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 3761) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 3763) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 3784) {
                                  if (3764 <= code2 && code2 <= 3772) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3864) {
                                    if (3784 <= code2 && code2 <= 3790) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3864 <= code2 && code2 <= 3865) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3967) {
                              if (code2 < 3897) {
                                if (code2 === 3893) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3895) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3902) {
                                  if (code2 === 3897) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3953) {
                                    if (3902 <= code2 && code2 <= 3903) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3953 <= code2 && code2 <= 3966) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3981) {
                                if (code2 < 3968) {
                                  if (code2 === 3967) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3974) {
                                    if (3968 <= code2 && code2 <= 3972) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3974 <= code2 && code2 <= 3975) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3993) {
                                  if (3981 <= code2 && code2 <= 3991) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4038) {
                                    if (3993 <= code2 && code2 <= 4028) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 4038) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 7204) {
                      if (code2 < 6448) {
                        if (code2 < 5938) {
                          if (code2 < 4226) {
                            if (code2 < 4157) {
                              if (code2 < 4146) {
                                if (code2 < 4145) {
                                  if (4141 <= code2 && code2 <= 4144) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 4145) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 4153) {
                                  if (4146 <= code2 && code2 <= 4151) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4155) {
                                    if (4153 <= code2 && code2 <= 4154) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (4155 <= code2 && code2 <= 4156) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 4184) {
                                if (code2 < 4182) {
                                  if (4157 <= code2 && code2 <= 4158) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4182 <= code2 && code2 <= 4183) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 4190) {
                                  if (4184 <= code2 && code2 <= 4185) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4209) {
                                    if (4190 <= code2 && code2 <= 4192) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (4209 <= code2 && code2 <= 4212) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 4352) {
                              if (code2 < 4229) {
                                if (code2 === 4226) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 4228) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 4237) {
                                  if (4229 <= code2 && code2 <= 4230) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 4237) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 4253) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 4957) {
                                if (code2 < 4448) {
                                  if (4352 <= code2 && code2 <= 4447) {
                                    return boundaries_1.CLUSTER_BREAK.L;
                                  }
                                } else {
                                  if (code2 < 4520) {
                                    if (4448 <= code2 && code2 <= 4519) {
                                      return boundaries_1.CLUSTER_BREAK.V;
                                    }
                                  } else {
                                    if (4520 <= code2 && code2 <= 4607) {
                                      return boundaries_1.CLUSTER_BREAK.T;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 5906) {
                                  if (4957 <= code2 && code2 <= 4959) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 5909) {
                                    if (5906 <= code2 && code2 <= 5908) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 5909) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 6089) {
                            if (code2 < 6070) {
                              if (code2 < 5970) {
                                if (code2 < 5940) {
                                  if (5938 <= code2 && code2 <= 5939) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 5940) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 6002) {
                                  if (5970 <= code2 && code2 <= 5971) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6068) {
                                    if (6002 <= code2 && code2 <= 6003) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6068 <= code2 && code2 <= 6069) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6078) {
                                if (code2 < 6071) {
                                  if (code2 === 6070) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (6071 <= code2 && code2 <= 6077) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6086) {
                                  if (6078 <= code2 && code2 <= 6085) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6087) {
                                    if (code2 === 6086) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6087 <= code2 && code2 <= 6088) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6277) {
                              if (code2 < 6155) {
                                if (code2 < 6109) {
                                  if (6089 <= code2 && code2 <= 6099) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6109) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6158) {
                                  if (6155 <= code2 && code2 <= 6157) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6158) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                  if (code2 === 6159) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6435) {
                                if (code2 < 6313) {
                                  if (6277 <= code2 && code2 <= 6278) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6432) {
                                    if (code2 === 6313) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6432 <= code2 && code2 <= 6434) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 6439) {
                                  if (6435 <= code2 && code2 <= 6438) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6441) {
                                    if (6439 <= code2 && code2 <= 6440) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6441 <= code2 && code2 <= 6443) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 6971) {
                          if (code2 < 6744) {
                            if (code2 < 6681) {
                              if (code2 < 6451) {
                                if (code2 < 6450) {
                                  if (6448 <= code2 && code2 <= 6449) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6450) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6457) {
                                  if (6451 <= code2 && code2 <= 6456) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6679) {
                                    if (6457 <= code2 && code2 <= 6459) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6679 <= code2 && code2 <= 6680) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6741) {
                                if (code2 < 6683) {
                                  if (6681 <= code2 && code2 <= 6682) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6683) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6742) {
                                  if (code2 === 6741) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6742) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 6743) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6771) {
                              if (code2 < 6754) {
                                if (code2 < 6752) {
                                  if (6744 <= code2 && code2 <= 6750) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6752) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6757) {
                                  if (code2 === 6754) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6765) {
                                    if (6757 <= code2 && code2 <= 6764) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6765 <= code2 && code2 <= 6770) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6912) {
                                if (code2 < 6783) {
                                  if (6771 <= code2 && code2 <= 6780) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6832) {
                                    if (code2 === 6783) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6832 <= code2 && code2 <= 6862) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 6916) {
                                  if (6912 <= code2 && code2 <= 6915) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6964) {
                                    if (code2 === 6916) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (6964 <= code2 && code2 <= 6970) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 7080) {
                            if (code2 < 7019) {
                              if (code2 < 6973) {
                                if (code2 === 6971) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 6972) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 6978) {
                                  if (6973 <= code2 && code2 <= 6977) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6979) {
                                    if (code2 === 6978) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6979 <= code2 && code2 <= 6980) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7073) {
                                if (code2 < 7040) {
                                  if (7019 <= code2 && code2 <= 7027) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 7042) {
                                    if (7040 <= code2 && code2 <= 7041) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 7042) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 7074) {
                                  if (code2 === 7073) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7078) {
                                    if (7074 <= code2 && code2 <= 7077) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7078 <= code2 && code2 <= 7079) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 7144) {
                              if (code2 < 7083) {
                                if (code2 < 7082) {
                                  if (7080 <= code2 && code2 <= 7081) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7082) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 7142) {
                                  if (7083 <= code2 && code2 <= 7085) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7142) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 7143) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7150) {
                                if (code2 < 7146) {
                                  if (7144 <= code2 && code2 <= 7145) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 7149) {
                                    if (7146 <= code2 && code2 <= 7148) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 7149) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 7151) {
                                  if (code2 === 7150) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7154) {
                                    if (7151 <= code2 && code2 <= 7153) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7154 <= code2 && code2 <= 7155) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 43346) {
                        if (code2 < 11647) {
                          if (code2 < 7415) {
                            if (code2 < 7380) {
                              if (code2 < 7220) {
                                if (code2 < 7212) {
                                  if (7204 <= code2 && code2 <= 7211) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7212 <= code2 && code2 <= 7219) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 7222) {
                                  if (7220 <= code2 && code2 <= 7221) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7376) {
                                    if (7222 <= code2 && code2 <= 7223) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7376 <= code2 && code2 <= 7378) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7394) {
                                if (code2 < 7393) {
                                  if (7380 <= code2 && code2 <= 7392) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7393) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 7405) {
                                  if (7394 <= code2 && code2 <= 7400) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7405) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 7412) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 8205) {
                              if (code2 < 7616) {
                                if (code2 < 7416) {
                                  if (code2 === 7415) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7416 <= code2 && code2 <= 7417) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 8203) {
                                  if (7616 <= code2 && code2 <= 7679) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 8203) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                  if (code2 === 8204) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 8288) {
                                if (code2 < 8206) {
                                  if (code2 === 8205) {
                                    return boundaries_1.CLUSTER_BREAK.ZWJ;
                                  }
                                } else {
                                  if (code2 < 8232) {
                                    if (8206 <= code2 && code2 <= 8207) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (8232 <= code2 && code2 <= 8238) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 8400) {
                                  if (8288 <= code2 && code2 <= 8303) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 11503) {
                                    if (8400 <= code2 && code2 <= 8432) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (11503 <= code2 && code2 <= 11505) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 43043) {
                            if (code2 < 42612) {
                              if (code2 < 12330) {
                                if (code2 < 11744) {
                                  if (code2 === 11647) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (11744 <= code2 && code2 <= 11775) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 12441) {
                                  if (12330 <= code2 && code2 <= 12335) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 42607) {
                                    if (12441 <= code2 && code2 <= 12442) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (42607 <= code2 && code2 <= 42610) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43010) {
                                if (code2 < 42654) {
                                  if (42612 <= code2 && code2 <= 42621) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 42736) {
                                    if (42654 <= code2 && code2 <= 42655) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (42736 <= code2 && code2 <= 42737) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 43014) {
                                  if (code2 === 43010) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43014) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43019) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43188) {
                              if (code2 < 43047) {
                                if (code2 < 43045) {
                                  if (43043 <= code2 && code2 <= 43044) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43045 <= code2 && code2 <= 43046) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43052) {
                                  if (code2 === 43047) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43136) {
                                    if (code2 === 43052) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43136 <= code2 && code2 <= 43137) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43263) {
                                if (code2 < 43204) {
                                  if (43188 <= code2 && code2 <= 43203) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43232) {
                                    if (43204 <= code2 && code2 <= 43205) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43232 <= code2 && code2 <= 43249) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 43302) {
                                  if (code2 === 43263) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 43335) {
                                    if (43302 <= code2 && code2 <= 43309) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43335 <= code2 && code2 <= 43345) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 43698) {
                          if (code2 < 43493) {
                            if (code2 < 43444) {
                              if (code2 < 43392) {
                                if (code2 < 43360) {
                                  if (43346 <= code2 && code2 <= 43347) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43360 <= code2 && code2 <= 43388) {
                                    return boundaries_1.CLUSTER_BREAK.L;
                                  }
                                }
                              } else {
                                if (code2 < 43395) {
                                  if (43392 <= code2 && code2 <= 43394) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43395) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 43443) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43450) {
                                if (code2 < 43446) {
                                  if (43444 <= code2 && code2 <= 43445) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43446 <= code2 && code2 <= 43449) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43452) {
                                  if (43450 <= code2 && code2 <= 43451) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43454) {
                                    if (43452 <= code2 && code2 <= 43453) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43454 <= code2 && code2 <= 43456) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43573) {
                              if (code2 < 43567) {
                                if (code2 < 43561) {
                                  if (code2 === 43493) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43561 <= code2 && code2 <= 43566) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43569) {
                                  if (43567 <= code2 && code2 <= 43568) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43571) {
                                    if (43569 <= code2 && code2 <= 43570) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43571 <= code2 && code2 <= 43572) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43597) {
                                if (code2 < 43587) {
                                  if (43573 <= code2 && code2 <= 43574) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43587) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43596) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43644) {
                                  if (code2 === 43597) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 43644) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43696) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44006) {
                            if (code2 < 43756) {
                              if (code2 < 43710) {
                                if (code2 < 43703) {
                                  if (43698 <= code2 && code2 <= 43700) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43703 <= code2 && code2 <= 43704) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43713) {
                                  if (43710 <= code2 && code2 <= 43711) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43713) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43755) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43766) {
                                if (code2 < 43758) {
                                  if (43756 <= code2 && code2 <= 43757) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 43765) {
                                    if (43758 <= code2 && code2 <= 43759) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 43765) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44003) {
                                  if (code2 === 43766) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 44005) {
                                    if (44003 <= code2 && code2 <= 44004) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 44005) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44032) {
                              if (code2 < 44009) {
                                if (code2 < 44008) {
                                  if (44006 <= code2 && code2 <= 44007) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 44008) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 44012) {
                                  if (44009 <= code2 && code2 <= 44010) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 44012) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 44013) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44061) {
                                if (code2 < 44033) {
                                  if (code2 === 44032) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44060) {
                                    if (44033 <= code2 && code2 <= 44059) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44060) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44088) {
                                  if (44061 <= code2 && code2 <= 44087) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44089) {
                                    if (code2 === 44088) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44089 <= code2 && code2 <= 44115) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 46497) {
                    if (code2 < 45293) {
                      if (code2 < 44704) {
                        if (code2 < 44397) {
                          if (code2 < 44256) {
                            if (code2 < 44173) {
                              if (code2 < 44144) {
                                if (code2 < 44117) {
                                  if (code2 === 44116) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44117 <= code2 && code2 <= 44143) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44145) {
                                  if (code2 === 44144) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44172) {
                                    if (44145 <= code2 && code2 <= 44171) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44172) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44201) {
                                if (code2 < 44200) {
                                  if (44173 <= code2 && code2 <= 44199) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44200) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44228) {
                                  if (44201 <= code2 && code2 <= 44227) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44229) {
                                    if (code2 === 44228) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44229 <= code2 && code2 <= 44255) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44313) {
                              if (code2 < 44284) {
                                if (code2 < 44257) {
                                  if (code2 === 44256) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44257 <= code2 && code2 <= 44283) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44285) {
                                  if (code2 === 44284) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44312) {
                                    if (44285 <= code2 && code2 <= 44311) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44312) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44368) {
                                if (code2 < 44340) {
                                  if (44313 <= code2 && code2 <= 44339) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44341) {
                                    if (code2 === 44340) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44341 <= code2 && code2 <= 44367) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44369) {
                                  if (code2 === 44368) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44396) {
                                    if (44369 <= code2 && code2 <= 44395) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44396) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44537) {
                            if (code2 < 44480) {
                              if (code2 < 44425) {
                                if (code2 < 44424) {
                                  if (44397 <= code2 && code2 <= 44423) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44424) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44452) {
                                  if (44425 <= code2 && code2 <= 44451) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44453) {
                                    if (code2 === 44452) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44453 <= code2 && code2 <= 44479) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44508) {
                                if (code2 < 44481) {
                                  if (code2 === 44480) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44481 <= code2 && code2 <= 44507) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44509) {
                                  if (code2 === 44508) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44536) {
                                    if (44509 <= code2 && code2 <= 44535) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44536) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44620) {
                              if (code2 < 44565) {
                                if (code2 < 44564) {
                                  if (44537 <= code2 && code2 <= 44563) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44564) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44592) {
                                  if (44565 <= code2 && code2 <= 44591) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44593) {
                                    if (code2 === 44592) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44593 <= code2 && code2 <= 44619) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44649) {
                                if (code2 < 44621) {
                                  if (code2 === 44620) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44648) {
                                    if (44621 <= code2 && code2 <= 44647) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44648) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44676) {
                                  if (44649 <= code2 && code2 <= 44675) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44677) {
                                    if (code2 === 44676) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44677 <= code2 && code2 <= 44703) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 44985) {
                          if (code2 < 44844) {
                            if (code2 < 44761) {
                              if (code2 < 44732) {
                                if (code2 < 44705) {
                                  if (code2 === 44704) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44705 <= code2 && code2 <= 44731) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44733) {
                                  if (code2 === 44732) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44760) {
                                    if (44733 <= code2 && code2 <= 44759) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44760) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44789) {
                                if (code2 < 44788) {
                                  if (44761 <= code2 && code2 <= 44787) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44788) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44816) {
                                  if (44789 <= code2 && code2 <= 44815) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44817) {
                                    if (code2 === 44816) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44817 <= code2 && code2 <= 44843) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44901) {
                              if (code2 < 44872) {
                                if (code2 < 44845) {
                                  if (code2 === 44844) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44845 <= code2 && code2 <= 44871) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44873) {
                                  if (code2 === 44872) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44900) {
                                    if (44873 <= code2 && code2 <= 44899) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44900) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44956) {
                                if (code2 < 44928) {
                                  if (44901 <= code2 && code2 <= 44927) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44929) {
                                    if (code2 === 44928) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44929 <= code2 && code2 <= 44955) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44957) {
                                  if (code2 === 44956) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44984) {
                                    if (44957 <= code2 && code2 <= 44983) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44984) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45152) {
                            if (code2 < 45068) {
                              if (code2 < 45013) {
                                if (code2 < 45012) {
                                  if (44985 <= code2 && code2 <= 45011) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45012) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45040) {
                                  if (45013 <= code2 && code2 <= 45039) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45041) {
                                    if (code2 === 45040) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45041 <= code2 && code2 <= 45067) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45097) {
                                if (code2 < 45069) {
                                  if (code2 === 45068) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45096) {
                                    if (45069 <= code2 && code2 <= 45095) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45096) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45124) {
                                  if (45097 <= code2 && code2 <= 45123) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45125) {
                                    if (code2 === 45124) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45125 <= code2 && code2 <= 45151) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45209) {
                              if (code2 < 45180) {
                                if (code2 < 45153) {
                                  if (code2 === 45152) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45153 <= code2 && code2 <= 45179) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45181) {
                                  if (code2 === 45180) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45208) {
                                    if (45181 <= code2 && code2 <= 45207) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45208) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45264) {
                                if (code2 < 45236) {
                                  if (45209 <= code2 && code2 <= 45235) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45237) {
                                    if (code2 === 45236) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45237 <= code2 && code2 <= 45263) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45265) {
                                  if (code2 === 45264) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45292) {
                                    if (45265 <= code2 && code2 <= 45291) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45292) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 45908) {
                        if (code2 < 45600) {
                          if (code2 < 45433) {
                            if (code2 < 45376) {
                              if (code2 < 45321) {
                                if (code2 < 45320) {
                                  if (45293 <= code2 && code2 <= 45319) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45320) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45348) {
                                  if (45321 <= code2 && code2 <= 45347) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45349) {
                                    if (code2 === 45348) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45349 <= code2 && code2 <= 45375) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45404) {
                                if (code2 < 45377) {
                                  if (code2 === 45376) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45377 <= code2 && code2 <= 45403) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45405) {
                                  if (code2 === 45404) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45432) {
                                    if (45405 <= code2 && code2 <= 45431) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45432) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45516) {
                              if (code2 < 45461) {
                                if (code2 < 45460) {
                                  if (45433 <= code2 && code2 <= 45459) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45460) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45488) {
                                  if (45461 <= code2 && code2 <= 45487) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45489) {
                                    if (code2 === 45488) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45489 <= code2 && code2 <= 45515) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45545) {
                                if (code2 < 45517) {
                                  if (code2 === 45516) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45544) {
                                    if (45517 <= code2 && code2 <= 45543) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45544) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45572) {
                                  if (45545 <= code2 && code2 <= 45571) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45573) {
                                    if (code2 === 45572) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45573 <= code2 && code2 <= 45599) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45741) {
                            if (code2 < 45657) {
                              if (code2 < 45628) {
                                if (code2 < 45601) {
                                  if (code2 === 45600) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45601 <= code2 && code2 <= 45627) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45629) {
                                  if (code2 === 45628) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45656) {
                                    if (45629 <= code2 && code2 <= 45655) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45656) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45712) {
                                if (code2 < 45684) {
                                  if (45657 <= code2 && code2 <= 45683) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45685) {
                                    if (code2 === 45684) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45685 <= code2 && code2 <= 45711) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45713) {
                                  if (code2 === 45712) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45740) {
                                    if (45713 <= code2 && code2 <= 45739) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45740) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45824) {
                              if (code2 < 45769) {
                                if (code2 < 45768) {
                                  if (45741 <= code2 && code2 <= 45767) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45768) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45796) {
                                  if (45769 <= code2 && code2 <= 45795) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45797) {
                                    if (code2 === 45796) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45797 <= code2 && code2 <= 45823) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45853) {
                                if (code2 < 45825) {
                                  if (code2 === 45824) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45852) {
                                    if (45825 <= code2 && code2 <= 45851) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45852) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45880) {
                                  if (45853 <= code2 && code2 <= 45879) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45881) {
                                    if (code2 === 45880) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45881 <= code2 && code2 <= 45907) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 46189) {
                          if (code2 < 46048) {
                            if (code2 < 45965) {
                              if (code2 < 45936) {
                                if (code2 < 45909) {
                                  if (code2 === 45908) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45909 <= code2 && code2 <= 45935) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45937) {
                                  if (code2 === 45936) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45964) {
                                    if (45937 <= code2 && code2 <= 45963) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45964) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45993) {
                                if (code2 < 45992) {
                                  if (45965 <= code2 && code2 <= 45991) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45992) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46020) {
                                  if (45993 <= code2 && code2 <= 46019) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46021) {
                                    if (code2 === 46020) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46021 <= code2 && code2 <= 46047) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46105) {
                              if (code2 < 46076) {
                                if (code2 < 46049) {
                                  if (code2 === 46048) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46049 <= code2 && code2 <= 46075) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46077) {
                                  if (code2 === 46076) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46104) {
                                    if (46077 <= code2 && code2 <= 46103) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46104) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46160) {
                                if (code2 < 46132) {
                                  if (46105 <= code2 && code2 <= 46131) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46133) {
                                    if (code2 === 46132) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46133 <= code2 && code2 <= 46159) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46161) {
                                  if (code2 === 46160) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46188) {
                                    if (46161 <= code2 && code2 <= 46187) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46188) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46356) {
                            if (code2 < 46272) {
                              if (code2 < 46217) {
                                if (code2 < 46216) {
                                  if (46189 <= code2 && code2 <= 46215) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46216) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46244) {
                                  if (46217 <= code2 && code2 <= 46243) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46245) {
                                    if (code2 === 46244) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46245 <= code2 && code2 <= 46271) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46301) {
                                if (code2 < 46273) {
                                  if (code2 === 46272) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46300) {
                                    if (46273 <= code2 && code2 <= 46299) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46300) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46328) {
                                  if (46301 <= code2 && code2 <= 46327) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46329) {
                                    if (code2 === 46328) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46329 <= code2 && code2 <= 46355) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46413) {
                              if (code2 < 46384) {
                                if (code2 < 46357) {
                                  if (code2 === 46356) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46357 <= code2 && code2 <= 46383) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46385) {
                                  if (code2 === 46384) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46412) {
                                    if (46385 <= code2 && code2 <= 46411) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46412) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46468) {
                                if (code2 < 46440) {
                                  if (46413 <= code2 && code2 <= 46439) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46441) {
                                    if (code2 === 46440) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46441 <= code2 && code2 <= 46467) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46469) {
                                  if (code2 === 46468) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46496) {
                                    if (46469 <= code2 && code2 <= 46495) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46496) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 47701) {
                      if (code2 < 47112) {
                        if (code2 < 46804) {
                          if (code2 < 46637) {
                            if (code2 < 46580) {
                              if (code2 < 46525) {
                                if (code2 < 46524) {
                                  if (46497 <= code2 && code2 <= 46523) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46524) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46552) {
                                  if (46525 <= code2 && code2 <= 46551) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46553) {
                                    if (code2 === 46552) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46553 <= code2 && code2 <= 46579) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46608) {
                                if (code2 < 46581) {
                                  if (code2 === 46580) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46581 <= code2 && code2 <= 46607) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46609) {
                                  if (code2 === 46608) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46636) {
                                    if (46609 <= code2 && code2 <= 46635) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46636) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46720) {
                              if (code2 < 46665) {
                                if (code2 < 46664) {
                                  if (46637 <= code2 && code2 <= 46663) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46664) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46692) {
                                  if (46665 <= code2 && code2 <= 46691) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46693) {
                                    if (code2 === 46692) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46693 <= code2 && code2 <= 46719) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46749) {
                                if (code2 < 46721) {
                                  if (code2 === 46720) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46748) {
                                    if (46721 <= code2 && code2 <= 46747) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46748) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46776) {
                                  if (46749 <= code2 && code2 <= 46775) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46777) {
                                    if (code2 === 46776) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46777 <= code2 && code2 <= 46803) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46945) {
                            if (code2 < 46861) {
                              if (code2 < 46832) {
                                if (code2 < 46805) {
                                  if (code2 === 46804) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46805 <= code2 && code2 <= 46831) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46833) {
                                  if (code2 === 46832) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46860) {
                                    if (46833 <= code2 && code2 <= 46859) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46860) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46916) {
                                if (code2 < 46888) {
                                  if (46861 <= code2 && code2 <= 46887) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46889) {
                                    if (code2 === 46888) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46889 <= code2 && code2 <= 46915) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46917) {
                                  if (code2 === 46916) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46944) {
                                    if (46917 <= code2 && code2 <= 46943) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46944) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47028) {
                              if (code2 < 46973) {
                                if (code2 < 46972) {
                                  if (46945 <= code2 && code2 <= 46971) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46972) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47e3) {
                                  if (46973 <= code2 && code2 <= 46999) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47001) {
                                    if (code2 === 47e3) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47001 <= code2 && code2 <= 47027) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47057) {
                                if (code2 < 47029) {
                                  if (code2 === 47028) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47056) {
                                    if (47029 <= code2 && code2 <= 47055) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47056) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47084) {
                                  if (47057 <= code2 && code2 <= 47083) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47085) {
                                    if (code2 === 47084) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47085 <= code2 && code2 <= 47111) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 47393) {
                          if (code2 < 47252) {
                            if (code2 < 47169) {
                              if (code2 < 47140) {
                                if (code2 < 47113) {
                                  if (code2 === 47112) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47113 <= code2 && code2 <= 47139) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47141) {
                                  if (code2 === 47140) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47168) {
                                    if (47141 <= code2 && code2 <= 47167) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47168) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47197) {
                                if (code2 < 47196) {
                                  if (47169 <= code2 && code2 <= 47195) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47196) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47224) {
                                  if (47197 <= code2 && code2 <= 47223) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47225) {
                                    if (code2 === 47224) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47225 <= code2 && code2 <= 47251) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47309) {
                              if (code2 < 47280) {
                                if (code2 < 47253) {
                                  if (code2 === 47252) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47253 <= code2 && code2 <= 47279) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47281) {
                                  if (code2 === 47280) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47308) {
                                    if (47281 <= code2 && code2 <= 47307) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47308) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47364) {
                                if (code2 < 47336) {
                                  if (47309 <= code2 && code2 <= 47335) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47337) {
                                    if (code2 === 47336) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47337 <= code2 && code2 <= 47363) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47365) {
                                  if (code2 === 47364) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47392) {
                                    if (47365 <= code2 && code2 <= 47391) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47392) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 47560) {
                            if (code2 < 47476) {
                              if (code2 < 47421) {
                                if (code2 < 47420) {
                                  if (47393 <= code2 && code2 <= 47419) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47420) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47448) {
                                  if (47421 <= code2 && code2 <= 47447) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47449) {
                                    if (code2 === 47448) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47449 <= code2 && code2 <= 47475) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47505) {
                                if (code2 < 47477) {
                                  if (code2 === 47476) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47504) {
                                    if (47477 <= code2 && code2 <= 47503) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47504) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47532) {
                                  if (47505 <= code2 && code2 <= 47531) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47533) {
                                    if (code2 === 47532) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47533 <= code2 && code2 <= 47559) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47617) {
                              if (code2 < 47588) {
                                if (code2 < 47561) {
                                  if (code2 === 47560) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47561 <= code2 && code2 <= 47587) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47589) {
                                  if (code2 === 47588) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47616) {
                                    if (47589 <= code2 && code2 <= 47615) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47616) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47672) {
                                if (code2 < 47644) {
                                  if (47617 <= code2 && code2 <= 47643) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47645) {
                                    if (code2 === 47644) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47645 <= code2 && code2 <= 47671) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47673) {
                                  if (code2 === 47672) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47700) {
                                    if (47673 <= code2 && code2 <= 47699) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47700) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 48316) {
                        if (code2 < 48008) {
                          if (code2 < 47841) {
                            if (code2 < 47784) {
                              if (code2 < 47729) {
                                if (code2 < 47728) {
                                  if (47701 <= code2 && code2 <= 47727) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47728) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47756) {
                                  if (47729 <= code2 && code2 <= 47755) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47757) {
                                    if (code2 === 47756) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47757 <= code2 && code2 <= 47783) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47812) {
                                if (code2 < 47785) {
                                  if (code2 === 47784) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47785 <= code2 && code2 <= 47811) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47813) {
                                  if (code2 === 47812) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47840) {
                                    if (47813 <= code2 && code2 <= 47839) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47840) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47924) {
                              if (code2 < 47869) {
                                if (code2 < 47868) {
                                  if (47841 <= code2 && code2 <= 47867) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47868) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47896) {
                                  if (47869 <= code2 && code2 <= 47895) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47897) {
                                    if (code2 === 47896) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47897 <= code2 && code2 <= 47923) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47953) {
                                if (code2 < 47925) {
                                  if (code2 === 47924) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47952) {
                                    if (47925 <= code2 && code2 <= 47951) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47952) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47980) {
                                  if (47953 <= code2 && code2 <= 47979) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47981) {
                                    if (code2 === 47980) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47981 <= code2 && code2 <= 48007) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48149) {
                            if (code2 < 48065) {
                              if (code2 < 48036) {
                                if (code2 < 48009) {
                                  if (code2 === 48008) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48009 <= code2 && code2 <= 48035) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48037) {
                                  if (code2 === 48036) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48064) {
                                    if (48037 <= code2 && code2 <= 48063) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48064) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48120) {
                                if (code2 < 48092) {
                                  if (48065 <= code2 && code2 <= 48091) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48093) {
                                    if (code2 === 48092) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48093 <= code2 && code2 <= 48119) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48121) {
                                  if (code2 === 48120) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48148) {
                                    if (48121 <= code2 && code2 <= 48147) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48148) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48232) {
                              if (code2 < 48177) {
                                if (code2 < 48176) {
                                  if (48149 <= code2 && code2 <= 48175) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48176) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48204) {
                                  if (48177 <= code2 && code2 <= 48203) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48205) {
                                    if (code2 === 48204) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48205 <= code2 && code2 <= 48231) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48261) {
                                if (code2 < 48233) {
                                  if (code2 === 48232) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48260) {
                                    if (48233 <= code2 && code2 <= 48259) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48260) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48288) {
                                  if (48261 <= code2 && code2 <= 48287) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48289) {
                                    if (code2 === 48288) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48289 <= code2 && code2 <= 48315) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 48597) {
                          if (code2 < 48456) {
                            if (code2 < 48373) {
                              if (code2 < 48344) {
                                if (code2 < 48317) {
                                  if (code2 === 48316) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48317 <= code2 && code2 <= 48343) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48345) {
                                  if (code2 === 48344) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48372) {
                                    if (48345 <= code2 && code2 <= 48371) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48372) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48401) {
                                if (code2 < 48400) {
                                  if (48373 <= code2 && code2 <= 48399) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48400) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48428) {
                                  if (48401 <= code2 && code2 <= 48427) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48429) {
                                    if (code2 === 48428) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48429 <= code2 && code2 <= 48455) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48513) {
                              if (code2 < 48484) {
                                if (code2 < 48457) {
                                  if (code2 === 48456) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48457 <= code2 && code2 <= 48483) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48485) {
                                  if (code2 === 48484) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48512) {
                                    if (48485 <= code2 && code2 <= 48511) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48512) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48568) {
                                if (code2 < 48540) {
                                  if (48513 <= code2 && code2 <= 48539) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48541) {
                                    if (code2 === 48540) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48541 <= code2 && code2 <= 48567) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48569) {
                                  if (code2 === 48568) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48596) {
                                    if (48569 <= code2 && code2 <= 48595) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48596) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48764) {
                            if (code2 < 48680) {
                              if (code2 < 48625) {
                                if (code2 < 48624) {
                                  if (48597 <= code2 && code2 <= 48623) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48624) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48652) {
                                  if (48625 <= code2 && code2 <= 48651) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48653) {
                                    if (code2 === 48652) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48653 <= code2 && code2 <= 48679) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48709) {
                                if (code2 < 48681) {
                                  if (code2 === 48680) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48708) {
                                    if (48681 <= code2 && code2 <= 48707) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48708) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48736) {
                                  if (48709 <= code2 && code2 <= 48735) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48737) {
                                    if (code2 === 48736) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48737 <= code2 && code2 <= 48763) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48821) {
                              if (code2 < 48792) {
                                if (code2 < 48765) {
                                  if (code2 === 48764) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48765 <= code2 && code2 <= 48791) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48793) {
                                  if (code2 === 48792) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48820) {
                                    if (48793 <= code2 && code2 <= 48819) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48820) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48876) {
                                if (code2 < 48848) {
                                  if (48821 <= code2 && code2 <= 48847) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48849) {
                                    if (code2 === 48848) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48849 <= code2 && code2 <= 48875) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48877) {
                                  if (code2 === 48876) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48904) {
                                    if (48877 <= code2 && code2 <= 48903) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48904) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 53720) {
                  if (code2 < 51312) {
                    if (code2 < 50108) {
                      if (code2 < 49493) {
                        if (code2 < 49212) {
                          if (code2 < 49045) {
                            if (code2 < 48988) {
                              if (code2 < 48933) {
                                if (code2 < 48932) {
                                  if (48905 <= code2 && code2 <= 48931) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48932) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48960) {
                                  if (48933 <= code2 && code2 <= 48959) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48961) {
                                    if (code2 === 48960) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48961 <= code2 && code2 <= 48987) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49016) {
                                if (code2 < 48989) {
                                  if (code2 === 48988) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48989 <= code2 && code2 <= 49015) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49017) {
                                  if (code2 === 49016) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49044) {
                                    if (49017 <= code2 && code2 <= 49043) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49044) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49128) {
                              if (code2 < 49073) {
                                if (code2 < 49072) {
                                  if (49045 <= code2 && code2 <= 49071) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49072) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49100) {
                                  if (49073 <= code2 && code2 <= 49099) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49101) {
                                    if (code2 === 49100) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49101 <= code2 && code2 <= 49127) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49157) {
                                if (code2 < 49129) {
                                  if (code2 === 49128) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49156) {
                                    if (49129 <= code2 && code2 <= 49155) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49156) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49184) {
                                  if (49157 <= code2 && code2 <= 49183) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49185) {
                                    if (code2 === 49184) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49185 <= code2 && code2 <= 49211) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49352) {
                            if (code2 < 49269) {
                              if (code2 < 49240) {
                                if (code2 < 49213) {
                                  if (code2 === 49212) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49213 <= code2 && code2 <= 49239) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49241) {
                                  if (code2 === 49240) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49268) {
                                    if (49241 <= code2 && code2 <= 49267) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49268) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49297) {
                                if (code2 < 49296) {
                                  if (49269 <= code2 && code2 <= 49295) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49296) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49324) {
                                  if (49297 <= code2 && code2 <= 49323) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49325) {
                                    if (code2 === 49324) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49325 <= code2 && code2 <= 49351) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49409) {
                              if (code2 < 49380) {
                                if (code2 < 49353) {
                                  if (code2 === 49352) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49353 <= code2 && code2 <= 49379) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49381) {
                                  if (code2 === 49380) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49408) {
                                    if (49381 <= code2 && code2 <= 49407) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49408) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49464) {
                                if (code2 < 49436) {
                                  if (49409 <= code2 && code2 <= 49435) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49437) {
                                    if (code2 === 49436) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49437 <= code2 && code2 <= 49463) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49465) {
                                  if (code2 === 49464) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49492) {
                                    if (49465 <= code2 && code2 <= 49491) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49492) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 49800) {
                          if (code2 < 49633) {
                            if (code2 < 49576) {
                              if (code2 < 49521) {
                                if (code2 < 49520) {
                                  if (49493 <= code2 && code2 <= 49519) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49520) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49548) {
                                  if (49521 <= code2 && code2 <= 49547) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49549) {
                                    if (code2 === 49548) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49549 <= code2 && code2 <= 49575) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49604) {
                                if (code2 < 49577) {
                                  if (code2 === 49576) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49577 <= code2 && code2 <= 49603) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49605) {
                                  if (code2 === 49604) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49632) {
                                    if (49605 <= code2 && code2 <= 49631) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49632) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49716) {
                              if (code2 < 49661) {
                                if (code2 < 49660) {
                                  if (49633 <= code2 && code2 <= 49659) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49660) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49688) {
                                  if (49661 <= code2 && code2 <= 49687) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49689) {
                                    if (code2 === 49688) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49689 <= code2 && code2 <= 49715) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49745) {
                                if (code2 < 49717) {
                                  if (code2 === 49716) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49744) {
                                    if (49717 <= code2 && code2 <= 49743) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49744) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49772) {
                                  if (49745 <= code2 && code2 <= 49771) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49773) {
                                    if (code2 === 49772) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49773 <= code2 && code2 <= 49799) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49941) {
                            if (code2 < 49857) {
                              if (code2 < 49828) {
                                if (code2 < 49801) {
                                  if (code2 === 49800) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49801 <= code2 && code2 <= 49827) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49829) {
                                  if (code2 === 49828) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49856) {
                                    if (49829 <= code2 && code2 <= 49855) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49856) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49912) {
                                if (code2 < 49884) {
                                  if (49857 <= code2 && code2 <= 49883) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49885) {
                                    if (code2 === 49884) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49885 <= code2 && code2 <= 49911) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49913) {
                                  if (code2 === 49912) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49940) {
                                    if (49913 <= code2 && code2 <= 49939) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49940) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50024) {
                              if (code2 < 49969) {
                                if (code2 < 49968) {
                                  if (49941 <= code2 && code2 <= 49967) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49968) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49996) {
                                  if (49969 <= code2 && code2 <= 49995) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49997) {
                                    if (code2 === 49996) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49997 <= code2 && code2 <= 50023) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50053) {
                                if (code2 < 50025) {
                                  if (code2 === 50024) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50052) {
                                    if (50025 <= code2 && code2 <= 50051) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50052) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50080) {
                                  if (50053 <= code2 && code2 <= 50079) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50081) {
                                    if (code2 === 50080) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50081 <= code2 && code2 <= 50107) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 50697) {
                        if (code2 < 50389) {
                          if (code2 < 50248) {
                            if (code2 < 50165) {
                              if (code2 < 50136) {
                                if (code2 < 50109) {
                                  if (code2 === 50108) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50109 <= code2 && code2 <= 50135) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50137) {
                                  if (code2 === 50136) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50164) {
                                    if (50137 <= code2 && code2 <= 50163) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50164) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50193) {
                                if (code2 < 50192) {
                                  if (50165 <= code2 && code2 <= 50191) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50192) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50220) {
                                  if (50193 <= code2 && code2 <= 50219) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50221) {
                                    if (code2 === 50220) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50221 <= code2 && code2 <= 50247) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50305) {
                              if (code2 < 50276) {
                                if (code2 < 50249) {
                                  if (code2 === 50248) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50249 <= code2 && code2 <= 50275) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50277) {
                                  if (code2 === 50276) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50304) {
                                    if (50277 <= code2 && code2 <= 50303) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50304) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50360) {
                                if (code2 < 50332) {
                                  if (50305 <= code2 && code2 <= 50331) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50333) {
                                    if (code2 === 50332) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50333 <= code2 && code2 <= 50359) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50361) {
                                  if (code2 === 50360) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50388) {
                                    if (50361 <= code2 && code2 <= 50387) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50388) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 50556) {
                            if (code2 < 50472) {
                              if (code2 < 50417) {
                                if (code2 < 50416) {
                                  if (50389 <= code2 && code2 <= 50415) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50416) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50444) {
                                  if (50417 <= code2 && code2 <= 50443) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50445) {
                                    if (code2 === 50444) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50445 <= code2 && code2 <= 50471) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50501) {
                                if (code2 < 50473) {
                                  if (code2 === 50472) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50500) {
                                    if (50473 <= code2 && code2 <= 50499) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50500) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50528) {
                                  if (50501 <= code2 && code2 <= 50527) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50529) {
                                    if (code2 === 50528) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50529 <= code2 && code2 <= 50555) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50613) {
                              if (code2 < 50584) {
                                if (code2 < 50557) {
                                  if (code2 === 50556) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50557 <= code2 && code2 <= 50583) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50585) {
                                  if (code2 === 50584) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50612) {
                                    if (50585 <= code2 && code2 <= 50611) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50612) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50668) {
                                if (code2 < 50640) {
                                  if (50613 <= code2 && code2 <= 50639) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50641) {
                                    if (code2 === 50640) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50641 <= code2 && code2 <= 50667) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50669) {
                                  if (code2 === 50668) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50696) {
                                    if (50669 <= code2 && code2 <= 50695) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50696) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 51004) {
                          if (code2 < 50837) {
                            if (code2 < 50780) {
                              if (code2 < 50725) {
                                if (code2 < 50724) {
                                  if (50697 <= code2 && code2 <= 50723) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50724) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50752) {
                                  if (50725 <= code2 && code2 <= 50751) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50753) {
                                    if (code2 === 50752) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50753 <= code2 && code2 <= 50779) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50808) {
                                if (code2 < 50781) {
                                  if (code2 === 50780) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50781 <= code2 && code2 <= 50807) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50809) {
                                  if (code2 === 50808) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50836) {
                                    if (50809 <= code2 && code2 <= 50835) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50836) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50920) {
                              if (code2 < 50865) {
                                if (code2 < 50864) {
                                  if (50837 <= code2 && code2 <= 50863) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50864) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50892) {
                                  if (50865 <= code2 && code2 <= 50891) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50893) {
                                    if (code2 === 50892) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50893 <= code2 && code2 <= 50919) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50949) {
                                if (code2 < 50921) {
                                  if (code2 === 50920) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50948) {
                                    if (50921 <= code2 && code2 <= 50947) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50948) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50976) {
                                  if (50949 <= code2 && code2 <= 50975) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50977) {
                                    if (code2 === 50976) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50977 <= code2 && code2 <= 51003) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51145) {
                            if (code2 < 51061) {
                              if (code2 < 51032) {
                                if (code2 < 51005) {
                                  if (code2 === 51004) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51005 <= code2 && code2 <= 51031) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51033) {
                                  if (code2 === 51032) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51060) {
                                    if (51033 <= code2 && code2 <= 51059) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51060) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51116) {
                                if (code2 < 51088) {
                                  if (51061 <= code2 && code2 <= 51087) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51089) {
                                    if (code2 === 51088) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51089 <= code2 && code2 <= 51115) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51117) {
                                  if (code2 === 51116) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51144) {
                                    if (51117 <= code2 && code2 <= 51143) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51144) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51228) {
                              if (code2 < 51173) {
                                if (code2 < 51172) {
                                  if (51145 <= code2 && code2 <= 51171) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51172) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51200) {
                                  if (51173 <= code2 && code2 <= 51199) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51201) {
                                    if (code2 === 51200) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51201 <= code2 && code2 <= 51227) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51257) {
                                if (code2 < 51229) {
                                  if (code2 === 51228) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51256) {
                                    if (51229 <= code2 && code2 <= 51255) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51256) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51284) {
                                  if (51257 <= code2 && code2 <= 51283) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51285) {
                                    if (code2 === 51284) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51285 <= code2 && code2 <= 51311) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 52516) {
                      if (code2 < 51901) {
                        if (code2 < 51593) {
                          if (code2 < 51452) {
                            if (code2 < 51369) {
                              if (code2 < 51340) {
                                if (code2 < 51313) {
                                  if (code2 === 51312) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51313 <= code2 && code2 <= 51339) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51341) {
                                  if (code2 === 51340) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51368) {
                                    if (51341 <= code2 && code2 <= 51367) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51368) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51397) {
                                if (code2 < 51396) {
                                  if (51369 <= code2 && code2 <= 51395) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51396) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51424) {
                                  if (51397 <= code2 && code2 <= 51423) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51425) {
                                    if (code2 === 51424) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51425 <= code2 && code2 <= 51451) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51509) {
                              if (code2 < 51480) {
                                if (code2 < 51453) {
                                  if (code2 === 51452) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51453 <= code2 && code2 <= 51479) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51481) {
                                  if (code2 === 51480) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51508) {
                                    if (51481 <= code2 && code2 <= 51507) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51508) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51564) {
                                if (code2 < 51536) {
                                  if (51509 <= code2 && code2 <= 51535) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51537) {
                                    if (code2 === 51536) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51537 <= code2 && code2 <= 51563) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51565) {
                                  if (code2 === 51564) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51592) {
                                    if (51565 <= code2 && code2 <= 51591) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51592) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51760) {
                            if (code2 < 51676) {
                              if (code2 < 51621) {
                                if (code2 < 51620) {
                                  if (51593 <= code2 && code2 <= 51619) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51620) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51648) {
                                  if (51621 <= code2 && code2 <= 51647) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51649) {
                                    if (code2 === 51648) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51649 <= code2 && code2 <= 51675) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51705) {
                                if (code2 < 51677) {
                                  if (code2 === 51676) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51704) {
                                    if (51677 <= code2 && code2 <= 51703) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51704) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51732) {
                                  if (51705 <= code2 && code2 <= 51731) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51733) {
                                    if (code2 === 51732) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51733 <= code2 && code2 <= 51759) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51817) {
                              if (code2 < 51788) {
                                if (code2 < 51761) {
                                  if (code2 === 51760) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51761 <= code2 && code2 <= 51787) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51789) {
                                  if (code2 === 51788) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51816) {
                                    if (51789 <= code2 && code2 <= 51815) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51816) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51872) {
                                if (code2 < 51844) {
                                  if (51817 <= code2 && code2 <= 51843) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51845) {
                                    if (code2 === 51844) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51845 <= code2 && code2 <= 51871) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51873) {
                                  if (code2 === 51872) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51900) {
                                    if (51873 <= code2 && code2 <= 51899) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51900) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 52208) {
                          if (code2 < 52041) {
                            if (code2 < 51984) {
                              if (code2 < 51929) {
                                if (code2 < 51928) {
                                  if (51901 <= code2 && code2 <= 51927) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51928) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51956) {
                                  if (51929 <= code2 && code2 <= 51955) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51957) {
                                    if (code2 === 51956) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51957 <= code2 && code2 <= 51983) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52012) {
                                if (code2 < 51985) {
                                  if (code2 === 51984) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51985 <= code2 && code2 <= 52011) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52013) {
                                  if (code2 === 52012) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52040) {
                                    if (52013 <= code2 && code2 <= 52039) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52040) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52124) {
                              if (code2 < 52069) {
                                if (code2 < 52068) {
                                  if (52041 <= code2 && code2 <= 52067) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52068) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52096) {
                                  if (52069 <= code2 && code2 <= 52095) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52097) {
                                    if (code2 === 52096) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52097 <= code2 && code2 <= 52123) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52153) {
                                if (code2 < 52125) {
                                  if (code2 === 52124) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52152) {
                                    if (52125 <= code2 && code2 <= 52151) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52152) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52180) {
                                  if (52153 <= code2 && code2 <= 52179) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52181) {
                                    if (code2 === 52180) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52181 <= code2 && code2 <= 52207) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52349) {
                            if (code2 < 52265) {
                              if (code2 < 52236) {
                                if (code2 < 52209) {
                                  if (code2 === 52208) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52209 <= code2 && code2 <= 52235) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52237) {
                                  if (code2 === 52236) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52264) {
                                    if (52237 <= code2 && code2 <= 52263) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52264) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52320) {
                                if (code2 < 52292) {
                                  if (52265 <= code2 && code2 <= 52291) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52293) {
                                    if (code2 === 52292) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52293 <= code2 && code2 <= 52319) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52321) {
                                  if (code2 === 52320) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52348) {
                                    if (52321 <= code2 && code2 <= 52347) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52348) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52432) {
                              if (code2 < 52377) {
                                if (code2 < 52376) {
                                  if (52349 <= code2 && code2 <= 52375) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52376) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52404) {
                                  if (52377 <= code2 && code2 <= 52403) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52405) {
                                    if (code2 === 52404) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52405 <= code2 && code2 <= 52431) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52461) {
                                if (code2 < 52433) {
                                  if (code2 === 52432) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52460) {
                                    if (52433 <= code2 && code2 <= 52459) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52460) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52488) {
                                  if (52461 <= code2 && code2 <= 52487) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52489) {
                                    if (code2 === 52488) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52489 <= code2 && code2 <= 52515) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 53105) {
                        if (code2 < 52797) {
                          if (code2 < 52656) {
                            if (code2 < 52573) {
                              if (code2 < 52544) {
                                if (code2 < 52517) {
                                  if (code2 === 52516) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52517 <= code2 && code2 <= 52543) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52545) {
                                  if (code2 === 52544) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52572) {
                                    if (52545 <= code2 && code2 <= 52571) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52572) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52601) {
                                if (code2 < 52600) {
                                  if (52573 <= code2 && code2 <= 52599) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52600) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52628) {
                                  if (52601 <= code2 && code2 <= 52627) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52629) {
                                    if (code2 === 52628) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52629 <= code2 && code2 <= 52655) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52713) {
                              if (code2 < 52684) {
                                if (code2 < 52657) {
                                  if (code2 === 52656) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52657 <= code2 && code2 <= 52683) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52685) {
                                  if (code2 === 52684) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52712) {
                                    if (52685 <= code2 && code2 <= 52711) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52712) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52768) {
                                if (code2 < 52740) {
                                  if (52713 <= code2 && code2 <= 52739) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52741) {
                                    if (code2 === 52740) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52741 <= code2 && code2 <= 52767) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52769) {
                                  if (code2 === 52768) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52796) {
                                    if (52769 <= code2 && code2 <= 52795) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52796) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52964) {
                            if (code2 < 52880) {
                              if (code2 < 52825) {
                                if (code2 < 52824) {
                                  if (52797 <= code2 && code2 <= 52823) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52824) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52852) {
                                  if (52825 <= code2 && code2 <= 52851) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52853) {
                                    if (code2 === 52852) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52853 <= code2 && code2 <= 52879) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52909) {
                                if (code2 < 52881) {
                                  if (code2 === 52880) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52908) {
                                    if (52881 <= code2 && code2 <= 52907) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52908) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52936) {
                                  if (52909 <= code2 && code2 <= 52935) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52937) {
                                    if (code2 === 52936) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52937 <= code2 && code2 <= 52963) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53021) {
                              if (code2 < 52992) {
                                if (code2 < 52965) {
                                  if (code2 === 52964) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52965 <= code2 && code2 <= 52991) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52993) {
                                  if (code2 === 52992) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53020) {
                                    if (52993 <= code2 && code2 <= 53019) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53020) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53076) {
                                if (code2 < 53048) {
                                  if (53021 <= code2 && code2 <= 53047) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53049) {
                                    if (code2 === 53048) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53049 <= code2 && code2 <= 53075) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53077) {
                                  if (code2 === 53076) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53104) {
                                    if (53077 <= code2 && code2 <= 53103) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53104) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 53412) {
                          if (code2 < 53245) {
                            if (code2 < 53188) {
                              if (code2 < 53133) {
                                if (code2 < 53132) {
                                  if (53105 <= code2 && code2 <= 53131) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53132) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53160) {
                                  if (53133 <= code2 && code2 <= 53159) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53161) {
                                    if (code2 === 53160) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53161 <= code2 && code2 <= 53187) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53216) {
                                if (code2 < 53189) {
                                  if (code2 === 53188) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53189 <= code2 && code2 <= 53215) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53217) {
                                  if (code2 === 53216) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53244) {
                                    if (53217 <= code2 && code2 <= 53243) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53244) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53328) {
                              if (code2 < 53273) {
                                if (code2 < 53272) {
                                  if (53245 <= code2 && code2 <= 53271) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53272) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53300) {
                                  if (53273 <= code2 && code2 <= 53299) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53301) {
                                    if (code2 === 53300) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53301 <= code2 && code2 <= 53327) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53357) {
                                if (code2 < 53329) {
                                  if (code2 === 53328) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53356) {
                                    if (53329 <= code2 && code2 <= 53355) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53356) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53384) {
                                  if (53357 <= code2 && code2 <= 53383) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53385) {
                                    if (code2 === 53384) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53385 <= code2 && code2 <= 53411) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 53553) {
                            if (code2 < 53469) {
                              if (code2 < 53440) {
                                if (code2 < 53413) {
                                  if (code2 === 53412) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53413 <= code2 && code2 <= 53439) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53441) {
                                  if (code2 === 53440) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53468) {
                                    if (53441 <= code2 && code2 <= 53467) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53468) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53524) {
                                if (code2 < 53496) {
                                  if (53469 <= code2 && code2 <= 53495) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53497) {
                                    if (code2 === 53496) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53497 <= code2 && code2 <= 53523) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53525) {
                                  if (code2 === 53524) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53552) {
                                    if (53525 <= code2 && code2 <= 53551) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53552) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53636) {
                              if (code2 < 53581) {
                                if (code2 < 53580) {
                                  if (53553 <= code2 && code2 <= 53579) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53580) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53608) {
                                  if (53581 <= code2 && code2 <= 53607) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53609) {
                                    if (code2 === 53608) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53609 <= code2 && code2 <= 53635) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53665) {
                                if (code2 < 53637) {
                                  if (code2 === 53636) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53664) {
                                    if (53637 <= code2 && code2 <= 53663) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53664) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53692) {
                                  if (53665 <= code2 && code2 <= 53691) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53693) {
                                    if (code2 === 53692) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53693 <= code2 && code2 <= 53719) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 70459) {
                    if (code2 < 54897) {
                      if (code2 < 54308) {
                        if (code2 < 54001) {
                          if (code2 < 53860) {
                            if (code2 < 53777) {
                              if (code2 < 53748) {
                                if (code2 < 53721) {
                                  if (code2 === 53720) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53721 <= code2 && code2 <= 53747) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53749) {
                                  if (code2 === 53748) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53776) {
                                    if (53749 <= code2 && code2 <= 53775) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53776) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53805) {
                                if (code2 < 53804) {
                                  if (53777 <= code2 && code2 <= 53803) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53804) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53832) {
                                  if (53805 <= code2 && code2 <= 53831) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53833) {
                                    if (code2 === 53832) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53833 <= code2 && code2 <= 53859) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53917) {
                              if (code2 < 53888) {
                                if (code2 < 53861) {
                                  if (code2 === 53860) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53861 <= code2 && code2 <= 53887) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53889) {
                                  if (code2 === 53888) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53916) {
                                    if (53889 <= code2 && code2 <= 53915) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53916) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53972) {
                                if (code2 < 53944) {
                                  if (53917 <= code2 && code2 <= 53943) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53945) {
                                    if (code2 === 53944) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53945 <= code2 && code2 <= 53971) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53973) {
                                  if (code2 === 53972) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54e3) {
                                    if (53973 <= code2 && code2 <= 53999) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54e3) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54141) {
                            if (code2 < 54084) {
                              if (code2 < 54029) {
                                if (code2 < 54028) {
                                  if (54001 <= code2 && code2 <= 54027) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54028) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54056) {
                                  if (54029 <= code2 && code2 <= 54055) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54057) {
                                    if (code2 === 54056) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54057 <= code2 && code2 <= 54083) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54112) {
                                if (code2 < 54085) {
                                  if (code2 === 54084) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54085 <= code2 && code2 <= 54111) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54113) {
                                  if (code2 === 54112) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54140) {
                                    if (54113 <= code2 && code2 <= 54139) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54140) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54224) {
                              if (code2 < 54169) {
                                if (code2 < 54168) {
                                  if (54141 <= code2 && code2 <= 54167) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54168) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54196) {
                                  if (54169 <= code2 && code2 <= 54195) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54197) {
                                    if (code2 === 54196) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54197 <= code2 && code2 <= 54223) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54253) {
                                if (code2 < 54225) {
                                  if (code2 === 54224) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54252) {
                                    if (54225 <= code2 && code2 <= 54251) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54252) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54280) {
                                  if (54253 <= code2 && code2 <= 54279) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54281) {
                                    if (code2 === 54280) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54281 <= code2 && code2 <= 54307) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 54589) {
                          if (code2 < 54448) {
                            if (code2 < 54365) {
                              if (code2 < 54336) {
                                if (code2 < 54309) {
                                  if (code2 === 54308) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54309 <= code2 && code2 <= 54335) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54337) {
                                  if (code2 === 54336) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54364) {
                                    if (54337 <= code2 && code2 <= 54363) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54364) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54393) {
                                if (code2 < 54392) {
                                  if (54365 <= code2 && code2 <= 54391) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54392) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54420) {
                                  if (54393 <= code2 && code2 <= 54419) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54421) {
                                    if (code2 === 54420) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54421 <= code2 && code2 <= 54447) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54505) {
                              if (code2 < 54476) {
                                if (code2 < 54449) {
                                  if (code2 === 54448) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54449 <= code2 && code2 <= 54475) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54477) {
                                  if (code2 === 54476) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54504) {
                                    if (54477 <= code2 && code2 <= 54503) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54504) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54560) {
                                if (code2 < 54532) {
                                  if (54505 <= code2 && code2 <= 54531) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54533) {
                                    if (code2 === 54532) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54533 <= code2 && code2 <= 54559) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54561) {
                                  if (code2 === 54560) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54588) {
                                    if (54561 <= code2 && code2 <= 54587) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54588) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54756) {
                            if (code2 < 54672) {
                              if (code2 < 54617) {
                                if (code2 < 54616) {
                                  if (54589 <= code2 && code2 <= 54615) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54616) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54644) {
                                  if (54617 <= code2 && code2 <= 54643) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54645) {
                                    if (code2 === 54644) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54645 <= code2 && code2 <= 54671) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54701) {
                                if (code2 < 54673) {
                                  if (code2 === 54672) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54700) {
                                    if (54673 <= code2 && code2 <= 54699) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54700) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54728) {
                                  if (54701 <= code2 && code2 <= 54727) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54729) {
                                    if (code2 === 54728) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54729 <= code2 && code2 <= 54755) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54813) {
                              if (code2 < 54784) {
                                if (code2 < 54757) {
                                  if (code2 === 54756) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54757 <= code2 && code2 <= 54783) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54785) {
                                  if (code2 === 54784) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54812) {
                                    if (54785 <= code2 && code2 <= 54811) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54812) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54868) {
                                if (code2 < 54840) {
                                  if (54813 <= code2 && code2 <= 54839) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54841) {
                                    if (code2 === 54840) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54841 <= code2 && code2 <= 54867) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54869) {
                                  if (code2 === 54868) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54896) {
                                    if (54869 <= code2 && code2 <= 54895) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54896) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 69632) {
                        if (code2 < 55216) {
                          if (code2 < 55037) {
                            if (code2 < 54980) {
                              if (code2 < 54925) {
                                if (code2 < 54924) {
                                  if (54897 <= code2 && code2 <= 54923) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54924) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54952) {
                                  if (54925 <= code2 && code2 <= 54951) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54953) {
                                    if (code2 === 54952) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54953 <= code2 && code2 <= 54979) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 55008) {
                                if (code2 < 54981) {
                                  if (code2 === 54980) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54981 <= code2 && code2 <= 55007) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 55009) {
                                  if (code2 === 55008) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 55036) {
                                    if (55009 <= code2 && code2 <= 55035) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 55036) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 55120) {
                              if (code2 < 55065) {
                                if (code2 < 55064) {
                                  if (55037 <= code2 && code2 <= 55063) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 55064) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 55092) {
                                  if (55065 <= code2 && code2 <= 55091) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 55093) {
                                    if (code2 === 55092) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (55093 <= code2 && code2 <= 55119) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 55149) {
                                if (code2 < 55121) {
                                  if (code2 === 55120) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 55148) {
                                    if (55121 <= code2 && code2 <= 55147) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 55148) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 55176) {
                                  if (55149 <= code2 && code2 <= 55175) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 55177) {
                                    if (code2 === 55176) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (55177 <= code2 && code2 <= 55203) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 68097) {
                            if (code2 < 65279) {
                              if (code2 < 64286) {
                                if (code2 < 55243) {
                                  if (55216 <= code2 && code2 <= 55238) {
                                    return boundaries_1.CLUSTER_BREAK.V;
                                  }
                                } else {
                                  if (55243 <= code2 && code2 <= 55291) {
                                    return boundaries_1.CLUSTER_BREAK.T;
                                  }
                                }
                              } else {
                                if (code2 < 65024) {
                                  if (code2 === 64286) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 65056) {
                                    if (65024 <= code2 && code2 <= 65039) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (65056 <= code2 && code2 <= 65071) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 66045) {
                                if (code2 < 65438) {
                                  if (code2 === 65279) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 65520) {
                                    if (65438 <= code2 && code2 <= 65439) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (65520 <= code2 && code2 <= 65531) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 66272) {
                                  if (code2 === 66045) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 66422) {
                                    if (code2 === 66272) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (66422 <= code2 && code2 <= 66426) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 68325) {
                              if (code2 < 68108) {
                                if (code2 < 68101) {
                                  if (68097 <= code2 && code2 <= 68099) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (68101 <= code2 && code2 <= 68102) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 68152) {
                                  if (68108 <= code2 && code2 <= 68111) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 68159) {
                                    if (68152 <= code2 && code2 <= 68154) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 68159) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69373) {
                                if (code2 < 68900) {
                                  if (68325 <= code2 && code2 <= 68326) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69291) {
                                    if (68900 <= code2 && code2 <= 68903) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (69291 <= code2 && code2 <= 69292) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 69446) {
                                  if (69373 <= code2 && code2 <= 69375) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69506) {
                                    if (69446 <= code2 && code2 <= 69456) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (69506 <= code2 && code2 <= 69509) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 70016) {
                          if (code2 < 69815) {
                            if (code2 < 69747) {
                              if (code2 < 69634) {
                                if (code2 === 69632) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 69633) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 69688) {
                                  if (code2 === 69634) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 69744) {
                                    if (69688 <= code2 && code2 <= 69702) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 69744) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69762) {
                                if (code2 < 69759) {
                                  if (69747 <= code2 && code2 <= 69748) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69759 <= code2 && code2 <= 69761) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 69808) {
                                  if (code2 === 69762) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 69811) {
                                    if (69808 <= code2 && code2 <= 69810) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (69811 <= code2 && code2 <= 69814) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 69888) {
                              if (code2 < 69821) {
                                if (code2 < 69817) {
                                  if (69815 <= code2 && code2 <= 69816) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (69817 <= code2 && code2 <= 69818) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 69826) {
                                  if (code2 === 69821) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 === 69826) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 69837) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69933) {
                                if (code2 < 69927) {
                                  if (69888 <= code2 && code2 <= 69890) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69932) {
                                    if (69927 <= code2 && code2 <= 69931) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 69932) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 69957) {
                                  if (69933 <= code2 && code2 <= 69940) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70003) {
                                    if (69957 <= code2 && code2 <= 69958) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 70003) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 70194) {
                            if (code2 < 70082) {
                              if (code2 < 70067) {
                                if (code2 < 70018) {
                                  if (70016 <= code2 && code2 <= 70017) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 70018) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70070) {
                                  if (70067 <= code2 && code2 <= 70069) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70079) {
                                    if (70070 <= code2 && code2 <= 70078) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70079 <= code2 && code2 <= 70080) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70095) {
                                if (code2 < 70089) {
                                  if (70082 <= code2 && code2 <= 70083) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 70094) {
                                    if (70089 <= code2 && code2 <= 70092) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 70094) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 70188) {
                                  if (code2 === 70095) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70191) {
                                    if (70188 <= code2 && code2 <= 70190) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70191 <= code2 && code2 <= 70193) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70209) {
                              if (code2 < 70197) {
                                if (code2 < 70196) {
                                  if (70194 <= code2 && code2 <= 70195) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70196) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70198) {
                                  if (code2 === 70197) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70206) {
                                    if (70198 <= code2 && code2 <= 70199) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 70206) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70371) {
                                if (code2 < 70367) {
                                  if (code2 === 70209) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70368) {
                                    if (code2 === 70367) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70368 <= code2 && code2 <= 70370) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 70400) {
                                  if (70371 <= code2 && code2 <= 70378) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70402) {
                                    if (70400 <= code2 && code2 <= 70401) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70402 <= code2 && code2 <= 70403) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 72343) {
                      if (code2 < 71339) {
                        if (code2 < 70841) {
                          if (code2 < 70512) {
                            if (code2 < 70471) {
                              if (code2 < 70463) {
                                if (code2 < 70462) {
                                  if (70459 <= code2 && code2 <= 70460) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 70462) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70464) {
                                  if (code2 === 70463) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70465) {
                                    if (code2 === 70464) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70465 <= code2 && code2 <= 70468) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70487) {
                                if (code2 < 70475) {
                                  if (70471 <= code2 && code2 <= 70472) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70475 <= code2 && code2 <= 70477) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70498) {
                                  if (code2 === 70487) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70502) {
                                    if (70498 <= code2 && code2 <= 70499) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70502 <= code2 && code2 <= 70508) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70725) {
                              if (code2 < 70712) {
                                if (code2 < 70709) {
                                  if (70512 <= code2 && code2 <= 70516) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70709 <= code2 && code2 <= 70711) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70720) {
                                  if (70712 <= code2 && code2 <= 70719) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70722) {
                                    if (70720 <= code2 && code2 <= 70721) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70722 <= code2 && code2 <= 70724) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70832) {
                                if (code2 < 70726) {
                                  if (code2 === 70725) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70726) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 70750) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70833) {
                                  if (code2 === 70832) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70835) {
                                    if (70833 <= code2 && code2 <= 70834) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70835 <= code2 && code2 <= 70840) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 71096) {
                            if (code2 < 70847) {
                              if (code2 < 70843) {
                                if (code2 === 70841) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 70842) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70845) {
                                  if (70843 <= code2 && code2 <= 70844) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70845) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 70846) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71087) {
                                if (code2 < 70849) {
                                  if (70847 <= code2 && code2 <= 70848) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70850) {
                                    if (code2 === 70849) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70850 <= code2 && code2 <= 70851) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71088) {
                                  if (code2 === 71087) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71090) {
                                    if (71088 <= code2 && code2 <= 71089) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71090 <= code2 && code2 <= 71093) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71216) {
                              if (code2 < 71102) {
                                if (code2 < 71100) {
                                  if (71096 <= code2 && code2 <= 71099) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71100 <= code2 && code2 <= 71101) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 71103) {
                                  if (code2 === 71102) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 71132) {
                                    if (71103 <= code2 && code2 <= 71104) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (71132 <= code2 && code2 <= 71133) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71229) {
                                if (code2 < 71219) {
                                  if (71216 <= code2 && code2 <= 71218) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 71227) {
                                    if (71219 <= code2 && code2 <= 71226) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (71227 <= code2 && code2 <= 71228) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71230) {
                                  if (code2 === 71229) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71231) {
                                    if (code2 === 71230) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71231 <= code2 && code2 <= 71232) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 71999) {
                          if (code2 < 71463) {
                            if (code2 < 71350) {
                              if (code2 < 71341) {
                                if (code2 === 71339) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 71340) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 71342) {
                                  if (code2 === 71341) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71344) {
                                    if (71342 <= code2 && code2 <= 71343) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71344 <= code2 && code2 <= 71349) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71453) {
                                if (code2 === 71350) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 71351) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71458) {
                                  if (71453 <= code2 && code2 <= 71455) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71462) {
                                    if (71458 <= code2 && code2 <= 71461) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 71462) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71984) {
                              if (code2 < 71727) {
                                if (code2 < 71724) {
                                  if (71463 <= code2 && code2 <= 71467) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71724 <= code2 && code2 <= 71726) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 71736) {
                                  if (71727 <= code2 && code2 <= 71735) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71737) {
                                    if (code2 === 71736) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71737 <= code2 && code2 <= 71738) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71995) {
                                if (code2 < 71985) {
                                  if (code2 === 71984) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71991) {
                                    if (71985 <= code2 && code2 <= 71989) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71991 <= code2 && code2 <= 71992) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71997) {
                                  if (71995 <= code2 && code2 <= 71996) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 71997) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 71998) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 72193) {
                            if (code2 < 72145) {
                              if (code2 < 72001) {
                                if (code2 === 71999) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code2 === 72e3) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 72002) {
                                  if (code2 === 72001) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 === 72002) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 72003) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72156) {
                                if (code2 < 72148) {
                                  if (72145 <= code2 && code2 <= 72147) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72154) {
                                    if (72148 <= code2 && code2 <= 72151) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72154 <= code2 && code2 <= 72155) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 72160) {
                                  if (72156 <= code2 && code2 <= 72159) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 72160) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 72164) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 72263) {
                              if (code2 < 72249) {
                                if (code2 < 72243) {
                                  if (72193 <= code2 && code2 <= 72202) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72243 <= code2 && code2 <= 72248) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72250) {
                                  if (code2 === 72249) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72251) {
                                    if (code2 === 72250) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  } else {
                                    if (72251 <= code2 && code2 <= 72254) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72281) {
                                if (code2 < 72273) {
                                  if (code2 === 72263) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72279) {
                                    if (72273 <= code2 && code2 <= 72278) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72279 <= code2 && code2 <= 72280) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 72324) {
                                  if (72281 <= code2 && code2 <= 72283) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72330) {
                                    if (72324 <= code2 && code2 <= 72329) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  } else {
                                    if (72330 <= code2 && code2 <= 72342) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 94033) {
                        if (code2 < 73104) {
                          if (code2 < 72881) {
                            if (code2 < 72766) {
                              if (code2 < 72751) {
                                if (code2 < 72344) {
                                  if (code2 === 72343) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72344 <= code2 && code2 <= 72345) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72752) {
                                  if (code2 === 72751) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72760) {
                                    if (72752 <= code2 && code2 <= 72758) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72760 <= code2 && code2 <= 72765) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72850) {
                                if (code2 === 72766) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 72767) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 72873) {
                                  if (72850 <= code2 && code2 <= 72871) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72874) {
                                    if (code2 === 72873) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (72874 <= code2 && code2 <= 72880) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 73018) {
                              if (code2 < 72884) {
                                if (code2 < 72882) {
                                  if (code2 === 72881) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72882 <= code2 && code2 <= 72883) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72885) {
                                  if (code2 === 72884) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 73009) {
                                    if (72885 <= code2 && code2 <= 72886) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73009 <= code2 && code2 <= 73014) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 73030) {
                                if (code2 < 73020) {
                                  if (code2 === 73018) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 73023) {
                                    if (73020 <= code2 && code2 <= 73021) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73023 <= code2 && code2 <= 73029) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 73031) {
                                  if (code2 === 73030) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 73098) {
                                    if (code2 === 73031) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73098 <= code2 && code2 <= 73102) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 73526) {
                            if (code2 < 73459) {
                              if (code2 < 73109) {
                                if (code2 < 73107) {
                                  if (73104 <= code2 && code2 <= 73105) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73107 <= code2 && code2 <= 73108) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 73110) {
                                  if (code2 === 73109) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 73110) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 73111) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 73474) {
                                if (code2 < 73461) {
                                  if (73459 <= code2 && code2 <= 73460) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 73472) {
                                    if (73461 <= code2 && code2 <= 73462) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (73472 <= code2 && code2 <= 73473) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 73475) {
                                  if (code2 === 73474) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 73524) {
                                    if (code2 === 73475) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (73524 <= code2 && code2 <= 73525) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 78896) {
                              if (code2 < 73536) {
                                if (code2 < 73534) {
                                  if (73526 <= code2 && code2 <= 73530) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73534 <= code2 && code2 <= 73535) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 73537) {
                                  if (code2 === 73536) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 73537) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 73538) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 92912) {
                                if (code2 < 78912) {
                                  if (78896 <= code2 && code2 <= 78911) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 78919) {
                                    if (code2 === 78912) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (78919 <= code2 && code2 <= 78933) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 92976) {
                                  if (92912 <= code2 && code2 <= 92916) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 94031) {
                                    if (92976 <= code2 && code2 <= 92982) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 94031) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 121476) {
                          if (code2 < 119143) {
                            if (code2 < 113824) {
                              if (code2 < 94180) {
                                if (code2 < 94095) {
                                  if (94033 <= code2 && code2 <= 94087) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (94095 <= code2 && code2 <= 94098) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 94192) {
                                  if (code2 === 94180) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 113821) {
                                    if (94192 <= code2 && code2 <= 94193) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (113821 <= code2 && code2 <= 113822) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 118576) {
                                if (code2 < 118528) {
                                  if (113824 <= code2 && code2 <= 113827) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (118528 <= code2 && code2 <= 118573) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 119141) {
                                  if (118576 <= code2 && code2 <= 118598) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 119141) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 119142) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 119173) {
                              if (code2 < 119150) {
                                if (code2 < 119149) {
                                  if (119143 <= code2 && code2 <= 119145) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 119149) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 119155) {
                                  if (119150 <= code2 && code2 <= 119154) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 119163) {
                                    if (119155 <= code2 && code2 <= 119162) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (119163 <= code2 && code2 <= 119170) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 121344) {
                                if (code2 < 119210) {
                                  if (119173 <= code2 && code2 <= 119179) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 119362) {
                                    if (119210 <= code2 && code2 <= 119213) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (119362 <= code2 && code2 <= 119364) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 121403) {
                                  if (121344 <= code2 && code2 <= 121398) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 121461) {
                                    if (121403 <= code2 && code2 <= 121452) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 121461) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 123628) {
                            if (code2 < 122907) {
                              if (code2 < 121505) {
                                if (code2 < 121499) {
                                  if (code2 === 121476) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (121499 <= code2 && code2 <= 121503) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 122880) {
                                  if (121505 <= code2 && code2 <= 121519) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 122888) {
                                    if (122880 <= code2 && code2 <= 122886) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (122888 <= code2 && code2 <= 122904) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 123023) {
                                if (code2 < 122915) {
                                  if (122907 <= code2 && code2 <= 122913) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 122918) {
                                    if (122915 <= code2 && code2 <= 122916) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (122918 <= code2 && code2 <= 122922) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 123184) {
                                  if (code2 === 123023) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 123566) {
                                    if (123184 <= code2 && code2 <= 123190) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 123566) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 127995) {
                              if (code2 < 125136) {
                                if (code2 < 124140) {
                                  if (123628 <= code2 && code2 <= 123631) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (124140 <= code2 && code2 <= 124143) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 125252) {
                                  if (125136 <= code2 && code2 <= 125142) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 127462) {
                                    if (125252 <= code2 && code2 <= 125258) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (127462 <= code2 && code2 <= 127487) {
                                      return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 917632) {
                                if (code2 < 917504) {
                                  if (127995 <= code2 && code2 <= 127999) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 917536) {
                                    if (917504 <= code2 && code2 <= 917535) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (917536 <= code2 && code2 <= 917631) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 917760) {
                                  if (917632 <= code2 && code2 <= 917759) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 918e3) {
                                    if (917760 <= code2 && code2 <= 917999) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (918e3 <= code2 && code2 <= 921599) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return boundaries_1.CLUSTER_BREAK.OTHER;
            }
            static getEmojiProperty(code2) {
              if (code2 < 10160) {
                if (code2 < 9728) {
                  if (code2 < 9e3) {
                    if (code2 < 8482) {
                      if (code2 < 8252) {
                        if (code2 === 169) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 174) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 8252) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 8265) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 8596) {
                        if (code2 === 8482) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 8505) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 8617) {
                          if (8596 <= code2 && code2 <= 8601) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 8986) {
                            if (8617 <= code2 && code2 <= 8618) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (8986 <= code2 && code2 <= 8987) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 9410) {
                      if (code2 < 9167) {
                        if (code2 === 9e3) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 9096) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 9193) {
                          if (code2 === 9167) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9208) {
                            if (9193 <= code2 && code2 <= 9203) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9208 <= code2 && code2 <= 9210) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 9654) {
                        if (code2 < 9642) {
                          if (code2 === 9410) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9642 <= code2 && code2 <= 9643) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 9664) {
                          if (code2 === 9654) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9723) {
                            if (code2 === 9664) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9723 <= code2 && code2 <= 9726) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 10035) {
                    if (code2 < 10004) {
                      if (code2 < 9748) {
                        if (code2 < 9735) {
                          if (9728 <= code2 && code2 <= 9733) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9735 <= code2 && code2 <= 9746) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 9872) {
                          if (9748 <= code2 && code2 <= 9861) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9992) {
                            if (9872 <= code2 && code2 <= 9989) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9992 <= code2 && code2 <= 10002) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 10013) {
                        if (code2 === 10004) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 10006) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 10017) {
                          if (code2 === 10013) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10017) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 10024) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 10067) {
                      if (code2 < 10055) {
                        if (code2 < 10052) {
                          if (10035 <= code2 && code2 <= 10036) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10052) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 10060) {
                          if (code2 === 10055) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10060) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 10062) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    } else {
                      if (code2 < 10083) {
                        if (code2 < 10071) {
                          if (10067 <= code2 && code2 <= 10069) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10071) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 10133) {
                          if (10083 <= code2 && code2 <= 10087) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 10145) {
                            if (10133 <= code2 && code2 <= 10135) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (code2 === 10145) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 127489) {
                  if (code2 < 12951) {
                    if (code2 < 11035) {
                      if (code2 < 10548) {
                        if (code2 === 10160) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 10175) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 11013) {
                          if (10548 <= code2 && code2 <= 10549) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (11013 <= code2 && code2 <= 11015) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    } else {
                      if (code2 < 11093) {
                        if (code2 < 11088) {
                          if (11035 <= code2 && code2 <= 11036) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 11088) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 12336) {
                          if (code2 === 11093) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 12336) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 12349) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 127340) {
                      if (code2 < 126976) {
                        if (code2 === 12951) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 12953) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 127245) {
                          if (126976 <= code2 && code2 <= 127231) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127279) {
                            if (127245 <= code2 && code2 <= 127247) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (code2 === 127279) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 127374) {
                        if (code2 < 127358) {
                          if (127340 <= code2 && code2 <= 127345) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127358 <= code2 && code2 <= 127359) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 127377) {
                          if (code2 === 127374) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127405) {
                            if (127377 <= code2 && code2 <= 127386) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (127405 <= code2 && code2 <= 127461) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 128981) {
                    if (code2 < 127561) {
                      if (code2 < 127535) {
                        if (code2 < 127514) {
                          if (127489 <= code2 && code2 <= 127503) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 127514) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 127538) {
                          if (code2 === 127535) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127548) {
                            if (127538 <= code2 && code2 <= 127546) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (127548 <= code2 && code2 <= 127551) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 128326) {
                        if (code2 < 128e3) {
                          if (127561 <= code2 && code2 <= 127994) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (128e3 <= code2 && code2 <= 128317) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 128640) {
                          if (128326 <= code2 && code2 <= 128591) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 128884) {
                            if (128640 <= code2 && code2 <= 128767) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (128884 <= code2 && code2 <= 128895) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 129198) {
                      if (code2 < 129096) {
                        if (code2 < 129036) {
                          if (128981 <= code2 && code2 <= 129023) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129036 <= code2 && code2 <= 129039) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 129114) {
                          if (129096 <= code2 && code2 <= 129103) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 129160) {
                            if (129114 <= code2 && code2 <= 129119) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (129160 <= code2 && code2 <= 129167) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 129340) {
                        if (code2 < 129292) {
                          if (129198 <= code2 && code2 <= 129279) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129292 <= code2 && code2 <= 129338) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 129351) {
                          if (129340 <= code2 && code2 <= 129349) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 130048) {
                            if (129351 <= code2 && code2 <= 129791) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (130048 <= code2 && code2 <= 131069) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return boundaries_1.CLUSTER_BREAK.OTHER;
            }
          };
          exports2.default = Graphemer2;
        }
      });
      var require_lib2 = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/index.js"(exports2) {
          "use strict";
          var __importDefault = exports2 && exports2.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var Graphemer_1 = __importDefault(require_Graphemer());
          exports2.default = Graphemer_1.default;
        }
      });
      var require_dist2 = __commonJS2({
        "../../node_modules/.pnpm/iso-datestring-validator@2.2.2/node_modules/iso-datestring-validator/dist/index.js"(exports2) {
          (() => {
            "use strict";
            var e = { d: (t2, r2) => {
              for (var n2 in r2)
                e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
            }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
              typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
            } }, t = {};
            function r(e2, t2) {
              return t2 === void 0 && (t2 = "-"), new RegExp("^(?!0{4}" + t2 + "0{2}" + t2 + "0{2})((?=[0-9]{4}" + t2 + "(((0[^2])|1[0-2])|02(?=" + t2 + "(([0-1][0-9])|2[0-8])))" + t2 + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t2 + "02" + t2 + "29))([0-9]{4})" + t2 + "(?!((0[469])|11)" + t2 + "31)((0[1,3-9]|1[0-2])|(02(?!" + t2 + "3)))" + t2 + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e2);
            }
            function n(e2) {
              var t2 = /\D/.exec(e2);
              return t2 ? t2[0] : "";
            }
            function i(e2, t2, r2) {
              t2 === void 0 && (t2 = ":"), r2 === void 0 && (r2 = false);
              var i2 = new RegExp("^([0-1]|2(?=([0-3])|4" + t2 + "00))[0-9]" + t2 + "[0-5][0-9](" + t2 + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
              if (!r2 || !/[Z+\-]/.test(e2))
                return i2.test(e2);
              if (/Z$/.test(e2))
                return i2.test(e2.replace("Z", ""));
              var o2 = e2.includes("+"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];
              return i2.test(u2) && function(e3, t3, r3) {
                return r3 === void 0 && (r3 = ":"), new RegExp(t3 ? "^(0(?!(2" + r3 + "4)|0" + r3 + "3)|1(?=([0-1]|2(?=" + r3 + "[04])|[34](?=" + r3 + "0))))([03469](?=" + r3 + "[03])|[17](?=" + r3 + "0)|2(?=" + r3 + "[04])|5(?=" + r3 + "[034])|8(?=" + r3 + "[04]))" + r3 + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r3 + "[03])|[0-24-8](?=" + r3 + "00))" + r3 + "[03]0$").test(e3);
              }(d2, o2, n(d2));
            }
            function o(e2) {
              var t2 = e2.split("T"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));
              if (!a2)
                return false;
              var d2, s = (d2 = a2.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d2) ? d2[0] : "");
              return u2 && i(a2, s, true);
            }
            function a(e2, t2) {
              return t2 === void 0 && (t2 = "-"), new RegExp("^[0-9]{4}" + t2 + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e2);
            }
            e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });
            var u = exports2;
            for (var d in t)
              u[d] = t[d];
            t.__esModule && Object.defineProperty(u, "__esModule", { value: true });
          })();
        }
      });
      var src_exports2 = {};
      __export(src_exports2, {
        APP_BSKY_GRAPH: () => APP_BSKY_GRAPH,
        ActorNS: () => ActorNS,
        AdminNS: () => AdminNS,
        AppBskyActorDefs: () => defs_exports5,
        AppBskyActorGetPreferences: () => getPreferences_exports,
        AppBskyActorGetProfile: () => getProfile_exports,
        AppBskyActorGetProfiles: () => getProfiles_exports,
        AppBskyActorGetSuggestions: () => getSuggestions_exports,
        AppBskyActorProfile: () => profile_exports,
        AppBskyActorPutPreferences: () => putPreferences_exports,
        AppBskyActorSearchActors: () => searchActors_exports,
        AppBskyActorSearchActorsTypeahead: () => searchActorsTypeahead_exports,
        AppBskyEmbedExternal: () => external_exports,
        AppBskyEmbedImages: () => images_exports,
        AppBskyEmbedRecord: () => record_exports,
        AppBskyEmbedRecordWithMedia: () => recordWithMedia_exports,
        AppBskyFeedDefs: () => defs_exports6,
        AppBskyFeedDescribeFeedGenerator: () => describeFeedGenerator_exports,
        AppBskyFeedGenerator: () => generator_exports,
        AppBskyFeedGetActorFeeds: () => getActorFeeds_exports,
        AppBskyFeedGetActorLikes: () => getActorLikes_exports,
        AppBskyFeedGetAuthorFeed: () => getAuthorFeed_exports,
        AppBskyFeedGetFeed: () => getFeed_exports,
        AppBskyFeedGetFeedGenerator: () => getFeedGenerator_exports,
        AppBskyFeedGetFeedGenerators: () => getFeedGenerators_exports,
        AppBskyFeedGetFeedSkeleton: () => getFeedSkeleton_exports,
        AppBskyFeedGetLikes: () => getLikes_exports,
        AppBskyFeedGetListFeed: () => getListFeed_exports,
        AppBskyFeedGetPostThread: () => getPostThread_exports,
        AppBskyFeedGetPosts: () => getPosts_exports,
        AppBskyFeedGetRepostedBy: () => getRepostedBy_exports,
        AppBskyFeedGetSuggestedFeeds: () => getSuggestedFeeds_exports,
        AppBskyFeedGetTimeline: () => getTimeline_exports,
        AppBskyFeedLike: () => like_exports,
        AppBskyFeedPost: () => post_exports,
        AppBskyFeedRepost: () => repost_exports,
        AppBskyFeedSearchPosts: () => searchPosts_exports,
        AppBskyFeedThreadgate: () => threadgate_exports,
        AppBskyGraphBlock: () => block_exports,
        AppBskyGraphDefs: () => defs_exports7,
        AppBskyGraphFollow: () => follow_exports,
        AppBskyGraphGetBlocks: () => getBlocks_exports2,
        AppBskyGraphGetFollowers: () => getFollowers_exports,
        AppBskyGraphGetFollows: () => getFollows_exports,
        AppBskyGraphGetList: () => getList_exports,
        AppBskyGraphGetListBlocks: () => getListBlocks_exports,
        AppBskyGraphGetListMutes: () => getListMutes_exports,
        AppBskyGraphGetLists: () => getLists_exports,
        AppBskyGraphGetMutes: () => getMutes_exports,
        AppBskyGraphGetSuggestedFollowsByActor: () => getSuggestedFollowsByActor_exports,
        AppBskyGraphList: () => list_exports,
        AppBskyGraphListblock: () => listblock_exports,
        AppBskyGraphListitem: () => listitem_exports,
        AppBskyGraphMuteActor: () => muteActor_exports,
        AppBskyGraphMuteActorList: () => muteActorList_exports,
        AppBskyGraphUnmuteActor: () => unmuteActor_exports,
        AppBskyGraphUnmuteActorList: () => unmuteActorList_exports,
        AppBskyNotificationGetUnreadCount: () => getUnreadCount_exports,
        AppBskyNotificationListNotifications: () => listNotifications_exports,
        AppBskyNotificationRegisterPush: () => registerPush_exports,
        AppBskyNotificationUpdateSeen: () => updateSeen_exports,
        AppBskyRichtextFacet: () => facet_exports,
        AppBskyUnspeccedDefs: () => defs_exports8,
        AppBskyUnspeccedGetPopular: () => getPopular_exports,
        AppBskyUnspeccedGetPopularFeedGenerators: () => getPopularFeedGenerators_exports,
        AppBskyUnspeccedGetTimelineSkeleton: () => getTimelineSkeleton_exports,
        AppBskyUnspeccedSearchActorsSkeleton: () => searchActorsSkeleton_exports,
        AppBskyUnspeccedSearchPostsSkeleton: () => searchPostsSkeleton_exports,
        AppNS: () => AppNS,
        AtUri: () => AtUri,
        AtpAgent: () => AtpAgent,
        AtpBaseClient: () => AtpBaseClient,
        AtpServiceClient: () => AtpServiceClient,
        AtprotoNS: () => AtprotoNS,
        BlobRef: () => BlobRef,
        BlockRecord: () => BlockRecord,
        BskyAgent: () => BskyAgent2,
        BskyNS: () => BskyNS,
        COM_ATPROTO_ADMIN: () => COM_ATPROTO_ADMIN,
        COM_ATPROTO_MODERATION: () => COM_ATPROTO_MODERATION,
        ComAtprotoAdminDefs: () => defs_exports,
        ComAtprotoAdminDeleteAccount: () => deleteAccount_exports,
        ComAtprotoAdminDisableAccountInvites: () => disableAccountInvites_exports,
        ComAtprotoAdminDisableInviteCodes: () => disableInviteCodes_exports,
        ComAtprotoAdminEmitModerationEvent: () => emitModerationEvent_exports,
        ComAtprotoAdminEnableAccountInvites: () => enableAccountInvites_exports,
        ComAtprotoAdminGetAccountInfo: () => getAccountInfo_exports,
        ComAtprotoAdminGetInviteCodes: () => getInviteCodes_exports,
        ComAtprotoAdminGetModerationEvent: () => getModerationEvent_exports,
        ComAtprotoAdminGetRecord: () => getRecord_exports,
        ComAtprotoAdminGetRepo: () => getRepo_exports,
        ComAtprotoAdminGetSubjectStatus: () => getSubjectStatus_exports,
        ComAtprotoAdminQueryModerationEvents: () => queryModerationEvents_exports,
        ComAtprotoAdminQueryModerationStatuses: () => queryModerationStatuses_exports,
        ComAtprotoAdminSearchRepos: () => searchRepos_exports,
        ComAtprotoAdminSendEmail: () => sendEmail_exports,
        ComAtprotoAdminUpdateAccountEmail: () => updateAccountEmail_exports,
        ComAtprotoAdminUpdateAccountHandle: () => updateAccountHandle_exports,
        ComAtprotoAdminUpdateSubjectStatus: () => updateSubjectStatus_exports,
        ComAtprotoIdentityResolveHandle: () => resolveHandle_exports,
        ComAtprotoIdentityUpdateHandle: () => updateHandle_exports,
        ComAtprotoLabelDefs: () => defs_exports2,
        ComAtprotoLabelQueryLabels: () => queryLabels_exports,
        ComAtprotoLabelSubscribeLabels: () => subscribeLabels_exports,
        ComAtprotoModerationCreateReport: () => createReport_exports,
        ComAtprotoModerationDefs: () => defs_exports3,
        ComAtprotoRepoApplyWrites: () => applyWrites_exports,
        ComAtprotoRepoCreateRecord: () => createRecord_exports,
        ComAtprotoRepoDeleteRecord: () => deleteRecord_exports,
        ComAtprotoRepoDescribeRepo: () => describeRepo_exports,
        ComAtprotoRepoGetRecord: () => getRecord_exports2,
        ComAtprotoRepoListRecords: () => listRecords_exports,
        ComAtprotoRepoPutRecord: () => putRecord_exports,
        ComAtprotoRepoStrongRef: () => strongRef_exports,
        ComAtprotoRepoUploadBlob: () => uploadBlob_exports,
        ComAtprotoServerConfirmEmail: () => confirmEmail_exports,
        ComAtprotoServerCreateAccount: () => createAccount_exports,
        ComAtprotoServerCreateAppPassword: () => createAppPassword_exports,
        ComAtprotoServerCreateInviteCode: () => createInviteCode_exports,
        ComAtprotoServerCreateInviteCodes: () => createInviteCodes_exports,
        ComAtprotoServerCreateSession: () => createSession_exports,
        ComAtprotoServerDefs: () => defs_exports4,
        ComAtprotoServerDeleteAccount: () => deleteAccount_exports2,
        ComAtprotoServerDeleteSession: () => deleteSession_exports,
        ComAtprotoServerDescribeServer: () => describeServer_exports,
        ComAtprotoServerGetAccountInviteCodes: () => getAccountInviteCodes_exports,
        ComAtprotoServerGetSession: () => getSession_exports,
        ComAtprotoServerListAppPasswords: () => listAppPasswords_exports,
        ComAtprotoServerRefreshSession: () => refreshSession_exports,
        ComAtprotoServerRequestAccountDelete: () => requestAccountDelete_exports,
        ComAtprotoServerRequestEmailConfirmation: () => requestEmailConfirmation_exports,
        ComAtprotoServerRequestEmailUpdate: () => requestEmailUpdate_exports,
        ComAtprotoServerRequestPasswordReset: () => requestPasswordReset_exports,
        ComAtprotoServerReserveSigningKey: () => reserveSigningKey_exports,
        ComAtprotoServerResetPassword: () => resetPassword_exports,
        ComAtprotoServerRevokeAppPassword: () => revokeAppPassword_exports,
        ComAtprotoServerUpdateEmail: () => updateEmail_exports,
        ComAtprotoSyncGetBlob: () => getBlob_exports,
        ComAtprotoSyncGetBlocks: () => getBlocks_exports,
        ComAtprotoSyncGetCheckout: () => getCheckout_exports,
        ComAtprotoSyncGetHead: () => getHead_exports,
        ComAtprotoSyncGetLatestCommit: () => getLatestCommit_exports,
        ComAtprotoSyncGetRecord: () => getRecord_exports3,
        ComAtprotoSyncGetRepo: () => getRepo_exports2,
        ComAtprotoSyncListBlobs: () => listBlobs_exports,
        ComAtprotoSyncListRepos: () => listRepos_exports,
        ComAtprotoSyncNotifyOfUpdate: () => notifyOfUpdate_exports,
        ComAtprotoSyncRequestCrawl: () => requestCrawl_exports,
        ComAtprotoSyncSubscribeRepos: () => subscribeRepos_exports,
        ComAtprotoTempFetchLabels: () => fetchLabels_exports,
        ComAtprotoTempImportRepo: () => importRepo_exports,
        ComAtprotoTempPushBlob: () => pushBlob_exports,
        ComAtprotoTempTransferAccount: () => transferAccount_exports,
        ComNS: () => ComNS,
        EmbedNS: () => EmbedNS,
        FeedNS: () => FeedNS,
        FollowRecord: () => FollowRecord,
        GeneratorRecord: () => GeneratorRecord,
        GraphNS: () => GraphNS,
        IdentityNS: () => IdentityNS,
        LABELS: () => LABELS,
        LABEL_GROUPS: () => LABEL_GROUPS,
        LabelNS: () => LabelNS,
        LikeRecord: () => LikeRecord,
        ListRecord: () => ListRecord,
        ListblockRecord: () => ListblockRecord,
        ListitemRecord: () => ListitemRecord,
        ModerationDecision: () => ModerationDecision,
        ModerationNS: () => ModerationNS,
        NotificationNS: () => NotificationNS,
        PostRecord: () => PostRecord,
        ProfileRecord: () => ProfileRecord,
        RepoNS: () => RepoNS,
        RepostRecord: () => RepostRecord,
        RichText: () => RichText,
        RichTextSegment: () => RichTextSegment,
        RichtextNS: () => RichtextNS,
        ServerNS: () => ServerNS,
        SyncNS: () => SyncNS,
        TempNS: () => TempNS,
        ThreadgateRecord: () => ThreadgateRecord,
        UnicodeString: () => UnicodeString,
        UnspeccedNS: () => UnspeccedNS,
        default: () => AtpAgent,
        jsonStringToLex: () => jsonStringToLex,
        jsonToLex: () => jsonToLex,
        lexToJson: () => lexToJson,
        moderateFeedGenerator: () => moderateFeedGenerator,
        moderatePost: () => moderatePost,
        moderateProfile: () => moderateProfile,
        moderateUserList: () => moderateUserList,
        parseLanguage: () => parseLanguage,
        sanitizeRichText: () => sanitizeRichText,
        stringifyLex: () => stringifyLex
      });
      module.exports = __toCommonJS(src_exports2);
      var ensureValidHandle = (handle2) => {
        if (!/^[a-zA-Z0-9.-]*$/.test(handle2)) {
          throw new InvalidHandleError("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
        }
        if (handle2.length > 253) {
          throw new InvalidHandleError("Handle is too long (253 chars max)");
        }
        const labels = handle2.split(".");
        if (labels.length < 2) {
          throw new InvalidHandleError("Handle domain needs at least two parts");
        }
        for (let i = 0; i < labels.length; i++) {
          const l = labels[i];
          if (l.length < 1) {
            throw new InvalidHandleError("Handle parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidHandleError("Handle part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidHandleError("Handle parts can not start or end with hyphens");
          }
          if (i + 1 == labels.length && !/^[a-zA-Z]/.test(l)) {
            throw new InvalidHandleError("Handle final component (TLD) must start with ASCII letter");
          }
        }
      };
      var InvalidHandleError = class extends Error {
      };
      var ensureValidDid = (did2) => {
        if (!/^[a-zA-Z0-9._:%-]*$/.test(did2)) {
          throw new InvalidDidError("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
        }
        const parts = did2.split(":");
        if (parts.length < 3) {
          throw new InvalidDidError("DID requires prefix, method, and method-specific content");
        }
        if (parts[0] != "did") {
          throw new InvalidDidError('DID requires "did:" prefix');
        }
        if (!/^[a-z]+$/.test(parts[1])) {
          throw new InvalidDidError("DID method must be lower-case letters");
        }
        if (did2.endsWith(":") || did2.endsWith("%")) {
          throw new InvalidDidError('DID can not end with ":" or "%"');
        }
        if (did2.length > 2 * 1024) {
          throw new InvalidDidError("DID is too long (2048 chars max)");
        }
      };
      var InvalidDidError = class extends Error {
      };
      var NSID = class {
        constructor(nsid2) {
          this.segments = [];
          ensureValidNsid(nsid2);
          this.segments = nsid2.split(".");
        }
        static parse(nsid2) {
          return new NSID(nsid2);
        }
        static create(authority, name2) {
          const segments = [...authority.split(".").reverse(), name2].join(".");
          return new NSID(segments);
        }
        static isValid(nsid2) {
          try {
            NSID.parse(nsid2);
            return true;
          } catch (e) {
            return false;
          }
        }
        get authority() {
          return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
        }
        get name() {
          return this.segments.at(this.segments.length - 1);
        }
        toString() {
          return this.segments.join(".");
        }
      };
      var ensureValidNsid = (nsid2) => {
        const toCheck = nsid2;
        if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
          throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
        }
        if (toCheck.length > 253 + 1 + 63) {
          throw new InvalidNsidError("NSID is too long (317 chars max)");
        }
        const labels = toCheck.split(".");
        if (labels.length < 3) {
          throw new InvalidNsidError("NSID needs at least three parts");
        }
        for (let i = 0; i < labels.length; i++) {
          const l = labels[i];
          if (l.length < 1) {
            throw new InvalidNsidError("NSID parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidNsidError("NSID part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidNsidError("NSID parts can not start or end with hyphen");
          }
          if (/^[0-9]/.test(l) && i == 0) {
            throw new InvalidNsidError("NSID first part may not start with a digit");
          }
          if (!/^[a-zA-Z]+$/.test(l) && i + 1 == labels.length) {
            throw new InvalidNsidError("NSID name part must be only letters");
          }
        }
      };
      var InvalidNsidError = class extends Error {
      };
      var ensureValidAtUri = (uri2) => {
        const uriParts = uri2.split("#");
        if (uriParts.length > 2) {
          throw new Error('ATURI can have at most one "#", separating fragment out');
        }
        const fragmentPart = uriParts[1] || null;
        uri2 = uriParts[0];
        if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri2)) {
          throw new Error("Disallowed characters in ATURI (ASCII)");
        }
        const parts = uri2.split("/");
        if (parts.length >= 3 && (parts[0] != "at:" || parts[1].length != 0)) {
          throw new Error('ATURI must start with "at://"');
        }
        if (parts.length < 3) {
          throw new Error("ATURI requires at least method and authority sections");
        }
        try {
          if (parts[2].startsWith("did:")) {
            ensureValidDid(parts[2]);
          } else {
            ensureValidHandle(parts[2]);
          }
        } catch (e) {
          throw new Error("ATURI authority must be a valid handle or DID");
        }
        if (parts.length >= 4) {
          if (parts[3].length == 0) {
            throw new Error("ATURI can not have a slash after authority without a path segment");
          }
          try {
            ensureValidNsid(parts[3]);
          } catch (e) {
            throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
          }
        }
        if (parts.length >= 5) {
          if (parts[4].length == 0) {
            throw new Error("ATURI can not have a slash after collection, unless record key is provided");
          }
        }
        if (parts.length >= 6) {
          throw new Error("ATURI path can have at most two parts, and no trailing slash");
        }
        if (uriParts.length >= 2 && fragmentPart == null) {
          throw new Error("ATURI fragment must be non-empty and start with slash");
        }
        if (fragmentPart != null) {
          if (fragmentPart.length == 0 || fragmentPart[0] != "/") {
            throw new Error("ATURI fragment must be non-empty and start with slash");
          }
          if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
            throw new Error("Disallowed characters in ATURI fragment (ASCII)");
          }
        }
        if (uri2.length > 8 * 1024) {
          throw new Error("ATURI is far too long");
        }
      };
      var ATP_URI_REGEX = /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      var RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      var AtUri = class {
        constructor(uri2, base3) {
          let parsed;
          if (base3) {
            parsed = parse(base3);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${base3}`);
            }
            const relativep = parseRelative(uri2);
            if (!relativep) {
              throw new Error(`Invalid path: ${uri2}`);
            }
            Object.assign(parsed, relativep);
          } else {
            parsed = parse(uri2);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${uri2}`);
            }
          }
          this.hash = parsed.hash;
          this.host = parsed.host;
          this.pathname = parsed.pathname;
          this.searchParams = parsed.searchParams;
        }
        static make(handleOrDid, collection, rkey) {
          let str = handleOrDid;
          if (collection)
            str += "/" + collection;
          if (rkey)
            str += "/" + rkey;
          return new AtUri(str);
        }
        get protocol() {
          return "at:";
        }
        get origin() {
          return `at://${this.host}`;
        }
        get hostname() {
          return this.host;
        }
        set hostname(v) {
          this.host = v;
        }
        get search() {
          return this.searchParams.toString();
        }
        set search(v) {
          this.searchParams = new URLSearchParams(v);
        }
        get collection() {
          return this.pathname.split("/").filter(Boolean)[0] || "";
        }
        set collection(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          parts[0] = v;
          this.pathname = parts.join("/");
        }
        get rkey() {
          return this.pathname.split("/").filter(Boolean)[1] || "";
        }
        set rkey(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          if (!parts[0])
            parts[0] = "undefined";
          parts[1] = v;
          this.pathname = parts.join("/");
        }
        get href() {
          return this.toString();
        }
        toString() {
          let path = this.pathname || "/";
          if (!path.startsWith("/")) {
            path = `/${path}`;
          }
          let qs = this.searchParams.toString();
          if (qs && !qs.startsWith("?")) {
            qs = `?${qs}`;
          }
          let hash = this.hash;
          if (hash && !hash.startsWith("#")) {
            hash = `#${hash}`;
          }
          return `at://${this.host}${path}${qs}${hash}`;
        }
      };
      function parse(str) {
        const match = ATP_URI_REGEX.exec(str);
        if (match) {
          return {
            hash: match[5] || "",
            host: match[2] || "",
            pathname: match[3] || "",
            searchParams: new URLSearchParams(match[4] || "")
          };
        }
        return void 0;
      }
      function parseRelative(str) {
        const match = RELATIVE_REGEX.exec(str);
        if (match) {
          return {
            hash: match[3] || "",
            pathname: match[1] || "",
            searchParams: new URLSearchParams(match[2] || "")
          };
        }
        return void 0;
      }
      var util;
      (function(util2) {
        util2.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util2.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util2.assertNever = assertNever;
        util2.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util2.getValidEnumValues = (obj) => {
          const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
          const filtered = {};
          for (const k of validKeys) {
            filtered[k] = obj[k];
          }
          return util2.objectValues(filtered);
        };
        util2.objectValues = (obj) => {
          return util2.objectKeys(obj).map(function(e) {
            return obj[e];
          });
        };
        util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
          const keys = [];
          for (const key in object2) {
            if (Object.prototype.hasOwnProperty.call(object2, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        util2.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array2, separator = " | ") {
          return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util2.joinValues = joinValues;
        util2.jsonStringifyReplacer = (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util || (util = {}));
      var objectUtil;
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return __spreadValues(__spreadValues({}, first), second);
        };
      })(objectUtil || (objectUtil = {}));
      var ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      var getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "undefined":
            return ZodParsedType.undefined;
          case "string":
            return ZodParsedType.string;
          case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
          case "boolean":
            return ZodParsedType.boolean;
          case "function":
            return ZodParsedType.function;
          case "bigint":
            return ZodParsedType.bigint;
          case "symbol":
            return ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return ZodParsedType.array;
            }
            if (data === null) {
              return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return ZodParsedType.date;
            }
            return ZodParsedType.object;
          default:
            return ZodParsedType.unknown;
        }
      };
      var ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
      ]);
      var quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
      };
      var ZodError = class extends Error {
        constructor(issues) {
          super();
          this.issues = [];
          this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
          };
          this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
          };
          const actualProto = new.target.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
          } else {
            this.__proto__ = actualProto;
          }
          this.name = "ZodError";
          this.issues = issues;
        }
        get errors() {
          return this.issues;
        }
        format(_mapper) {
          const mapper = _mapper || function(issue) {
            return issue.message;
          };
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union") {
                issue.unionErrors.map(processError);
              } else if (issue.code === "invalid_return_type") {
                processError(issue.returnTypeError);
              } else if (issue.code === "invalid_arguments") {
                processError(issue.argumentsError);
              } else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              } else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                  const el = issue.path[i];
                  const terminal = i === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  } else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i++;
                }
              }
            }
          };
          processError(this);
          return fieldErrors;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub of this.issues) {
            if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
              formErrors.push(mapper(sub));
            }
          }
          return { formErrors, fieldErrors };
        }
        get formErrors() {
          return this.flatten();
        }
      };
      ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
      };
      var errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
          case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
              message = "Required";
            } else {
              message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
          case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
          case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
          case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
          case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
          case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
          case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
          case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
          case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
              if ("includes" in issue.validation) {
                message = `Invalid input: must include "${issue.validation.includes}"`;
                if (typeof issue.validation.position === "number") {
                  message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                }
              } else if ("startsWith" in issue.validation) {
                message = `Invalid input: must start with "${issue.validation.startsWith}"`;
              } else if ("endsWith" in issue.validation) {
                message = `Invalid input: must end with "${issue.validation.endsWith}"`;
              } else {
                util.assertNever(issue.validation);
              }
            } else if (issue.validation !== "regex") {
              message = `Invalid ${issue.validation}`;
            } else {
              message = "Invalid";
            }
            break;
          case ZodIssueCode.too_small:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.too_big:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
              message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
          case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
          case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
          default:
            message = _ctx.defaultError;
            util.assertNever(issue);
        }
        return { message };
      };
      var overrideErrorMap = errorMap;
      function setErrorMap(map) {
        overrideErrorMap = map;
      }
      function getErrorMap() {
        return overrideErrorMap;
      }
      var makeIssue = (params2) => {
        const { data, path, errorMaps, issueData } = params2;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = __spreadProps(__spreadValues({}, issueData), {
          path: fullPath
        });
        let errorMessage = "";
        const maps = errorMaps.filter((m) => !!m).slice().reverse();
        for (const map of maps) {
          errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return __spreadProps(__spreadValues({}, issueData), {
          path: fullPath,
          message: issueData.message || errorMessage
        });
      };
      var EMPTY_PATH = [];
      function addIssueToContext(ctx, issueData) {
        const issue = makeIssue({
          issueData,
          data: ctx.data,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x)
        });
        ctx.common.issues.push(issue);
      }
      var ParseStatus = class {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s of results) {
            if (s.status === "aborted")
              return INVALID;
            if (s.status === "dirty")
              status.dirty();
            arrayValue.push(s.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static mergeObjectAsync(status, pairs) {
          return __async(this, null, function* () {
            const syncPairs = [];
            for (const pair of pairs) {
              syncPairs.push({
                key: yield pair.key,
                value: yield pair.value
              });
            }
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return INVALID;
            if (value.status === "aborted")
              return INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      };
      var INVALID = Object.freeze({
        status: "aborted"
      });
      var DIRTY = (value) => ({ status: "dirty", value });
      var OK = (value) => ({ status: "valid", value });
      var isAborted = (x) => x.status === "aborted";
      var isDirty = (x) => x.status === "dirty";
      var isValid = (x) => x.status === "valid";
      var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
      var errorUtil;
      (function(errorUtil2) {
        errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
      })(errorUtil || (errorUtil = {}));
      var ParseInputLazyPath = class {
        constructor(parent, value, path, key) {
          this._cachedPath = [];
          this.parent = parent;
          this.data = value;
          this._path = path;
          this._key = key;
        }
        get path() {
          if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
              this._cachedPath.push(...this._path, ...this._key);
            } else {
              this._cachedPath.push(...this._path, this._key);
            }
          }
          return this._cachedPath;
        }
      };
      var handleResult = (ctx, result) => {
        if (isValid(result)) {
          return { success: true, data: result.value };
        } else {
          if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
          }
          return {
            success: false,
            get error() {
              if (this._error)
                return this._error;
              const error = new ZodError(ctx.common.issues);
              this._error = error;
              return this._error;
            }
          };
        }
      };
      function processCreateParams(params2) {
        if (!params2)
          return {};
        const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
        if (errorMap2 && (invalid_type_error || required_error)) {
          throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        }
        if (errorMap2)
          return { errorMap: errorMap2, description };
        const customMap = (iss, ctx) => {
          if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
          if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
          }
          return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
        };
        return { errorMap: customMap, description };
      }
      var ZodType = class {
        constructor(def2) {
          this.spa = this.safeParseAsync;
          this._def = def2;
          this.parse = this.parse.bind(this);
          this.safeParse = this.safeParse.bind(this);
          this.parseAsync = this.parseAsync.bind(this);
          this.safeParseAsync = this.safeParseAsync.bind(this);
          this.spa = this.spa.bind(this);
          this.refine = this.refine.bind(this);
          this.refinement = this.refinement.bind(this);
          this.superRefine = this.superRefine.bind(this);
          this.optional = this.optional.bind(this);
          this.nullable = this.nullable.bind(this);
          this.nullish = this.nullish.bind(this);
          this.array = this.array.bind(this);
          this.promise = this.promise.bind(this);
          this.or = this.or.bind(this);
          this.and = this.and.bind(this);
          this.transform = this.transform.bind(this);
          this.brand = this.brand.bind(this);
          this.default = this.default.bind(this);
          this.catch = this.catch.bind(this);
          this.describe = this.describe.bind(this);
          this.pipe = this.pipe.bind(this);
          this.isNullable = this.isNullable.bind(this);
          this.isOptional = this.isOptional.bind(this);
        }
        get description() {
          return this._def.description;
        }
        _getType(input) {
          return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
          return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          };
        }
        _processInputParams(input) {
          return {
            status: new ParseStatus(),
            ctx: {
              common: input.parent.common,
              data: input.data,
              parsedType: getParsedType(input.data),
              schemaErrorMap: this._def.errorMap,
              path: input.path,
              parent: input.parent
            }
          };
        }
        _parseSync(input) {
          const result = this._parse(input);
          if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
          }
          return result;
        }
        _parseAsync(input) {
          const result = this._parse(input);
          return Promise.resolve(result);
        }
        parse(data, params2) {
          const result = this.safeParse(data, params2);
          if (result.success)
            return result.data;
          throw result.error;
        }
        safeParse(data, params2) {
          var _a2;
          const ctx = {
            common: {
              issues: [],
              async: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a2 !== void 0 ? _a2 : false,
              contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
            },
            path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const result = this._parseSync({ data, path: ctx.path, parent: ctx });
          return handleResult(ctx, result);
        }
        parseAsync(data, params2) {
          return __async(this, null, function* () {
            const result = yield this.safeParseAsync(data, params2);
            if (result.success)
              return result.data;
            throw result.error;
          });
        }
        safeParseAsync(data, params2) {
          return __async(this, null, function* () {
            const ctx = {
              common: {
                issues: [],
                contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
                async: true
              },
              path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data,
              parsedType: getParsedType(data)
            };
            const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
            const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
            return handleResult(ctx, result);
          });
        }
        refine(check, message) {
          const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
              return { message };
            } else if (typeof message === "function") {
              return message(val);
            } else {
              return message;
            }
          };
          return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue(__spreadValues({
              code: ZodIssueCode.custom
            }, getIssueProperties(val)));
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then((data) => {
                if (!data) {
                  setError();
                  return false;
                } else {
                  return true;
                }
              });
            }
            if (!result) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        refinement(check, refinementData) {
          return this._refinement((val, ctx) => {
            if (!check(val)) {
              ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
              return false;
            } else {
              return true;
            }
          });
        }
        _refinement(refinement) {
          return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement }
          });
        }
        superRefine(refinement) {
          return this._refinement(refinement);
        }
        optional() {
          return ZodOptional.create(this, this._def);
        }
        nullable() {
          return ZodNullable.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return ZodArray.create(this, this._def);
        }
        promise() {
          return ZodPromise.create(this, this._def);
        }
        or(option) {
          return ZodUnion.create([this, option], this._def);
        }
        and(incoming) {
          return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
          return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform }
          }));
        }
        default(def2) {
          const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
          return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
          }));
        }
        brand() {
          return new ZodBranded(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this
          }, processCreateParams(this._def)));
        }
        catch(def2) {
          const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
          return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
          }));
        }
        describe(description) {
          const This = this.constructor;
          return new This(__spreadProps(__spreadValues({}, this._def), {
            description
          }));
        }
        pipe(target2) {
          return ZodPipeline.create(this, target2);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      };
      var cuidRegex = /^c[^\s-]{8,}$/i;
      var cuid2Regex = /^[a-z][a-z0-9]*$/;
      var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
      var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
      var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
      var emojiRegex = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
      var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
      var datetimeRegex = (args) => {
        if (args.precision) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
          }
        } else if (args.precision === 0) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
          }
        } else {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
          }
        }
      };
      function isValidIP(ip, version2) {
        if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
          return true;
        }
        if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
          return true;
        }
        return false;
      }
      var ZodString = class extends ZodType {
        constructor() {
          super(...arguments);
          this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), __spreadValues({
            validation,
            code: ZodIssueCode.invalid_string
          }, errorUtil.errToObj(message)));
          this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
          this.trim = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "trim" }]
          }));
          this.toLowerCase = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toLowerCase" }]
          }));
          this.toUpperCase = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toUpperCase" }]
          }));
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = String(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.length < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.length > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "length") {
              const tooBig = input.data.length > check.value;
              const tooSmall = input.data.length < check.value;
              if (tooBig || tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                if (tooBig) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                } else if (tooSmall) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                }
                status.dirty();
              }
            } else if (check.kind === "email") {
              if (!emailRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "email",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "emoji") {
              if (!emojiRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "emoji",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "uuid") {
              if (!uuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "uuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid") {
              if (!cuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid2") {
              if (!cuid2Regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid2",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ulid") {
              if (!ulidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ulid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "url") {
              try {
                new URL(input.data);
              } catch (_a2) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "url",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "regex") {
              check.regex.lastIndex = 0;
              const testResult = check.regex.test(input.data);
              if (!testResult) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "regex",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "trim") {
              input.data = input.data.trim();
            } else if (check.kind === "includes") {
              if (!input.data.includes(check.value, check.position)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { includes: check.value, position: check.position },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "toLowerCase") {
              input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
              input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
              if (!input.data.startsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { startsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "endsWith") {
              if (!input.data.endsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { endsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "datetime") {
              const regex = datetimeRegex(check);
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: "datetime",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ip") {
              if (!isValidIP(input.data, check.version)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ip",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        _addCheck(check) {
          return new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        email(message) {
          return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
        }
        url(message) {
          return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
        }
        emoji(message) {
          return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
        }
        uuid(message) {
          return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
        }
        cuid(message) {
          return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
        }
        cuid2(message) {
          return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
        }
        ulid(message) {
          return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
        }
        ip(options) {
          return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
        }
        datetime(options) {
          var _a2;
          if (typeof options === "string") {
            return this._addCheck({
              kind: "datetime",
              precision: null,
              offset: false,
              message: options
            });
          }
          return this._addCheck(__spreadValues({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        regex(regex, message) {
          return this._addCheck(__spreadValues({
            kind: "regex",
            regex
          }, errorUtil.errToObj(message)));
        }
        includes(value, options) {
          return this._addCheck(__spreadValues({
            kind: "includes",
            value,
            position: options === null || options === void 0 ? void 0 : options.position
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        startsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "startsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        endsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "endsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        min(minLength, message) {
          return this._addCheck(__spreadValues({
            kind: "min",
            value: minLength
          }, errorUtil.errToObj(message)));
        }
        max(maxLength, message) {
          return this._addCheck(__spreadValues({
            kind: "max",
            value: maxLength
          }, errorUtil.errToObj(message)));
        }
        length(len, message) {
          return this._addCheck(__spreadValues({
            kind: "length",
            value: len
          }, errorUtil.errToObj(message)));
        }
        get isDatetime() {
          return !!this._def.checks.find((ch) => ch.kind === "datetime");
        }
        get isEmail() {
          return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
          return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isEmoji() {
          return !!this._def.checks.find((ch) => ch.kind === "emoji");
        }
        get isUUID() {
          return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get isCUID2() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid2");
        }
        get isULID() {
          return !!this._def.checks.find((ch) => ch.kind === "ulid");
        }
        get isIP() {
          return !!this._def.checks.find((ch) => ch.kind === "ip");
        }
        get minLength() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxLength() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodString.create = (params2) => {
        var _a2;
        return new ZodString(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodString,
          coerce: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a2 !== void 0 ? _a2 : false
        }, processCreateParams(params2)));
      };
      function floatSafeRemainder(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
        return valInt % stepInt / Math.pow(10, decCount);
      }
      var ZodNumber = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
          this.step = this.multipleOf;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = Number(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.number,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "int") {
              if (!util.isInteger(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (floatSafeRemainder(input.data, check.value) !== 0) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "finite") {
              if (!Number.isFinite(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_finite,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        int(message) {
          return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        finite(message) {
          return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message)
          });
        }
        safe(message) {
          return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message)
          })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
        get isInt() {
          return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
        }
        get isFinite() {
          let max = null, min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
              return true;
            } else if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            } else if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return Number.isFinite(min) && Number.isFinite(max);
        }
      };
      ZodNumber.create = (params2) => {
        return new ZodNumber(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodNumber,
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false
        }, processCreateParams(params2)));
      };
      var ZodBigInt = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = BigInt(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.bigint) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.bigint,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  type: "bigint",
                  minimum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  type: "bigint",
                  maximum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (input.data % check.value !== BigInt(0)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodBigInt.create = (params2) => {
        var _a2;
        return new ZodBigInt(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodBigInt,
          coerce: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a2 !== void 0 ? _a2 : false
        }, processCreateParams(params2)));
      };
      var ZodBoolean = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = Boolean(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.boolean,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodBoolean.create = (params2) => {
        return new ZodBoolean(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodBoolean,
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false
        }, processCreateParams(params2)));
      };
      var ZodDate = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = new Date(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.date,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          if (isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_date
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.getTime() < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  minimum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.getTime() > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  maximum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return {
            status: status.value,
            value: new Date(input.data.getTime())
          };
        }
        _addCheck(check) {
          return new ZodDate(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        min(minDate, message) {
          return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        max(maxDate, message) {
          return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        get minDate() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min != null ? new Date(min) : null;
        }
        get maxDate() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max != null ? new Date(max) : null;
        }
      };
      ZodDate.create = (params2) => {
        return new ZodDate(__spreadValues({
          checks: [],
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
          typeName: ZodFirstPartyTypeKind.ZodDate
        }, processCreateParams(params2)));
      };
      var ZodSymbol = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.symbol,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodSymbol.create = (params2) => {
        return new ZodSymbol(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodSymbol
        }, processCreateParams(params2)));
      };
      var ZodUndefined = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.undefined,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodUndefined.create = (params2) => {
        return new ZodUndefined(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUndefined
        }, processCreateParams(params2)));
      };
      var ZodNull = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.null,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodNull.create = (params2) => {
        return new ZodNull(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNull
        }, processCreateParams(params2)));
      };
      var ZodAny = class extends ZodType {
        constructor() {
          super(...arguments);
          this._any = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodAny.create = (params2) => {
        return new ZodAny(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodAny
        }, processCreateParams(params2)));
      };
      var ZodUnknown = class extends ZodType {
        constructor() {
          super(...arguments);
          this._unknown = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodUnknown.create = (params2) => {
        return new ZodUnknown(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUnknown
        }, processCreateParams(params2)));
      };
      var ZodNever = class extends ZodType {
        _parse(input) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
          });
          return INVALID;
        }
      };
      ZodNever.create = (params2) => {
        return new ZodNever(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNever
        }, processCreateParams(params2)));
      };
      var ZodVoid = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.void,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodVoid.create = (params2) => {
        return new ZodVoid(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodVoid
        }, processCreateParams(params2)));
      };
      var ZodArray = class extends ZodType {
        _parse(input) {
          const { ctx, status } = this._processInputParams(input);
          const def2 = this._def;
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (def2.exactLength !== null) {
            const tooBig = ctx.data.length > def2.exactLength.value;
            const tooSmall = ctx.data.length < def2.exactLength.value;
            if (tooBig || tooSmall) {
              addIssueToContext(ctx, {
                code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                minimum: tooSmall ? def2.exactLength.value : void 0,
                maximum: tooBig ? def2.exactLength.value : void 0,
                type: "array",
                inclusive: true,
                exact: true,
                message: def2.exactLength.message
              });
              status.dirty();
            }
          }
          if (def2.minLength !== null) {
            if (ctx.data.length < def2.minLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def2.minLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def2.minLength.message
              });
              status.dirty();
            }
          }
          if (def2.maxLength !== null) {
            if (ctx.data.length > def2.maxLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def2.maxLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def2.maxLength.message
              });
              status.dirty();
            }
          }
          if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
              return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result2) => {
              return ParseStatus.mergeArray(status, result2);
            });
          }
          const result = [...ctx.data].map((item, i) => {
            return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          });
          return ParseStatus.mergeArray(status, result);
        }
        get element() {
          return this._def.type;
        }
        min(minLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            minLength: { value: minLength, message: errorUtil.toString(message) }
          }));
        }
        max(maxLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            maxLength: { value: maxLength, message: errorUtil.toString(message) }
          }));
        }
        length(len, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            exactLength: { value: len, message: errorUtil.toString(message) }
          }));
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodArray.create = (schema2, params2) => {
        return new ZodArray(__spreadValues({
          type: schema2,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: ZodFirstPartyTypeKind.ZodArray
        }, processCreateParams(params2)));
      };
      function deepPartialify(schema2) {
        if (schema2 instanceof ZodObject) {
          const newShape = {};
          for (const key in schema2.shape) {
            const fieldSchema = schema2.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
          }
          return new ZodObject(__spreadProps(__spreadValues({}, schema2._def), {
            shape: () => newShape
          }));
        } else if (schema2 instanceof ZodArray) {
          return new ZodArray(__spreadProps(__spreadValues({}, schema2._def), {
            type: deepPartialify(schema2.element)
          }));
        } else if (schema2 instanceof ZodOptional) {
          return ZodOptional.create(deepPartialify(schema2.unwrap()));
        } else if (schema2 instanceof ZodNullable) {
          return ZodNullable.create(deepPartialify(schema2.unwrap()));
        } else if (schema2 instanceof ZodTuple) {
          return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
        } else {
          return schema2;
        }
      }
      var ZodObject = class extends ZodType {
        constructor() {
          super(...arguments);
          this._cached = null;
          this.nonstrict = this.passthrough;
          this.augment = this.extend;
        }
        _getCached() {
          if (this._cached !== null)
            return this._cached;
          const shape = this._def.shape();
          const keys = util.objectKeys(shape);
          return this._cached = { shape, keys };
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const { status, ctx } = this._processInputParams(input);
          const { shape, keys: shapeKeys } = this._getCached();
          const extraKeys = [];
          if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
              if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
              }
            }
          }
          const pairs = [];
          for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
              for (const key of extraKeys) {
                pairs.push({
                  key: { status: "valid", value: key },
                  value: { status: "valid", value: ctx.data[key] }
                });
              }
            } else if (unknownKeys === "strict") {
              if (extraKeys.length > 0) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.unrecognized_keys,
                  keys: extraKeys
                });
                status.dirty();
              }
            } else if (unknownKeys === "strip")
              ;
            else {
              throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
          } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
              const value = ctx.data[key];
              pairs.push({
                key: { status: "valid", value: key },
                value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
              });
            }
          }
          if (ctx.common.async) {
            return Promise.resolve().then(() => __async(this, null, function* () {
              const syncPairs = [];
              for (const pair of pairs) {
                const key = yield pair.key;
                syncPairs.push({
                  key,
                  value: yield pair.value,
                  alwaysSet: pair.alwaysSet
                });
              }
              return syncPairs;
            })).then((syncPairs) => {
              return ParseStatus.mergeObjectSync(status, syncPairs);
            });
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get shape() {
          return this._def.shape();
        }
        strict(message) {
          errorUtil.errToObj;
          return new ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strict"
          }), message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a2, _b, _c, _d;
              const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}));
        }
        strip() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strip"
          }));
        }
        passthrough() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "passthrough"
          }));
        }
        extend(augmentation) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
          }));
        }
        merge(merging) {
          const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject
          });
          return merged;
        }
        setKey(key, schema2) {
          return this.augment({ [key]: schema2 });
        }
        catchall(index) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            catchall: index
          }));
        }
        pick(mask) {
          const shape = {};
          util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        omit(mask) {
          const shape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        deepPartial() {
          return deepPartialify(this);
        }
        partial(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
              newShape[key] = fieldSchema;
            } else {
              newShape[key] = fieldSchema.optional();
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        required(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        keyof() {
          return createZodEnum(util.objectKeys(this.shape));
        }
      };
      ZodObject.create = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      ZodObject.strictCreate = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strict",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      ZodObject.lazycreate = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      var ZodUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const options = this._def.options;
          function handleResults(results) {
            for (const result of results) {
              if (result.result.status === "valid") {
                return result.result;
              }
            }
            for (const result of results) {
              if (result.result.status === "dirty") {
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
              }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return Promise.all(options.map((option) => __async(this, null, function* () {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              return {
                result: yield option._parseAsync({
                  data: ctx.data,
                  path: ctx.path,
                  parent: childCtx
                }),
                ctx: childCtx
              };
            }))).then(handleResults);
          } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              const result = option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              });
              if (result.status === "valid") {
                return result;
              } else if (result.status === "dirty" && !dirty) {
                dirty = { result, ctx: childCtx };
              }
              if (childCtx.common.issues.length) {
                issues.push(childCtx.common.issues);
              }
            }
            if (dirty) {
              ctx.common.issues.push(...dirty.ctx.common.issues);
              return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError(issues2));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      ZodUnion.create = (types, params2) => {
        return new ZodUnion(__spreadValues({
          options: types,
          typeName: ZodFirstPartyTypeKind.ZodUnion
        }, processCreateParams(params2)));
      };
      var getDiscriminator = (type) => {
        if (type instanceof ZodLazy) {
          return getDiscriminator(type.schema);
        } else if (type instanceof ZodEffects) {
          return getDiscriminator(type.innerType());
        } else if (type instanceof ZodLiteral) {
          return [type.value];
        } else if (type instanceof ZodEnum) {
          return type.options;
        } else if (type instanceof ZodNativeEnum) {
          return Object.keys(type.enum);
        } else if (type instanceof ZodDefault) {
          return getDiscriminator(type._def.innerType);
        } else if (type instanceof ZodUndefined) {
          return [void 0];
        } else if (type instanceof ZodNull) {
          return [null];
        } else {
          return null;
        }
      };
      var ZodDiscriminatedUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const discriminator = this.discriminator;
          const discriminatorValue = ctx.data[discriminator];
          const option = this.optionsMap.get(discriminatorValue);
          if (!option) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [discriminator]
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          } else {
            return option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(discriminator, options, params2) {
          const optionsMap = /* @__PURE__ */ new Map();
          for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
              throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
              if (optionsMap.has(value)) {
                throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
              }
              optionsMap.set(value, type);
            }
          }
          return new ZodDiscriminatedUnion(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap
          }, processCreateParams(params2)));
        }
      };
      function mergeValues(a, b) {
        const aType = getParsedType(a);
        const bType = getParsedType(b);
        if (a === b) {
          return { valid: true, data: a };
        } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
          const bKeys = util.objectKeys(b);
          const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
          const newObj = __spreadValues(__spreadValues({}, a), b);
          for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newObj[key] = sharedValue.data;
          }
          return { valid: true, data: newObj };
        } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
          if (a.length !== b.length) {
            return { valid: false };
          }
          const newArray = [];
          for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newArray.push(sharedValue.data);
          }
          return { valid: true, data: newArray };
        } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
          return { valid: true, data: a };
        } else {
          return { valid: false };
        }
      }
      var ZodIntersection = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
              return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_intersection_types
              });
              return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
              status.dirty();
            }
            return { status: status.value, value: merged.data };
          };
          if (ctx.common.async) {
            return Promise.all([
              this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              }),
              this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              })
            ]).then(([left, right]) => handleParsed(left, right));
          } else {
            return handleParsed(this._def.left._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }), this._def.right._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }));
          }
        }
      };
      ZodIntersection.create = (left, right, params2) => {
        return new ZodIntersection(__spreadValues({
          left,
          right,
          typeName: ZodFirstPartyTypeKind.ZodIntersection
        }, processCreateParams(params2)));
      };
      var ZodTuple = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            return INVALID;
          }
          const rest = this._def.rest;
          if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            status.dirty();
          }
          const items = [...ctx.data].map((item, itemIndex) => {
            const schema2 = this._def.items[itemIndex] || this._def.rest;
            if (!schema2)
              return null;
            return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
          }).filter((x) => !!x);
          if (ctx.common.async) {
            return Promise.all(items).then((results) => {
              return ParseStatus.mergeArray(status, results);
            });
          } else {
            return ParseStatus.mergeArray(status, items);
          }
        }
        get items() {
          return this._def.items;
        }
        rest(rest) {
          return new ZodTuple(__spreadProps(__spreadValues({}, this._def), {
            rest
          }));
        }
      };
      ZodTuple.create = (schemas2, params2) => {
        if (!Array.isArray(schemas2)) {
          throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple(__spreadValues({
          items: schemas2,
          typeName: ZodFirstPartyTypeKind.ZodTuple,
          rest: null
        }, processCreateParams(params2)));
      };
      var ZodRecord = class extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const pairs = [];
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          for (const key in ctx.data) {
            pairs.push({
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
              value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
            });
          }
          if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get element() {
          return this._def.valueType;
        }
        static create(first, second, third) {
          if (second instanceof ZodType) {
            return new ZodRecord(__spreadValues({
              keyType: first,
              valueType: second,
              typeName: ZodFirstPartyTypeKind.ZodRecord
            }, processCreateParams(third)));
          }
          return new ZodRecord(__spreadValues({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord
          }, processCreateParams(second)));
        }
      };
      var ZodMap = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.map,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
              value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
            };
          });
          if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(() => __async(this, null, function* () {
              for (const pair of pairs) {
                const key = yield pair.key;
                const value = yield pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                  return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                  status.dirty();
                }
                finalMap.set(key.value, value.value);
              }
              return { status: status.value, value: finalMap };
            }));
          } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
              const key = pair.key;
              const value = pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          }
        }
      };
      ZodMap.create = (keyType, valueType, params2) => {
        return new ZodMap(__spreadValues({
          valueType,
          keyType,
          typeName: ZodFirstPartyTypeKind.ZodMap
        }, processCreateParams(params2)));
      };
      var ZodSet = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.set,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const def2 = this._def;
          if (def2.minSize !== null) {
            if (ctx.data.size < def2.minSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def2.minSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def2.minSize.message
              });
              status.dirty();
            }
          }
          if (def2.maxSize !== null) {
            if (ctx.data.size > def2.maxSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def2.maxSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def2.maxSize.message
              });
              status.dirty();
            }
          }
          const valueType = this._def.valueType;
          function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
              if (element.status === "aborted")
                return INVALID;
              if (element.status === "dirty")
                status.dirty();
              parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
          }
          const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
          if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
          } else {
            return finalizeSet(elements);
          }
        }
        min(minSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            minSize: { value: minSize, message: errorUtil.toString(message) }
          }));
        }
        max(maxSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            maxSize: { value: maxSize, message: errorUtil.toString(message) }
          }));
        }
        size(size, message) {
          return this.min(size, message).max(size, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodSet.create = (valueType, params2) => {
        return new ZodSet(__spreadValues({
          valueType,
          minSize: null,
          maxSize: null,
          typeName: ZodFirstPartyTypeKind.ZodSet
        }, processCreateParams(params2)));
      };
      var ZodFunction = class extends ZodType {
        constructor() {
          super(...arguments);
          this.validate = this.implement;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.function,
              received: ctx.parsedType
            });
            return INVALID;
          }
          function makeArgsIssue(args, error) {
            return makeIssue({
              data: args,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_arguments,
                argumentsError: error
              }
            });
          }
          function makeReturnsIssue(returns, error) {
            return makeIssue({
              data: returns,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_return_type,
                returnTypeError: error
              }
            });
          }
          const params2 = { errorMap: ctx.common.contextualErrorMap };
          const fn = ctx.data;
          if (this._def.returns instanceof ZodPromise) {
            return OK((...args) => __async(this, null, function* () {
              const error = new ZodError([]);
              const parsedArgs = yield this._def.args.parseAsync(args, params2).catch((e) => {
                error.addIssue(makeArgsIssue(args, e));
                throw error;
              });
              const result = yield fn(...parsedArgs);
              const parsedReturns = yield this._def.returns._def.type.parseAsync(result, params2).catch((e) => {
                error.addIssue(makeReturnsIssue(result, e));
                throw error;
              });
              return parsedReturns;
            }));
          } else {
            return OK((...args) => {
              const parsedArgs = this._def.args.safeParse(args, params2);
              if (!parsedArgs.success) {
                throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
              }
              const result = fn(...parsedArgs.data);
              const parsedReturns = this._def.returns.safeParse(result, params2);
              if (!parsedReturns.success) {
                throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
              }
              return parsedReturns.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...items) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            args: ZodTuple.create(items).rest(ZodUnknown.create())
          }));
        }
        returns(returnType) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            returns: returnType
          }));
        }
        implement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        strictImplement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        static create(args, returns, params2) {
          return new ZodFunction(__spreadValues({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction
          }, processCreateParams(params2)));
        }
      };
      var ZodLazy = class extends ZodType {
        get schema() {
          return this._def.getter();
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const lazySchema = this._def.getter();
          return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
      };
      ZodLazy.create = (getter, params2) => {
        return new ZodLazy(__spreadValues({
          getter,
          typeName: ZodFirstPartyTypeKind.ZodLazy
        }, processCreateParams(params2)));
      };
      var ZodLiteral = class extends ZodType {
        _parse(input) {
          if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_literal,
              expected: this._def.value
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
        get value() {
          return this._def.value;
        }
      };
      ZodLiteral.create = (value, params2) => {
        return new ZodLiteral(__spreadValues({
          value,
          typeName: ZodFirstPartyTypeKind.ZodLiteral
        }, processCreateParams(params2)));
      };
      function createZodEnum(values, params2) {
        return new ZodEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodEnum
        }, processCreateParams(params2)));
      }
      var ZodEnum = class extends ZodType {
        _parse(input) {
          if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Values() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        extract(values) {
          return ZodEnum.create(values);
        }
        exclude(values) {
          return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
        }
      };
      ZodEnum.create = createZodEnum;
      var ZodNativeEnum = class extends ZodType {
        _parse(input) {
          const nativeEnumValues = util.getValidEnumValues(this._def.values);
          const ctx = this._getOrReturnCtx(input);
          if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      ZodNativeEnum.create = (values, params2) => {
        return new ZodNativeEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodNativeEnum
        }, processCreateParams(params2)));
      };
      var ZodPromise = class extends ZodType {
        unwrap() {
          return this._def.type;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.promise,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
          return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
              path: ctx.path,
              errorMap: ctx.common.contextualErrorMap
            });
          }));
        }
      };
      ZodPromise.create = (schema2, params2) => {
        return new ZodPromise(__spreadValues({
          type: schema2,
          typeName: ZodFirstPartyTypeKind.ZodPromise
        }, processCreateParams(params2)));
      };
      var ZodEffects = class extends ZodType {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const effect = this._def.effect || null;
          if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
              return Promise.resolve(processed).then((processed2) => {
                return this._def.schema._parseAsync({
                  data: processed2,
                  path: ctx.path,
                  parent: ctx
                });
              });
            } else {
              return this._def.schema._parseSync({
                data: processed,
                path: ctx.path,
                parent: ctx
              });
            }
          }
          const checkCtx = {
            addIssue: (arg) => {
              addIssueToContext(ctx, arg);
              if (arg.fatal) {
                status.abort();
              } else {
                status.dirty();
              }
            },
            get path() {
              return ctx.path;
            }
          };
          checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
          if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
              const result = effect.refinement(acc, checkCtx);
              if (ctx.common.async) {
                return Promise.resolve(result);
              }
              if (result instanceof Promise) {
                throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
              }
              return acc;
            };
            if (ctx.common.async === false) {
              const inner = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              executeRefinement(inner.value);
              return { status: status.value, value: inner.value };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                if (inner.status === "aborted")
                  return INVALID;
                if (inner.status === "dirty")
                  status.dirty();
                return executeRefinement(inner.value).then(() => {
                  return { status: status.value, value: inner.value };
                });
              });
            }
          }
          if (effect.type === "transform") {
            if (ctx.common.async === false) {
              const base3 = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (!isValid(base3))
                return base3;
              const result = effect.transform(base3.value, checkCtx);
              if (result instanceof Promise) {
                throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
              }
              return { status: status.value, value: result };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
                if (!isValid(base3))
                  return base3;
                return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
              });
            }
          }
          util.assertNever(effect);
        }
      };
      ZodEffects.create = (schema2, effect, params2) => {
        return new ZodEffects(__spreadValues({
          schema: schema2,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect
        }, processCreateParams(params2)));
      };
      ZodEffects.createWithPreprocess = (preprocess, schema2, params2) => {
        return new ZodEffects(__spreadValues({
          schema: schema2,
          effect: { type: "preprocess", transform: preprocess },
          typeName: ZodFirstPartyTypeKind.ZodEffects
        }, processCreateParams(params2)));
      };
      var ZodOptional = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.undefined) {
            return OK(void 0);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodOptional.create = (type, params2) => {
        return new ZodOptional(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodOptional
        }, processCreateParams(params2)));
      };
      var ZodNullable = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.null) {
            return OK(null);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodNullable.create = (type, params2) => {
        return new ZodNullable(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodNullable
        }, processCreateParams(params2)));
      };
      var ZodDefault = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          let data = ctx.data;
          if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
          }
          return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      ZodDefault.create = (type, params2) => {
        return new ZodDefault(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodDefault,
          defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default
        }, processCreateParams(params2)));
      };
      var ZodCatch = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const newCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            })
          });
          const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: __spreadValues({}, newCtx)
          });
          if (isAsync(result)) {
            return result.then((result2) => {
              return {
                status: "valid",
                value: result2.status === "valid" ? result2.value : this._def.catchValue({
                  get error() {
                    return new ZodError(newCtx.common.issues);
                  },
                  input: newCtx.data
                })
              };
            });
          } else {
            return {
              status: "valid",
              value: result.status === "valid" ? result.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          }
        }
        removeCatch() {
          return this._def.innerType;
        }
      };
      ZodCatch.create = (type, params2) => {
        return new ZodCatch(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodCatch,
          catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch
        }, processCreateParams(params2)));
      };
      var ZodNaN = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.nan,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
      };
      ZodNaN.create = (params2) => {
        return new ZodNaN(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNaN
        }, processCreateParams(params2)));
      };
      var BRAND = Symbol("zod_brand");
      var ZodBranded = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const data = ctx.data;
          return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        unwrap() {
          return this._def.type;
        }
      };
      var ZodPipeline = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.common.async) {
            const handleAsync = () => __async(this, null, function* () {
              const inResult = yield this._def.in._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inResult.status === "aborted")
                return INVALID;
              if (inResult.status === "dirty") {
                status.dirty();
                return DIRTY(inResult.value);
              } else {
                return this._def.out._parseAsync({
                  data: inResult.value,
                  path: ctx.path,
                  parent: ctx
                });
              }
            });
            return handleAsync();
          } else {
            const inResult = this._def.in._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return {
                status: "dirty",
                value: inResult.value
              };
            } else {
              return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }
        }
        static create(a, b) {
          return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
          });
        }
      };
      var custom = (check, params2 = {}, fatal) => {
        if (check)
          return ZodAny.create().superRefine((data, ctx) => {
            var _a2, _b;
            if (!check(data)) {
              const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
              const _fatal = (_b = (_a2 = p.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
              const p2 = typeof p === "string" ? { message: p } : p;
              ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal: _fatal }));
            }
          });
        return ZodAny.create();
      };
      var late = {
        object: ZodObject.lazycreate
      };
      var ZodFirstPartyTypeKind;
      (function(ZodFirstPartyTypeKind2) {
        ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
      var instanceOfType = (cls, params2 = {
        message: `Input not instance of ${cls.name}`
      }) => custom((data) => data instanceof cls, params2);
      var stringType = ZodString.create;
      var numberType = ZodNumber.create;
      var nanType = ZodNaN.create;
      var bigIntType = ZodBigInt.create;
      var booleanType = ZodBoolean.create;
      var dateType = ZodDate.create;
      var symbolType = ZodSymbol.create;
      var undefinedType = ZodUndefined.create;
      var nullType = ZodNull.create;
      var anyType = ZodAny.create;
      var unknownType = ZodUnknown.create;
      var neverType = ZodNever.create;
      var voidType = ZodVoid.create;
      var arrayType = ZodArray.create;
      var objectType = ZodObject.create;
      var strictObjectType = ZodObject.strictCreate;
      var unionType = ZodUnion.create;
      var discriminatedUnionType = ZodDiscriminatedUnion.create;
      var intersectionType = ZodIntersection.create;
      var tupleType = ZodTuple.create;
      var recordType = ZodRecord.create;
      var mapType = ZodMap.create;
      var setType = ZodSet.create;
      var functionType = ZodFunction.create;
      var lazyType = ZodLazy.create;
      var literalType = ZodLiteral.create;
      var enumType = ZodEnum.create;
      var nativeEnumType = ZodNativeEnum.create;
      var promiseType = ZodPromise.create;
      var effectsType = ZodEffects.create;
      var optionalType = ZodOptional.create;
      var nullableType = ZodNullable.create;
      var preprocessType = ZodEffects.createWithPreprocess;
      var pipelineType = ZodPipeline.create;
      var ostring = () => stringType().optional();
      var onumber = () => numberType().optional();
      var oboolean = () => booleanType().optional();
      var coerce2 = {
        string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
          coerce: true
        })),
        bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true }))
      };
      var NEVER2 = INVALID;
      var z = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        defaultErrorMap: errorMap,
        setErrorMap,
        getErrorMap,
        makeIssue,
        EMPTY_PATH,
        addIssueToContext,
        ParseStatus,
        INVALID,
        DIRTY,
        OK,
        isAborted,
        isDirty,
        isValid,
        isAsync,
        get util() {
          return util;
        },
        get objectUtil() {
          return objectUtil;
        },
        ZodParsedType,
        getParsedType,
        ZodType,
        ZodString,
        ZodNumber,
        ZodBigInt,
        ZodBoolean,
        ZodDate,
        ZodSymbol,
        ZodUndefined,
        ZodNull,
        ZodAny,
        ZodUnknown,
        ZodNever,
        ZodVoid,
        ZodArray,
        ZodObject,
        ZodUnion,
        ZodDiscriminatedUnion,
        ZodIntersection,
        ZodTuple,
        ZodRecord,
        ZodMap,
        ZodSet,
        ZodFunction,
        ZodLazy,
        ZodLiteral,
        ZodEnum,
        ZodNativeEnum,
        ZodPromise,
        ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional,
        ZodNullable,
        ZodDefault,
        ZodCatch,
        ZodNaN,
        BRAND,
        ZodBranded,
        ZodPipeline,
        custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late,
        get ZodFirstPartyTypeKind() {
          return ZodFirstPartyTypeKind;
        },
        coerce: coerce2,
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        "enum": enumType,
        "function": functionType,
        "instanceof": instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        "null": nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean,
        onumber,
        optional: optionalType,
        ostring,
        pipeline: pipelineType,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        symbol: symbolType,
        transformer: effectsType,
        tuple: tupleType,
        "undefined": undefinedType,
        union: unionType,
        unknown: unknownType,
        "void": voidType,
        NEVER: NEVER2,
        ZodIssueCode,
        quotelessJson,
        ZodError
      });
      var check_exports = {};
      __export(check_exports, {
        assure: () => assure,
        is: () => is2,
        isObject: () => isObject
      });
      var is2 = (obj, def2) => {
        return def2.safeParse(obj).success;
      };
      var assure = (def2, obj) => {
        return def2.parse(obj);
      };
      var isObject = (obj) => {
        return typeof obj === "object" && obj !== null;
      };
      var encode_12 = encode5;
      var MSB2 = 128;
      var REST2 = 127;
      var MSBALL2 = ~REST2;
      var INT2 = Math.pow(2, 31);
      function encode5(num, out, offset) {
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT2) {
          out[offset++] = num & 255 | MSB2;
          num /= 128;
        }
        while (num & MSBALL2) {
          out[offset++] = num & 255 | MSB2;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode5.bytes = offset - oldOffset + 1;
        return out;
      }
      var decode8 = read3;
      var MSB$12 = 128;
      var REST$12 = 127;
      function read3(buf2, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
        do {
          if (counter >= l) {
            read3.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf2[counter++];
          res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB$12);
        read3.bytes = counter - offset;
        return res;
      }
      var N12 = Math.pow(2, 7);
      var N22 = Math.pow(2, 14);
      var N32 = Math.pow(2, 21);
      var N42 = Math.pow(2, 28);
      var N52 = Math.pow(2, 35);
      var N62 = Math.pow(2, 42);
      var N72 = Math.pow(2, 49);
      var N82 = Math.pow(2, 56);
      var N92 = Math.pow(2, 63);
      var length2 = function(value) {
        return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
      };
      var varint3 = {
        encode: encode_12,
        decode: decode8,
        encodingLength: length2
      };
      var _brrp_varint2 = varint3;
      var varint_default2 = _brrp_varint2;
      var decode22 = (data, offset = 0) => {
        const code2 = varint_default2.decode(data, offset);
        return [
          code2,
          varint_default2.decode.bytes
        ];
      };
      var encodeTo2 = (int, target2, offset = 0) => {
        varint_default2.encode(int, target2, offset);
        return target2;
      };
      var encodingLength2 = (int) => {
        return varint_default2.encodingLength(int);
      };
      var empty2 = new Uint8Array(0);
      var equals3 = (aa, bb) => {
        if (aa === bb)
          return true;
        if (aa.byteLength !== bb.byteLength) {
          return false;
        }
        for (let ii = 0; ii < aa.byteLength; ii++) {
          if (aa[ii] !== bb[ii]) {
            return false;
          }
        }
        return true;
      };
      var coerce22 = (o) => {
        if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
          return o;
        if (o instanceof ArrayBuffer)
          return new Uint8Array(o);
        if (ArrayBuffer.isView(o)) {
          return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
        }
        throw new Error("Unknown type, must be binary type");
      };
      var fromString2 = (str) => new TextEncoder().encode(str);
      var toString2 = (b) => new TextDecoder().decode(b);
      var create2 = (code2, digest2) => {
        const size = digest2.byteLength;
        const sizeOffset = encodingLength2(code2);
        const digestOffset = sizeOffset + encodingLength2(size);
        const bytes2 = new Uint8Array(digestOffset + size);
        encodeTo2(code2, bytes2, 0);
        encodeTo2(size, bytes2, sizeOffset);
        bytes2.set(digest2, digestOffset);
        return new Digest2(code2, size, digest2, bytes2);
      };
      var decode32 = (multihash) => {
        const bytes2 = coerce22(multihash);
        const [code2, sizeOffset] = decode22(bytes2);
        const [size, digestOffset] = decode22(bytes2.subarray(sizeOffset));
        const digest2 = bytes2.subarray(sizeOffset + digestOffset);
        if (digest2.byteLength !== size) {
          throw new Error("Incorrect length");
        }
        return new Digest2(code2, size, digest2, bytes2);
      };
      var equals22 = (a, b) => {
        if (a === b) {
          return true;
        } else {
          return a.code === b.code && a.size === b.size && equals3(a.bytes, b.bytes);
        }
      };
      var Digest2 = class {
        constructor(code2, size, digest2, bytes2) {
          this.code = code2;
          this.size = size;
          this.digest = digest2;
          this.bytes = bytes2;
        }
      };
      var base58_exports = {};
      __export(base58_exports, {
        base58btc: () => base58btc2,
        base58flickr: () => base58flickr2
      });
      function base2(ALPHABET, name2) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode52(source) {
          if (source instanceof Uint8Array)
            ;
          else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length22 = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length22) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length22 = i2;
            pbegin++;
          }
          var it2 = size - length22;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          var psz = 0;
          if (source[psz] === " ") {
            return;
          }
          var zeroes = 0;
          var length22 = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length22) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length22 = i2;
            psz++;
          }
          if (source[psz] === " ") {
            return;
          }
          var it4 = size - length22;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = new Uint8Array(zeroes + (size - it4));
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode62(string3) {
          var buffer2 = decodeUnsafe(string3);
          if (buffer2) {
            return buffer2;
          }
          throw new Error(`Non-${name2} character`);
        }
        return {
          encode: encode52,
          decodeUnsafe,
          decode: decode62
        };
      }
      var src3 = base2;
      var _brrp__multiformats_scope_baseX2 = src3;
      var base_x_default2 = _brrp__multiformats_scope_baseX2;
      var Encoder3 = class {
        constructor(name2, prefix, baseEncode) {
          this.name = name2;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes2) {
          if (bytes2 instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes2)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      var Decoder3 = class {
        constructor(name2, prefix, baseDecode) {
          this.name = name2;
          this.prefix = prefix;
          if (prefix.codePointAt(0) === void 0) {
            throw new Error("Invalid prefix character");
          }
          this.prefixCodePoint = prefix.codePointAt(0);
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder22) {
          return or2(this, decoder22);
        }
      };
      var ComposedDecoder2 = class {
        constructor(decoders) {
          this.decoders = decoders;
        }
        or(decoder22) {
          return or2(this, decoder22);
        }
        decode(input) {
          const prefix = input[0];
          const decoder22 = this.decoders[prefix];
          if (decoder22) {
            return decoder22.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      var or2 = (left, right) => new ComposedDecoder2(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
      var Codec2 = class {
        constructor(name2, prefix, baseEncode, baseDecode) {
          this.name = name2;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder3(name2, prefix, baseEncode);
          this.decoder = new Decoder3(name2, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
      var from2 = ({ name: name2, prefix, encode: encode52, decode: decode62 }) => new Codec2(name2, prefix, encode52, decode62);
      var baseX2 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
        const { encode: encode52, decode: decode62 } = base_x_default2(alphabet2, name2);
        return from2({
          prefix,
          name: name2,
          encode: encode52,
          decode: (text) => coerce22(decode62(text))
        });
      };
      var decode42 = (string3, alphabet2, bitsPerChar, name2) => {
        const codes = {};
        for (let i = 0; i < alphabet2.length; ++i) {
          codes[alphabet2[i]] = i;
        }
        let end = string3.length;
        while (string3[end - 1] === "=") {
          --end;
        }
        const out = new Uint8Array(end * bitsPerChar / 8 | 0);
        let bits = 0;
        let buffer2 = 0;
        let written = 0;
        for (let i = 0; i < end; ++i) {
          const value = codes[string3[i]];
          if (value === void 0) {
            throw new SyntaxError(`Non-${name2} character`);
          }
          buffer2 = buffer2 << bitsPerChar | value;
          bits += bitsPerChar;
          if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer2 >> bits;
          }
        }
        if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
          throw new SyntaxError("Unexpected end of data");
        }
        return out;
      };
      var encode22 = (data, alphabet2, bitsPerChar) => {
        const pad = alphabet2[alphabet2.length - 1] === "=";
        const mask = (1 << bitsPerChar) - 1;
        let out = "";
        let bits = 0;
        let buffer2 = 0;
        for (let i = 0; i < data.length; ++i) {
          buffer2 = buffer2 << 8 | data[i];
          bits += 8;
          while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet2[mask & buffer2 >> bits];
          }
        }
        if (bits) {
          out += alphabet2[mask & buffer2 << bitsPerChar - bits];
        }
        if (pad) {
          while (out.length * bitsPerChar & 7) {
            out += "=";
          }
        }
        return out;
      };
      var rfc46482 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
        return from2({
          prefix,
          name: name2,
          encode(input) {
            return encode22(input, alphabet2, bitsPerChar);
          },
          decode(input) {
            return decode42(input, alphabet2, bitsPerChar, name2);
          }
        });
      };
      var base58btc2 = baseX2({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      var base58flickr2 = baseX2({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
      var base32_exports = {};
      __export(base32_exports, {
        base32: () => base322,
        base32hex: () => base32hex2,
        base32hexpad: () => base32hexpad2,
        base32hexpadupper: () => base32hexpadupper2,
        base32hexupper: () => base32hexupper2,
        base32pad: () => base32pad2,
        base32padupper: () => base32padupper2,
        base32upper: () => base32upper2,
        base32z: () => base32z2
      });
      var base322 = rfc46482({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      });
      var base32upper2 = rfc46482({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      });
      var base32pad2 = rfc46482({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      });
      var base32padupper2 = rfc46482({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      });
      var base32hex2 = rfc46482({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      });
      var base32hexupper2 = rfc46482({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      });
      var base32hexpad2 = rfc46482({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      });
      var base32hexpadupper2 = rfc46482({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      });
      var base32z2 = rfc46482({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
      var CID2 = class {
        constructor(version2, code2, multihash, bytes2) {
          this.code = code2;
          this.version = version2;
          this.multihash = multihash;
          this.bytes = bytes2;
          this.byteOffset = bytes2.byteOffset;
          this.byteLength = bytes2.byteLength;
          this.asCID = this;
          this._baseCache = /* @__PURE__ */ new Map();
          Object.defineProperties(this, {
            byteOffset: hidden,
            byteLength: hidden,
            code: readonly,
            version: readonly,
            multihash: readonly,
            bytes: readonly,
            _baseCache: hidden,
            asCID: hidden
          });
        }
        toV0() {
          switch (this.version) {
            case 0: {
              return this;
            }
            default: {
              const { code: code2, multihash } = this;
              if (code2 !== DAG_PB_CODE2) {
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              }
              if (multihash.code !== SHA_256_CODE2) {
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              }
              return CID2.createV0(multihash);
            }
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              const { code: code2, digest: digest2 } = this.multihash;
              const multihash = create2(code2, digest2);
              return CID2.createV1(this.code, multihash);
            }
            case 1: {
              return this;
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
          }
        }
        equals(other) {
          return other && this.code === other.code && this.version === other.version && equals22(this.multihash, other.multihash);
        }
        toString(base3) {
          const { bytes: bytes2, version: version2, _baseCache } = this;
          switch (version2) {
            case 0:
              return toStringV02(bytes2, _baseCache, base3 || base58btc2.encoder);
            default:
              return toStringV12(bytes2, _baseCache, base3 || base322.encoder);
          }
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(value) {
          deprecate(/^0\.0/, IS_CID_DEPRECATION);
          return !!(value && (value[cidSymbol2] || value.asCID === value));
        }
        get toBaseEncodedString() {
          throw new Error("Deprecated, use .toString()");
        }
        get codec() {
          throw new Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
        }
        get multibaseName() {
          throw new Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw new Error('"prefix" property is deprecated');
        }
        static asCID(value) {
          if (value instanceof CID2) {
            return value;
          } else if (value != null && value.asCID === value) {
            const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
            return new CID2(version2, code2, multihash, bytes2 || encodeCID2(version2, code2, multihash.bytes));
          } else if (value != null && value[cidSymbol2] === true) {
            const { version: version2, multihash, code: code2 } = value;
            const digest2 = decode32(multihash);
            return CID2.create(version2, code2, digest2);
          } else {
            return null;
          }
        }
        static create(version2, code2, digest2) {
          if (typeof code2 !== "number") {
            throw new Error("String codecs are no longer supported");
          }
          switch (version2) {
            case 0: {
              if (code2 !== DAG_PB_CODE2) {
                throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
              } else {
                return new CID2(version2, code2, digest2, digest2.bytes);
              }
            }
            case 1: {
              const bytes2 = encodeCID2(version2, code2, digest2.bytes);
              return new CID2(version2, code2, digest2, bytes2);
            }
            default: {
              throw new Error("Invalid version");
            }
          }
        }
        static createV0(digest2) {
          return CID2.create(0, DAG_PB_CODE2, digest2);
        }
        static createV1(code2, digest2) {
          return CID2.create(1, code2, digest2);
        }
        static decode(bytes2) {
          const [cid2, remainder] = CID2.decodeFirst(bytes2);
          if (remainder.length) {
            throw new Error("Incorrect length");
          }
          return cid2;
        }
        static decodeFirst(bytes2) {
          const specs = CID2.inspectBytes(bytes2);
          const prefixSize = specs.size - specs.multihashSize;
          const multihashBytes = coerce22(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
          if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
          }
          const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
          const digest2 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
          const cid2 = specs.version === 0 ? CID2.createV0(digest2) : CID2.createV1(specs.codec, digest2);
          return [
            cid2,
            bytes2.subarray(specs.size)
          ];
        }
        static inspectBytes(initialBytes) {
          let offset = 0;
          const next = () => {
            const [i, length22] = decode22(initialBytes.subarray(offset));
            offset += length22;
            return i;
          };
          let version2 = next();
          let codec = DAG_PB_CODE2;
          if (version2 === 18) {
            version2 = 0;
            offset = 0;
          } else if (version2 === 1) {
            codec = next();
          }
          if (version2 !== 0 && version2 !== 1) {
            throw new RangeError(`Invalid CID version ${version2}`);
          }
          const prefixSize = offset;
          const multihashCode = next();
          const digestSize = next();
          const size = offset + digestSize;
          const multihashSize = size - prefixSize;
          return {
            version: version2,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
          };
        }
        static parse(source, base3) {
          const [prefix, bytes2] = parseCIDtoBytes2(source, base3);
          const cid2 = CID2.decode(bytes2);
          cid2._baseCache.set(prefix, source);
          return cid2;
        }
      };
      var parseCIDtoBytes2 = (source, base3) => {
        switch (source[0]) {
          case "Q": {
            const decoder22 = base3 || base58btc2;
            return [
              base58btc2.prefix,
              decoder22.decode(`${base58btc2.prefix}${source}`)
            ];
          }
          case base58btc2.prefix: {
            const decoder22 = base3 || base58btc2;
            return [
              base58btc2.prefix,
              decoder22.decode(source)
            ];
          }
          case base322.prefix: {
            const decoder22 = base3 || base322;
            return [
              base322.prefix,
              decoder22.decode(source)
            ];
          }
          default: {
            if (base3 == null) {
              throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            }
            return [
              source[0],
              base3.decode(source)
            ];
          }
        }
      };
      var toStringV02 = (bytes2, cache2, base3) => {
        const { prefix } = base3;
        if (prefix !== base58btc2.prefix) {
          throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
        }
        const cid2 = cache2.get(prefix);
        if (cid2 == null) {
          const cid3 = base3.encode(bytes2).slice(1);
          cache2.set(prefix, cid3);
          return cid3;
        } else {
          return cid2;
        }
      };
      var toStringV12 = (bytes2, cache2, base3) => {
        const { prefix } = base3;
        const cid2 = cache2.get(prefix);
        if (cid2 == null) {
          const cid3 = base3.encode(bytes2);
          cache2.set(prefix, cid3);
          return cid3;
        } else {
          return cid2;
        }
      };
      var DAG_PB_CODE2 = 112;
      var SHA_256_CODE2 = 18;
      var encodeCID2 = (version2, code2, multihash) => {
        const codeOffset = encodingLength2(version2);
        const hashOffset = codeOffset + encodingLength2(code2);
        const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
        encodeTo2(version2, bytes2, 0);
        encodeTo2(code2, bytes2, codeOffset);
        bytes2.set(multihash, hashOffset);
        return bytes2;
      };
      var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
      var readonly = {
        writable: false,
        configurable: false,
        enumerable: true
      };
      var hidden = {
        writable: false,
        enumerable: false,
        configurable: false
      };
      var version = "0.0.0-dev";
      var deprecate = (range, message) => {
        if (range.test(version)) {
          console.warn(message);
        } else {
          throw new Error(message);
        }
      };
      var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
      var identity_exports = {};
      __export(identity_exports, {
        identity: () => identity
      });
      var identity = from2({
        prefix: "\0",
        name: "identity",
        encode: (buf2) => toString2(buf2),
        decode: (str) => fromString2(str)
      });
      var base2_exports = {};
      __export(base2_exports, {
        base2: () => base22
      });
      var base22 = rfc46482({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
      });
      var base8_exports = {};
      __export(base8_exports, {
        base8: () => base8
      });
      var base8 = rfc46482({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
      });
      var base10_exports = {};
      __export(base10_exports, {
        base10: () => base10
      });
      var base10 = baseX2({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
      });
      var base16_exports = {};
      __export(base16_exports, {
        base16: () => base16,
        base16upper: () => base16upper
      });
      var base16 = rfc46482({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
      });
      var base16upper = rfc46482({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      });
      var base36_exports = {};
      __export(base36_exports, {
        base36: () => base36,
        base36upper: () => base36upper
      });
      var base36 = baseX2({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
      });
      var base36upper = baseX2({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      });
      var base64_exports = {};
      __export(base64_exports, {
        base64: () => base64,
        base64pad: () => base64pad,
        base64url: () => base64url,
        base64urlpad: () => base64urlpad
      });
      var base64 = rfc46482({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
      });
      var base64pad = rfc46482({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      });
      var base64url = rfc46482({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      });
      var base64urlpad = rfc46482({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      });
      var base256emoji_exports = {};
      __export(base256emoji_exports, {
        base256emoji: () => base256emoji
      });
      var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
      var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
        p[i] = c;
        return p;
      }, []);
      var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
        p[c.codePointAt(0)] = i;
        return p;
      }, []);
      function encode32(data) {
        return data.reduce((p, c) => {
          p += alphabetBytesToChars[c];
          return p;
        }, "");
      }
      function decode52(str) {
        const byts = [];
        for (const char of str) {
          const byt = alphabetCharsToBytes[char.codePointAt(0)];
          if (byt === void 0) {
            throw new Error(`Non-base256emoji character: ${char}`);
          }
          byts.push(byt);
        }
        return new Uint8Array(byts);
      }
      var base256emoji = from2({
        prefix: "\u{1F680}",
        name: "base256emoji",
        encode: encode32,
        decode: decode52
      });
      var sha2_browser_exports = {};
      __export(sha2_browser_exports, {
        sha256: () => sha256,
        sha512: () => sha512
      });
      var from22 = ({ name: name2, code: code2, encode: encode52 }) => new Hasher(name2, code2, encode52);
      var Hasher = class {
        constructor(name2, code2, encode52) {
          this.name = name2;
          this.code = code2;
          this.encode = encode52;
        }
        digest(input) {
          if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest2) => create2(this.code, digest2));
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      var sha = (name2) => (data) => __async(exports, null, function* () {
        return new Uint8Array(yield crypto.subtle.digest(name2, data));
      });
      var sha256 = from22({
        name: "sha2-256",
        code: 18,
        encode: sha("SHA-256")
      });
      var sha512 = from22({
        name: "sha2-512",
        code: 19,
        encode: sha("SHA-512")
      });
      var identity_exports2 = {};
      __export(identity_exports2, {
        identity: () => identity2
      });
      var code = 0;
      var name = "identity";
      var encode42 = coerce22;
      var digest = (input) => create2(code, encode42(input));
      var identity2 = {
        code,
        name,
        encode: encode42,
        digest
      };
      var textEncoder3 = new TextEncoder();
      var textDecoder2 = new TextDecoder();
      var bases = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity_exports), base2_exports), base8_exports), base10_exports), base16_exports), base32_exports), base36_exports), base58_exports), base64_exports), base256emoji_exports);
      var hashes = __spreadValues(__spreadValues({}, sha2_browser_exports), identity_exports2);
      function createCodec(name2, prefix, encode52, decode62) {
        return {
          name: name2,
          prefix,
          encoder: {
            name: name2,
            prefix,
            encode: encode52
          },
          decoder: { decode: decode62 }
        };
      }
      var string = createCodec("utf8", "u", (buf2) => {
        const decoder22 = new TextDecoder("utf8");
        return "u" + decoder22.decode(buf2);
      }, (str) => {
        const encoder2 = new TextEncoder();
        return encoder2.encode(str.substring(1));
      });
      var ascii = createCodec("ascii", "a", (buf2) => {
        let string3 = "a";
        for (let i = 0; i < buf2.length; i++) {
          string3 += String.fromCharCode(buf2[i]);
        }
        return string3;
      }, (str) => {
        str = str.substring(1);
        const buf2 = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          buf2[i] = str.charCodeAt(i);
        }
        return buf2;
      });
      var BASES = __spreadValues({
        utf8: string,
        "utf-8": string,
        hex: bases.base16,
        latin1: ascii,
        ascii,
        binary: ascii
      }, bases);
      var bases_default = BASES;
      function fromString22(string3, encoding = "utf8") {
        const base3 = bases_default[encoding];
        if (!base3) {
          throw new Error(`Unsupported encoding "${encoding}"`);
        }
        return base3.decoder.decode(`${base3.prefix}${string3}`);
      }
      function toString22(array2, encoding = "utf8") {
        const base3 = bases_default[encoding];
        if (!base3) {
          throw new Error(`Unsupported encoding "${encoding}"`);
        }
        return base3.encoder.encode(array2).substring(1);
      }
      var jsonToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => jsonToIpld(item));
        }
        if (val && typeof val === "object") {
          if (typeof val["$link"] === "string" && Object.keys(val).length === 1) {
            return CID2.parse(val["$link"]);
          }
          if (typeof val["$bytes"] === "string" && Object.keys(val).length === 1) {
            return fromString22(val["$bytes"], "base64");
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = jsonToIpld(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var ipldToJson = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => ipldToJson(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof Uint8Array) {
            return {
              $bytes: toString22(val, "base64")
            };
          }
          if (CID2.asCID(val)) {
            return {
              $link: val.toString()
            };
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = ipldToJson(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var cidSchema = z.any().refine((obj) => CID2.asCID(obj) !== null, {
        message: "Not a CID"
      }).transform((obj) => CID2.asCID(obj));
      var schema = {
        cid: cidSchema,
        bytes: z.instanceof(Uint8Array),
        string: z.string(),
        array: z.array(z.unknown()),
        map: z.record(z.string(), z.unknown()),
        unknown: z.unknown()
      };
      var def = {
        cid: {
          name: "cid",
          schema: schema.cid
        },
        bytes: {
          name: "bytes",
          schema: schema.bytes
        },
        string: {
          name: "string",
          schema: schema.string
        },
        map: {
          name: "map",
          schema: schema.map
        },
        unknown: {
          name: "unknown",
          schema: schema.unknown
        }
      };
      var SECOND = 1e3;
      var MINUTE = SECOND * 60;
      var HOUR = MINUTE * 60;
      var DAY = HOUR * 24;
      var import_graphemer = __toESM2(require_lib2());
      var utf8Len = (str) => {
        return new TextEncoder().encode(str).byteLength;
      };
      var graphemeLen = (str) => {
        const splitter = new import_graphemer.default();
        return splitter.countGraphemes(str);
      };
      var parseLanguage = (langTag) => {
        const parsed = langTag.match(bcp47Regexp);
        if (!(parsed == null ? void 0 : parsed.groups))
          return null;
        const parts = parsed.groups;
        return {
          grandfathered: parts.grandfathered,
          language: parts.language,
          extlang: parts.extlang,
          script: parts.script,
          region: parts.region,
          variant: parts.variant,
          extension: parts.extension,
          privateUse: parts.privateUseA || parts.privateUseB
        };
      };
      var validateLanguage = (langTag) => {
        return bcp47Regexp.test(langTag);
      };
      var bcp47Regexp = new RegExp("^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$");
      var isValidDidDoc = (doc) => {
        return didDocument.safeParse(doc).success;
      };
      var getDid = (doc) => {
        const id = doc.id;
        if (typeof id !== "string") {
          throw new Error("No `id` on document");
        }
        return id;
      };
      var getPdsEndpoint = (doc) => {
        return getServiceEndpoint(doc, {
          id: "#atproto_pds",
          type: "AtprotoPersonalDataServer"
        });
      };
      var getServiceEndpoint = (doc, opts) => {
        const did2 = getDid(doc);
        let services = doc.service;
        if (!services)
          return void 0;
        if (typeof services !== "object")
          return void 0;
        if (!Array.isArray(services)) {
          services = [services];
        }
        const found = services.find((service2) => service2.id === opts.id || service2.id === `${did2}${opts.id}`);
        if (!found)
          return void 0;
        if (found.type !== opts.type) {
          return void 0;
        }
        if (typeof found.serviceEndpoint !== "string") {
          return void 0;
        }
        return validateUrl(found.serviceEndpoint);
      };
      var validateUrl = (urlStr) => {
        let url;
        try {
          url = new URL(urlStr);
        } catch (e) {
          return void 0;
        }
        if (!["http:", "https:"].includes(url.protocol)) {
          return void 0;
        } else if (!url.hostname) {
          return void 0;
        } else {
          return urlStr;
        }
      };
      var verificationMethod = z.object({
        id: z.string(),
        type: z.string(),
        controller: z.string(),
        publicKeyMultibase: z.string().optional()
      });
      var service = z.object({
        id: z.string(),
        type: z.string(),
        serviceEndpoint: z.union([z.string(), z.record(z.unknown())])
      });
      var didDocument = z.object({
        id: z.string(),
        alsoKnownAs: z.array(z.string()).optional(),
        verificationMethod: z.array(verificationMethod).optional(),
        service: z.array(service).optional()
      });
      var import_iso_datestring_validator = __toESM2(require_dist2());
      function datetime(path, value) {
        try {
          if (!(0, import_iso_datestring_validator.isValidISODateString)(value)) {
            throw new Error();
          }
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
          };
        }
        return { success: true, value };
      }
      function uri(path, value) {
        const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
        if (!isUri) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a uri`)
          };
        }
        return { success: true, value };
      }
      function atUri(path, value) {
        try {
          ensureValidAtUri(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid at-uri`)
          };
        }
        return { success: true, value };
      }
      function did(path, value) {
        try {
          ensureValidDid(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid did`)
          };
        }
        return { success: true, value };
      }
      function handle(path, value) {
        try {
          ensureValidHandle(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid handle`)
          };
        }
        return { success: true, value };
      }
      function atIdentifier(path, value) {
        const isDid = did(path, value);
        if (!isDid.success) {
          const isHandle2 = handle(path, value);
          if (!isHandle2.success) {
            return {
              success: false,
              error: new ValidationError(`${path} must be a valid did or a handle`)
            };
          }
        }
        return { success: true, value };
      }
      function nsid(path, value) {
        try {
          ensureValidNsid(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid nsid`)
          };
        }
        return { success: true, value };
      }
      function cid(path, value) {
        try {
          CID2.parse(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a cid string`)
          };
        }
        return { success: true, value };
      }
      function language(path, value) {
        if (validateLanguage(value)) {
          return { success: true, value };
        }
        return {
          success: false,
          error: new ValidationError(`${path} must be a well-formed BCP 47 language tag`)
        };
      }
      function validate(lexicons2, path, def2, value) {
        switch (def2.type) {
          case "boolean":
            return boolean(lexicons2, path, def2, value);
          case "integer":
            return integer(lexicons2, path, def2, value);
          case "string":
            return string2(lexicons2, path, def2, value);
          case "bytes":
            return bytes(lexicons2, path, def2, value);
          case "cid-link":
            return cidLink(lexicons2, path, def2, value);
          case "unknown":
            return unknown(lexicons2, path, def2, value);
          default:
            return {
              success: false,
              error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)
            };
        }
      }
      function boolean(lexicons2, path, def2, value) {
        def2 = def2;
        const type = typeof value;
        if (type === "undefined") {
          if (typeof def2.default === "boolean") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be a boolean`)
          };
        } else if (type !== "boolean") {
          return {
            success: false,
            error: new ValidationError(`${path} must be a boolean`)
          };
        }
        if (typeof def2.const === "boolean") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        return { success: true, value };
      }
      function integer(lexicons2, path, def2, value) {
        def2 = def2;
        const type = typeof value;
        if (type === "undefined") {
          if (typeof def2.default === "number") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be an integer`)
          };
        } else if (!Number.isInteger(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an integer`)
          };
        }
        if (typeof def2.const === "number") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        if (Array.isArray(def2.enum)) {
          if (!def2.enum.includes(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be one of (${def2.enum.join("|")})`)
            };
          }
        }
        if (typeof def2.maximum === "number") {
          if (value > def2.maximum) {
            return {
              success: false,
              error: new ValidationError(`${path} can not be greater than ${def2.maximum}`)
            };
          }
        }
        if (typeof def2.minimum === "number") {
          if (value < def2.minimum) {
            return {
              success: false,
              error: new ValidationError(`${path} can not be less than ${def2.minimum}`)
            };
          }
        }
        return { success: true, value };
      }
      function string2(lexicons2, path, def2, value) {
        def2 = def2;
        if (typeof value === "undefined") {
          if (typeof def2.default === "string") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be a string`)
          };
        } else if (typeof value !== "string") {
          return {
            success: false,
            error: new ValidationError(`${path} must be a string`)
          };
        }
        if (typeof def2.const === "string") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        if (Array.isArray(def2.enum)) {
          if (!def2.enum.includes(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be one of (${def2.enum.join("|")})`)
            };
          }
        }
        if (typeof def2.maxLength === "number") {
          if (utf8Len(value) > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be longer than ${def2.maxLength} characters`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (utf8Len(value) < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be shorter than ${def2.minLength} characters`)
            };
          }
        }
        if (typeof def2.maxGraphemes === "number") {
          if (graphemeLen(value) > def2.maxGraphemes) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be longer than ${def2.maxGraphemes} graphemes`)
            };
          }
        }
        if (typeof def2.minGraphemes === "number") {
          if (graphemeLen(value) < def2.minGraphemes) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be shorter than ${def2.minGraphemes} graphemes`)
            };
          }
        }
        if (typeof def2.format === "string") {
          switch (def2.format) {
            case "datetime":
              return datetime(path, value);
            case "uri":
              return uri(path, value);
            case "at-uri":
              return atUri(path, value);
            case "did":
              return did(path, value);
            case "handle":
              return handle(path, value);
            case "at-identifier":
              return atIdentifier(path, value);
            case "nsid":
              return nsid(path, value);
            case "cid":
              return cid(path, value);
            case "language":
              return language(path, value);
          }
        }
        return { success: true, value };
      }
      function bytes(lexicons2, path, def2, value) {
        def2 = def2;
        if (!value || !(value instanceof Uint8Array)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a byte array`)
          };
        }
        if (typeof def2.maxLength === "number") {
          if (value.byteLength > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be larger than ${def2.maxLength} bytes`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (value.byteLength < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be smaller than ${def2.minLength} bytes`)
            };
          }
        }
        return { success: true, value };
      }
      function cidLink(lexicons2, path, def2, value) {
        if (CID2.asCID(value) === null) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a CID`)
          };
        }
        return { success: true, value };
      }
      function unknown(lexicons2, path, def2, value) {
        if (!value || typeof value !== "object") {
          return {
            success: false,
            error: new ValidationError(`${path} must be an object`)
          };
        }
        return { success: true, value };
      }
      var typedJsonBlobRef = z.object({
        $type: z.literal("blob"),
        ref: schema.cid,
        mimeType: z.string(),
        size: z.number()
      }).strict();
      var untypedJsonBlobRef = z.object({
        cid: z.string(),
        mimeType: z.string()
      }).strict();
      var jsonBlobRef = z.union([typedJsonBlobRef, untypedJsonBlobRef]);
      var BlobRef = class {
        constructor(ref, mimeType, size, original) {
          this.ref = ref;
          this.mimeType = mimeType;
          this.size = size;
          this.original = original != null ? original : {
            $type: "blob",
            ref,
            mimeType,
            size
          };
        }
        static asBlobRef(obj) {
          if (check_exports.is(obj, jsonBlobRef)) {
            return BlobRef.fromJsonRef(obj);
          }
          return null;
        }
        static fromJsonRef(json) {
          if (check_exports.is(json, typedJsonBlobRef)) {
            return new BlobRef(json.ref, json.mimeType, json.size);
          } else {
            return new BlobRef(CID2.parse(json.cid), json.mimeType, -1, json);
          }
        }
        ipld() {
          return {
            $type: "blob",
            ref: this.ref,
            mimeType: this.mimeType,
            size: this.size
          };
        }
        toJSON() {
          return ipldToJson(this.ipld());
        }
      };
      function blob(lexicons2, path, def2, value) {
        if (!value || !(value instanceof BlobRef)) {
          return {
            success: false,
            error: new ValidationError(`${path} should be a blob ref`)
          };
        }
        return { success: true, value };
      }
      function validate2(lexicons2, path, def2, value) {
        switch (def2.type) {
          case "boolean":
            return boolean(lexicons2, path, def2, value);
          case "integer":
            return integer(lexicons2, path, def2, value);
          case "string":
            return string2(lexicons2, path, def2, value);
          case "bytes":
            return bytes(lexicons2, path, def2, value);
          case "cid-link":
            return cidLink(lexicons2, path, def2, value);
          case "unknown":
            return unknown(lexicons2, path, def2, value);
          case "object":
            return object(lexicons2, path, def2, value);
          case "array":
            return array(lexicons2, path, def2, value);
          case "blob":
            return blob(lexicons2, path, def2, value);
          default:
            return {
              success: false,
              error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)
            };
        }
      }
      function array(lexicons2, path, def2, value) {
        if (!Array.isArray(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an array`)
          };
        }
        if (typeof def2.maxLength === "number") {
          if (value.length > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not have more than ${def2.maxLength} elements`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (value.length < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not have fewer than ${def2.minLength} elements`)
            };
          }
        }
        const itemsDef = def2.items;
        for (let i = 0; i < value.length; i++) {
          const itemValue = value[i];
          const itemPath = `${path}/${i}`;
          const res = validateOneOf(lexicons2, itemPath, itemsDef, itemValue);
          if (!res.success) {
            return res;
          }
        }
        return { success: true, value };
      }
      function object(lexicons2, path, def2, value) {
        def2 = def2;
        if (!value || typeof value !== "object") {
          return {
            success: false,
            error: new ValidationError(`${path} must be an object`)
          };
        }
        const requiredProps = new Set(def2.required);
        const nullableProps = new Set(def2.nullable);
        let resultValue = value;
        if (typeof def2.properties === "object") {
          for (const key in def2.properties) {
            if (value[key] === null && nullableProps.has(key)) {
              continue;
            }
            const propDef = def2.properties[key];
            const propPath = `${path}/${key}`;
            const validated = validateOneOf(lexicons2, propPath, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === "undefined";
            if (propIsUndefined && requiredProps.has(key)) {
              return {
                success: false,
                error: new ValidationError(`${path} must have the property "${key}"`)
              };
            } else if (!propIsUndefined && !validated.success) {
              return validated;
            }
            if (propValue !== value[key]) {
              if (resultValue === value) {
                resultValue = __spreadValues({}, value);
              }
              resultValue[key] = propValue;
            }
          }
        }
        return { success: true, value: resultValue };
      }
      function toLexUri(str, baseUri) {
        if (str.split("#").length > 2) {
          throw new Error("Uri can only have one hash segment");
        }
        if (str.startsWith("lex:")) {
          return str;
        }
        if (str.startsWith("#")) {
          if (!baseUri) {
            throw new Error(`Unable to resolve uri without anchor: ${str}`);
          }
          return `${baseUri}${str}`;
        }
        return `lex:${str}`;
      }
      function validateOneOf(lexicons2, path, def2, value, mustBeObj = false) {
        let error;
        let concreteDefs;
        if (def2.type === "union") {
          if (!isDiscriminatedObject(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be an object which includes the "$type" property`)
            };
          }
          if (!refsContainType(def2.refs, value.$type)) {
            if (def2.closed) {
              return {
                success: false,
                error: new ValidationError(`${path} $type must be one of ${def2.refs.join(", ")}`)
              };
            }
            return { success: true, value };
          } else {
            concreteDefs = toConcreteTypes(lexicons2, {
              type: "ref",
              ref: value.$type
            });
          }
        } else {
          concreteDefs = toConcreteTypes(lexicons2, def2);
        }
        for (const concreteDef of concreteDefs) {
          const result = mustBeObj ? object(lexicons2, path, concreteDef, value) : validate2(lexicons2, path, concreteDef, value);
          if (result.success) {
            return result;
          }
          error != null ? error : error = result.error;
        }
        if (concreteDefs.length > 1) {
          return {
            success: false,
            error: new ValidationError(`${path} did not match any of the expected definitions`)
          };
        }
        return { success: false, error };
      }
      function assertValidOneOf(lexicons2, path, def2, value, mustBeObj = false) {
        const res = validateOneOf(lexicons2, path, def2, value, mustBeObj);
        if (!res.success)
          throw res.error;
        return res.value;
      }
      function toConcreteTypes(lexicons2, def2) {
        if (def2.type === "ref") {
          return [lexicons2.getDefOrThrow(def2.ref)];
        } else if (def2.type === "union") {
          return def2.refs.map((ref) => lexicons2.getDefOrThrow(ref)).flat();
        } else {
          return [def2];
        }
      }
      function requiredPropertiesRefinement(object2, ctx) {
        if (object2.required === void 0) {
          return;
        }
        if (!Array.isArray(object2.required)) {
          ctx.addIssue({
            code: z.ZodIssueCode.invalid_type,
            received: typeof object2.required,
            expected: "array"
          });
          return;
        }
        if (object2.properties === void 0) {
          if (object2.required.length > 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Required fields defined but no properties defined`
            });
          }
          return;
        }
        for (const field of object2.required) {
          if (object2.properties[field] === void 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Required field "${field}" not defined`
            });
          }
        }
      }
      var refsContainType = (refs, type) => {
        const lexUri = toLexUri(type);
        if (refs.includes(lexUri)) {
          return true;
        }
        if (lexUri.endsWith("#main")) {
          return refs.includes(lexUri.replace("#main", ""));
        } else {
          return refs.includes(lexUri + "#main");
        }
      };
      var lexBoolean = z.object({
        type: z.literal("boolean"),
        description: z.string().optional(),
        default: z.boolean().optional(),
        const: z.boolean().optional()
      }).strict();
      var lexInteger = z.object({
        type: z.literal("integer"),
        description: z.string().optional(),
        default: z.number().int().optional(),
        minimum: z.number().int().optional(),
        maximum: z.number().int().optional(),
        enum: z.number().int().array().optional(),
        const: z.number().int().optional()
      }).strict();
      var lexStringFormat = z.enum([
        "datetime",
        "uri",
        "at-uri",
        "did",
        "handle",
        "at-identifier",
        "nsid",
        "cid",
        "language"
      ]);
      var lexString = z.object({
        type: z.literal("string"),
        format: lexStringFormat.optional(),
        description: z.string().optional(),
        default: z.string().optional(),
        minLength: z.number().int().optional(),
        maxLength: z.number().int().optional(),
        minGraphemes: z.number().int().optional(),
        maxGraphemes: z.number().int().optional(),
        enum: z.string().array().optional(),
        const: z.string().optional(),
        knownValues: z.string().array().optional()
      }).strict();
      var lexUnknown = z.object({
        type: z.literal("unknown"),
        description: z.string().optional()
      }).strict();
      var lexPrimitive = z.discriminatedUnion("type", [
        lexBoolean,
        lexInteger,
        lexString,
        lexUnknown
      ]);
      var lexBytes = z.object({
        type: z.literal("bytes"),
        description: z.string().optional(),
        maxLength: z.number().optional(),
        minLength: z.number().optional()
      }).strict();
      var lexCidLink = z.object({
        type: z.literal("cid-link"),
        description: z.string().optional()
      }).strict();
      var lexIpldType = z.discriminatedUnion("type", [lexBytes, lexCidLink]);
      var lexRef = z.object({
        type: z.literal("ref"),
        description: z.string().optional(),
        ref: z.string()
      }).strict();
      var lexRefUnion = z.object({
        type: z.literal("union"),
        description: z.string().optional(),
        refs: z.string().array(),
        closed: z.boolean().optional()
      }).strict();
      var lexRefVariant = z.discriminatedUnion("type", [lexRef, lexRefUnion]);
      var lexBlob = z.object({
        type: z.literal("blob"),
        description: z.string().optional(),
        accept: z.string().array().optional(),
        maxSize: z.number().optional()
      }).strict();
      var lexArray = z.object({
        type: z.literal("array"),
        description: z.string().optional(),
        items: z.union([lexPrimitive, lexIpldType, lexBlob, lexRefVariant]),
        minLength: z.number().int().optional(),
        maxLength: z.number().int().optional()
      }).strict();
      var lexPrimitiveArray = lexArray.merge(z.object({
        items: lexPrimitive
      }).strict());
      var lexToken = z.object({
        type: z.literal("token"),
        description: z.string().optional()
      }).strict();
      var lexObject = z.object({
        type: z.literal("object"),
        description: z.string().optional(),
        required: z.string().array().optional(),
        nullable: z.string().array().optional(),
        properties: z.record(z.union([lexRefVariant, lexIpldType, lexArray, lexBlob, lexPrimitive]))
      }).strict().superRefine(requiredPropertiesRefinement);
      var lexXrpcParameters = z.object({
        type: z.literal("params"),
        description: z.string().optional(),
        required: z.string().array().optional(),
        properties: z.record(z.union([lexPrimitive, lexPrimitiveArray]))
      }).strict().superRefine(requiredPropertiesRefinement);
      var lexXrpcBody = z.object({
        description: z.string().optional(),
        encoding: z.string(),
        schema: z.union([lexRefVariant, lexObject]).optional()
      }).strict();
      var lexXrpcSubscriptionMessage = z.object({
        description: z.string().optional(),
        schema: z.union([lexRefVariant, lexObject]).optional()
      }).strict();
      var lexXrpcError = z.object({
        name: z.string(),
        description: z.string().optional()
      }).strict();
      var lexXrpcQuery = z.object({
        type: z.literal("query"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        output: lexXrpcBody.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexXrpcProcedure = z.object({
        type: z.literal("procedure"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        input: lexXrpcBody.optional(),
        output: lexXrpcBody.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexXrpcSubscription = z.object({
        type: z.literal("subscription"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        message: lexXrpcSubscriptionMessage.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexRecord = z.object({
        type: z.literal("record"),
        description: z.string().optional(),
        key: z.string().optional(),
        record: lexObject
      }).strict();
      var lexUserType = z.custom((val) => {
        if (!val || typeof val !== "object") {
          return;
        }
        if (val["type"] === void 0) {
          return;
        }
        switch (val["type"]) {
          case "record":
            return lexRecord.parse(val);
          case "query":
            return lexXrpcQuery.parse(val);
          case "procedure":
            return lexXrpcProcedure.parse(val);
          case "subscription":
            return lexXrpcSubscription.parse(val);
          case "blob":
            return lexBlob.parse(val);
          case "array":
            return lexArray.parse(val);
          case "token":
            return lexToken.parse(val);
          case "object":
            return lexObject.parse(val);
          case "boolean":
            return lexBoolean.parse(val);
          case "integer":
            return lexInteger.parse(val);
          case "string":
            return lexString.parse(val);
          case "bytes":
            return lexBytes.parse(val);
          case "cid-link":
            return lexCidLink.parse(val);
          case "unknown":
            return lexUnknown.parse(val);
        }
      }, (val) => {
        if (!val || typeof val !== "object") {
          return {
            message: "Must be an object",
            fatal: true
          };
        }
        if (val["type"] === void 0) {
          return {
            message: "Must have a type",
            fatal: true
          };
        }
        return {
          message: `Invalid type: ${val["type"]} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
          fatal: true
        };
      });
      var lexiconDoc = z.object({
        lexicon: z.literal(1),
        id: z.string().refine((v) => NSID.isValid(v), {
          message: "Must be a valid NSID"
        }),
        revision: z.number().optional(),
        description: z.string().optional(),
        defs: z.record(lexUserType)
      }).strict().superRefine((doc, ctx) => {
        for (const defId in doc.defs) {
          const def2 = doc.defs[defId];
          if (defId !== "main" && (def2.type === "record" || def2.type === "procedure" || def2.type === "query" || def2.type === "subscription")) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Records, procedures, queries, and subscriptions must be the main definition.`
            });
          }
        }
      });
      function isObj(obj) {
        return obj !== null && typeof obj === "object";
      }
      function hasProp(data, prop) {
        return prop in data;
      }
      var discriminatedObject = z.object({ $type: z.string() });
      function isDiscriminatedObject(value) {
        return discriminatedObject.safeParse(value).success;
      }
      var ValidationError = class extends Error {
      };
      var InvalidLexiconError = class extends Error {
      };
      var LexiconDefNotFoundError = class extends Error {
      };
      function params(lexicons2, path, def2, val) {
        var _a2;
        const value = val && typeof val === "object" ? val : {};
        const requiredProps = new Set((_a2 = def2.required) != null ? _a2 : []);
        let resultValue = value;
        if (typeof def2.properties === "object") {
          for (const key in def2.properties) {
            const propDef = def2.properties[key];
            const validated = propDef.type === "array" ? array(lexicons2, key, propDef, value[key]) : validate(lexicons2, key, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === "undefined";
            if (propIsUndefined && requiredProps.has(key)) {
              return {
                success: false,
                error: new ValidationError(`${path} must have the property "${key}"`)
              };
            } else if (!propIsUndefined && !validated.success) {
              return validated;
            }
            if (propValue !== value[key]) {
              if (resultValue === value) {
                resultValue = __spreadValues({}, value);
              }
              resultValue[key] = propValue;
            }
          }
        }
        return { success: true, value: resultValue };
      }
      function assertValidRecord(lexicons2, def2, value) {
        const res = object(lexicons2, "Record", def2.record, value);
        if (!res.success)
          throw res.error;
        return res.value;
      }
      function assertValidXrpcParams(lexicons2, def2, value) {
        if (def2.parameters) {
          const res = params(lexicons2, "Params", def2.parameters, value);
          if (!res.success)
            throw res.error;
          return res.value;
        }
      }
      function assertValidXrpcInput(lexicons2, def2, value) {
        var _a2;
        if ((_a2 = def2.input) == null ? void 0 : _a2.schema) {
          return assertValidOneOf(lexicons2, "Input", def2.input.schema, value, true);
        }
      }
      function assertValidXrpcOutput(lexicons2, def2, value) {
        var _a2;
        if ((_a2 = def2.output) == null ? void 0 : _a2.schema) {
          return assertValidOneOf(lexicons2, "Output", def2.output.schema, value, true);
        }
      }
      function assertValidXrpcMessage(lexicons2, def2, value) {
        var _a2;
        if ((_a2 = def2.message) == null ? void 0 : _a2.schema) {
          return assertValidOneOf(lexicons2, "Message", def2.message.schema, value, true);
        }
      }
      var Lexicons = class {
        constructor(docs) {
          this.docs = /* @__PURE__ */ new Map();
          this.defs = /* @__PURE__ */ new Map();
          if (docs == null ? void 0 : docs.length) {
            for (const doc of docs) {
              this.add(doc);
            }
          }
        }
        add(doc) {
          const uri2 = toLexUri(doc.id);
          if (this.docs.has(uri2)) {
            throw new Error(`${uri2} has already been registered`);
          }
          resolveRefUris(doc, uri2);
          this.docs.set(uri2, doc);
          for (const [defUri, def2] of iterDefs(doc)) {
            this.defs.set(defUri, def2);
          }
        }
        remove(uri2) {
          uri2 = toLexUri(uri2);
          const doc = this.docs.get(uri2);
          if (!doc) {
            throw new Error(`Unable to remove "${uri2}": does not exist`);
          }
          for (const [defUri, _def] of iterDefs(doc)) {
            this.defs.delete(defUri);
          }
          this.docs.delete(uri2);
        }
        get(uri2) {
          uri2 = toLexUri(uri2);
          return this.docs.get(uri2);
        }
        getDef(uri2) {
          uri2 = toLexUri(uri2);
          return this.defs.get(uri2);
        }
        getDefOrThrow(uri2, types) {
          const def2 = this.getDef(uri2);
          if (!def2) {
            throw new LexiconDefNotFoundError(`Lexicon not found: ${uri2}`);
          }
          if (types && !types.includes(def2.type)) {
            throw new InvalidLexiconError(`Not a ${types.join(" or ")} lexicon: ${uri2}`);
          }
          return def2;
        }
        validate(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["record", "object"]);
          if (!isObj(value)) {
            throw new ValidationError(`Value must be an object`);
          }
          if (def2.type === "record") {
            return object(this, "Record", def2.record, value);
          } else if (def2.type === "object") {
            return object(this, "Object", def2, value);
          } else {
            throw new InvalidLexiconError("Definition must be a record or object");
          }
        }
        assertValidRecord(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["record"]);
          if (!isObj(value)) {
            throw new ValidationError(`Record must be an object`);
          }
          if (!hasProp(value, "$type") || typeof value.$type !== "string") {
            throw new ValidationError(`Record/$type must be a string`);
          }
          const $type = value.$type || "";
          if (toLexUri($type) !== lexUri) {
            throw new ValidationError(`Invalid $type: must be ${lexUri}, got ${$type}`);
          }
          return assertValidRecord(this, def2, value);
        }
        assertValidXrpcParams(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, [
            "query",
            "procedure",
            "subscription"
          ]);
          return assertValidXrpcParams(this, def2, value);
        }
        assertValidXrpcInput(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["procedure"]);
          return assertValidXrpcInput(this, def2, value);
        }
        assertValidXrpcOutput(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["query", "procedure"]);
          return assertValidXrpcOutput(this, def2, value);
        }
        assertValidXrpcMessage(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["subscription"]);
          return assertValidXrpcMessage(this, def2, value);
        }
        resolveLexUri(lexUri, ref) {
          lexUri = toLexUri(lexUri);
          return toLexUri(ref, lexUri);
        }
      };
      function* iterDefs(doc) {
        for (const defId in doc.defs) {
          yield [`lex:${doc.id}#${defId}`, doc.defs[defId]];
          if (defId === "main") {
            yield [`lex:${doc.id}`, doc.defs[defId]];
          }
        }
      }
      function resolveRefUris(obj, baseUri) {
        for (const k in obj) {
          if (obj.type === "ref") {
            obj.ref = toLexUri(obj.ref, baseUri);
          } else if (obj.type === "union") {
            obj.refs = obj.refs.map((ref) => toLexUri(ref, baseUri));
          } else if (Array.isArray(obj[k])) {
            obj[k] = obj[k].map((item) => {
              if (typeof item === "string") {
                return item.startsWith("#") ? toLexUri(item, baseUri) : item;
              } else if (item && typeof item === "object") {
                return resolveRefUris(item, baseUri);
              }
              return item;
            });
          } else if (obj[k] && typeof obj[k] === "object") {
            obj[k] = resolveRefUris(obj[k], baseUri);
          }
        }
        return obj;
      }
      var lexToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => lexToIpld(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof BlobRef) {
            return val.original;
          }
          if (CID2.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = lexToIpld(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var ipldToLex = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => ipldToLex(item));
        }
        if (val && typeof val === "object") {
          if ((val["$type"] === "blob" || typeof val["cid"] === "string" && typeof val["mimeType"] === "string") && check_exports.is(val, jsonBlobRef)) {
            return BlobRef.fromJsonRef(val);
          }
          if (CID2.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = ipldToLex(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var lexToJson = (val) => {
        return ipldToJson(lexToIpld(val));
      };
      var stringifyLex = (val) => {
        return JSON.stringify(lexToJson(val));
      };
      var jsonToLex = (val) => {
        return ipldToLex(jsonToIpld(val));
      };
      var jsonStringToLex = (val) => {
        return jsonToLex(JSON.parse(val));
      };
      var errorResponseBody = z.object({
        error: z.string().optional(),
        message: z.string().optional()
      });
      var ResponseType = /* @__PURE__ */ ((ResponseType2) => {
        ResponseType2[ResponseType2["Unknown"] = 1] = "Unknown";
        ResponseType2[ResponseType2["InvalidResponse"] = 2] = "InvalidResponse";
        ResponseType2[ResponseType2["Success"] = 200] = "Success";
        ResponseType2[ResponseType2["InvalidRequest"] = 400] = "InvalidRequest";
        ResponseType2[ResponseType2["AuthRequired"] = 401] = "AuthRequired";
        ResponseType2[ResponseType2["Forbidden"] = 403] = "Forbidden";
        ResponseType2[ResponseType2["XRPCNotSupported"] = 404] = "XRPCNotSupported";
        ResponseType2[ResponseType2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
        ResponseType2[ResponseType2["RateLimitExceeded"] = 429] = "RateLimitExceeded";
        ResponseType2[ResponseType2["InternalServerError"] = 500] = "InternalServerError";
        ResponseType2[ResponseType2["MethodNotImplemented"] = 501] = "MethodNotImplemented";
        ResponseType2[ResponseType2["UpstreamFailure"] = 502] = "UpstreamFailure";
        ResponseType2[ResponseType2["NotEnoughResources"] = 503] = "NotEnoughResources";
        ResponseType2[ResponseType2["UpstreamTimeout"] = 504] = "UpstreamTimeout";
        return ResponseType2;
      })(ResponseType || {});
      var ResponseTypeNames = {
        [
          2
          /* InvalidResponse */
        ]: "InvalidResponse",
        [
          200
          /* Success */
        ]: "Success",
        [
          400
          /* InvalidRequest */
        ]: "InvalidRequest",
        [
          401
          /* AuthRequired */
        ]: "AuthenticationRequired",
        [
          403
          /* Forbidden */
        ]: "Forbidden",
        [
          404
          /* XRPCNotSupported */
        ]: "XRPCNotSupported",
        [
          413
          /* PayloadTooLarge */
        ]: "PayloadTooLarge",
        [
          429
          /* RateLimitExceeded */
        ]: "RateLimitExceeded",
        [
          500
          /* InternalServerError */
        ]: "InternalServerError",
        [
          501
          /* MethodNotImplemented */
        ]: "MethodNotImplemented",
        [
          502
          /* UpstreamFailure */
        ]: "UpstreamFailure",
        [
          503
          /* NotEnoughResources */
        ]: "NotEnoughResources",
        [
          504
          /* UpstreamTimeout */
        ]: "UpstreamTimeout"
      };
      var ResponseTypeStrings = {
        [
          2
          /* InvalidResponse */
        ]: "Invalid Response",
        [
          200
          /* Success */
        ]: "Success",
        [
          400
          /* InvalidRequest */
        ]: "Invalid Request",
        [
          401
          /* AuthRequired */
        ]: "Authentication Required",
        [
          403
          /* Forbidden */
        ]: "Forbidden",
        [
          404
          /* XRPCNotSupported */
        ]: "XRPC Not Supported",
        [
          413
          /* PayloadTooLarge */
        ]: "Payload Too Large",
        [
          429
          /* RateLimitExceeded */
        ]: "Rate Limit Exceeded",
        [
          500
          /* InternalServerError */
        ]: "Internal Server Error",
        [
          501
          /* MethodNotImplemented */
        ]: "Method Not Implemented",
        [
          502
          /* UpstreamFailure */
        ]: "Upstream Failure",
        [
          503
          /* NotEnoughResources */
        ]: "Not Enough Resources",
        [
          504
          /* UpstreamTimeout */
        ]: "Upstream Timeout"
      };
      var XRPCResponse = class {
        constructor(data, headers) {
          this.data = data;
          this.headers = headers;
          this.success = true;
        }
      };
      var XRPCError = class extends Error {
        constructor(status, error, message, headers) {
          super(message || error || ResponseTypeStrings[status]);
          this.status = status;
          this.error = error;
          this.success = false;
          if (!this.error) {
            this.error = ResponseTypeNames[status];
          }
          this.headers = headers;
        }
      };
      var XRPCInvalidResponseError = class extends XRPCError {
        constructor(lexiconNsid, validationError, responseBody) {
          super(2, ResponseTypeStrings[
            2
            /* InvalidResponse */
          ], `The server gave an invalid response and may be out of date.`);
          this.lexiconNsid = lexiconNsid;
          this.validationError = validationError;
          this.responseBody = responseBody;
        }
      };
      function getMethodSchemaHTTPMethod(schema2) {
        if (schema2.type === "procedure") {
          return "post";
        }
        return "get";
      }
      function constructMethodCallUri(nsid2, schema2, serviceUri, params2) {
        var _a2, _b;
        const uri2 = new URL(serviceUri);
        uri2.pathname = `/xrpc/${nsid2}`;
        if (params2) {
          for (const [key, value] of Object.entries(params2)) {
            const paramSchema = (_b = (_a2 = schema2.parameters) == null ? void 0 : _a2.properties) == null ? void 0 : _b[key];
            if (!paramSchema) {
              throw new Error(`Invalid query parameter: ${key}`);
            }
            if (value !== void 0) {
              if (paramSchema.type === "array") {
                const vals = [];
                vals.concat(value).forEach((val) => {
                  uri2.searchParams.append(key, encodeQueryParam(paramSchema.items.type, val));
                });
              } else {
                uri2.searchParams.set(key, encodeQueryParam(paramSchema.type, value));
              }
            }
          }
        }
        return uri2.toString();
      }
      function encodeQueryParam(type, value) {
        if (type === "string" || type === "unknown") {
          return String(value);
        }
        if (type === "float") {
          return String(Number(value));
        } else if (type === "integer") {
          return String(Number(value) | 0);
        } else if (type === "boolean") {
          return value ? "true" : "false";
        } else if (type === "datetime") {
          if (value instanceof Date) {
            return value.toISOString();
          }
          return String(value);
        }
        throw new Error(`Unsupported query param type: ${type}`);
      }
      function normalizeHeaders(headers) {
        const normalized = {};
        for (const [header, value] of Object.entries(headers)) {
          normalized[header.toLowerCase()] = value;
        }
        return normalized;
      }
      function constructMethodCallHeaders(schema2, data, opts) {
        const headers = (opts == null ? void 0 : opts.headers) || {};
        if (schema2.type === "procedure") {
          if (opts == null ? void 0 : opts.encoding) {
            headers["Content-Type"] = opts.encoding;
          }
          if (data && typeof data === "object") {
            if (!headers["Content-Type"]) {
              headers["Content-Type"] = "application/json";
            }
          }
        }
        return headers;
      }
      function encodeMethodCallBody(headers, data) {
        if (!headers["content-type"] || typeof data === "undefined") {
          return void 0;
        }
        if (data instanceof ArrayBuffer) {
          return data;
        }
        if (headers["content-type"].startsWith("text/")) {
          return new TextEncoder().encode(data.toString());
        }
        if (headers["content-type"].startsWith("application/json")) {
          return new TextEncoder().encode(stringifyLex(data));
        }
        return data;
      }
      function httpResponseCodeToEnum(status) {
        let resCode;
        if (status in ResponseType) {
          resCode = status;
        } else if (status >= 100 && status < 200) {
          resCode = 404;
        } else if (status >= 200 && status < 300) {
          resCode = 200;
        } else if (status >= 300 && status < 400) {
          resCode = 404;
        } else if (status >= 400 && status < 500) {
          resCode = 400;
        } else {
          resCode = 500;
        }
        return resCode;
      }
      function httpResponseBodyParse(mimeType, data) {
        if (mimeType) {
          if (mimeType.includes("application/json") && (data == null ? void 0 : data.byteLength)) {
            try {
              const str = new TextDecoder().decode(data);
              return jsonStringToLex(str);
            } catch (e) {
              throw new XRPCError(2, `Failed to parse response body: ${String(e)}`);
            }
          }
          if (mimeType.startsWith("text/") && (data == null ? void 0 : data.byteLength)) {
            try {
              return new TextDecoder().decode(data);
            } catch (e) {
              throw new XRPCError(2, `Failed to parse response body: ${String(e)}`);
            }
          }
        }
        if (data instanceof ArrayBuffer) {
          return new Uint8Array(data);
        }
        return data;
      }
      var Client = class {
        constructor() {
          this.fetch = defaultFetchHandler;
          this.lex = new Lexicons();
        }
        call(serviceUri, methodNsid, params2, data, opts) {
          return __async(this, null, function* () {
            return this.service(serviceUri).call(methodNsid, params2, data, opts);
          });
        }
        service(serviceUri) {
          return new ServiceClient(this, serviceUri);
        }
        addLexicon(doc) {
          this.lex.add(doc);
        }
        addLexicons(docs) {
          for (const doc of docs) {
            this.addLexicon(doc);
          }
        }
        removeLexicon(uri2) {
          this.lex.remove(uri2);
        }
      };
      var ServiceClient = class {
        constructor(baseClient, serviceUri) {
          this.headers = {};
          this.baseClient = baseClient;
          this.uri = typeof serviceUri === "string" ? new URL(serviceUri) : serviceUri;
        }
        setHeader(key, value) {
          this.headers[key] = value;
        }
        unsetHeader(key) {
          delete this.headers[key];
        }
        call(methodNsid, params2, data, opts) {
          return __async(this, null, function* () {
            const def2 = this.baseClient.lex.getDefOrThrow(methodNsid);
            if (!def2 || def2.type !== "query" && def2.type !== "procedure") {
              throw new Error(`Invalid lexicon: ${methodNsid}. Must be a query or procedure.`);
            }
            const httpMethod = getMethodSchemaHTTPMethod(def2);
            const httpUri = constructMethodCallUri(methodNsid, def2, this.uri, params2);
            const httpHeaders = constructMethodCallHeaders(def2, data, {
              headers: __spreadValues(__spreadValues({}, this.headers), opts == null ? void 0 : opts.headers),
              encoding: opts == null ? void 0 : opts.encoding
            });
            const res = yield this.baseClient.fetch(httpUri, httpMethod, httpHeaders, data);
            const resCode = httpResponseCodeToEnum(res.status);
            if (resCode === 200) {
              try {
                this.baseClient.lex.assertValidXrpcOutput(methodNsid, res.body);
              } catch (e) {
                if (e instanceof ValidationError) {
                  throw new XRPCInvalidResponseError(methodNsid, e, res.body);
                } else {
                  throw e;
                }
              }
              return new XRPCResponse(res.body, res.headers);
            } else {
              if (res.body && isErrorResponseBody(res.body)) {
                throw new XRPCError(resCode, res.body.error, res.body.message, res.headers);
              } else {
                throw new XRPCError(resCode);
              }
            }
          });
        }
      };
      function defaultFetchHandler(httpUri, httpMethod, httpHeaders, httpReqBody) {
        return __async(this, null, function* () {
          try {
            const headers = normalizeHeaders(httpHeaders);
            const reqInit = {
              method: httpMethod,
              headers,
              body: encodeMethodCallBody(headers, httpReqBody),
              duplex: "half"
            };
            const res = yield fetch(httpUri, reqInit);
            const resBody = yield res.arrayBuffer();
            return {
              status: res.status,
              headers: Object.fromEntries(res.headers.entries()),
              body: httpResponseBodyParse(res.headers.get("content-type"), resBody)
            };
          } catch (e) {
            throw new XRPCError(1, String(e));
          }
        });
      }
      function isErrorResponseBody(v) {
        return errorResponseBody.safeParse(v).success;
      }
      var defaultInst = new Client();
      var schemaDict = {
        ComAtprotoAdminDefs: {
          lexicon: 1,
          id: "com.atproto.admin.defs",
          defs: {
            statusAttr: {
              type: "object",
              required: ["applied"],
              properties: {
                applied: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            },
            modEventView: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobCids",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#modEventTakedown",
                    "lex:com.atproto.admin.defs#modEventReverseTakedown",
                    "lex:com.atproto.admin.defs#modEventComment",
                    "lex:com.atproto.admin.defs#modEventReport",
                    "lex:com.atproto.admin.defs#modEventLabel",
                    "lex:com.atproto.admin.defs#modEventAcknowledge",
                    "lex:com.atproto.admin.defs#modEventEscalate",
                    "lex:com.atproto.admin.defs#modEventMute",
                    "lex:com.atproto.admin.defs#modEventEmail"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                creatorHandle: {
                  type: "string"
                },
                subjectHandle: {
                  type: "string"
                }
              }
            },
            modEventViewDetail: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobs",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#modEventTakedown",
                    "lex:com.atproto.admin.defs#modEventReverseTakedown",
                    "lex:com.atproto.admin.defs#modEventComment",
                    "lex:com.atproto.admin.defs#modEventReport",
                    "lex:com.atproto.admin.defs#modEventLabel",
                    "lex:com.atproto.admin.defs#modEventAcknowledge",
                    "lex:com.atproto.admin.defs#modEventEscalate",
                    "lex:com.atproto.admin.defs#modEventMute",
                    "lex:com.atproto.admin.defs#modEventResolveAppeal"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoView",
                    "lex:com.atproto.admin.defs#repoViewNotFound",
                    "lex:com.atproto.admin.defs#recordView",
                    "lex:com.atproto.admin.defs#recordViewNotFound"
                  ]
                },
                subjectBlobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#blobView"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            reportView: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt",
                "resolvedByActionIds"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                comment: {
                  type: "string"
                },
                subjectRepoHandle: {
                  type: "string"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                resolvedByActionIds: {
                  type: "array",
                  items: {
                    type: "integer"
                  }
                }
              }
            },
            subjectStatusView: {
              type: "object",
              required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
              properties: {
                id: {
                  type: "integer"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                subjectRepoHandle: {
                  type: "string"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the last update was made to the moderation status of the subject"
                },
                createdAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
                },
                reviewState: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectReviewState"
                },
                comment: {
                  type: "string",
                  description: "Sticky comment on the subject."
                },
                muteUntil: {
                  type: "string",
                  format: "datetime"
                },
                lastReviewedBy: {
                  type: "string",
                  format: "did"
                },
                lastReviewedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastReportedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastAppealedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the author of the subject appealed a moderation action"
                },
                takendown: {
                  type: "boolean"
                },
                appealed: {
                  type: "boolean",
                  description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
                },
                suspendUntil: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            reportViewDetail: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt",
                "resolvedByActions"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                comment: {
                  type: "string"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoView",
                    "lex:com.atproto.admin.defs#repoViewNotFound",
                    "lex:com.atproto.admin.defs#recordView",
                    "lex:com.atproto.admin.defs#recordViewNotFound"
                  ]
                },
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                resolvedByActions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#modEventView"
                  }
                }
              }
            },
            repoView: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                }
              }
            },
            repoViewDetail: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderationDetail"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            accountView: {
              type: "object",
              required: ["did", "handle", "indexedAt"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                },
                inviteNote: {
                  type: "string"
                }
              }
            },
            repoViewNotFound: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            repoRef: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            repoBlobRef: {
              type: "object",
              required: ["did", "cid"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                recordUri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            recordView: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobCids",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                },
                repo: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoView"
                }
              }
            },
            recordViewDetail: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobs",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#blobView"
                  }
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderationDetail"
                },
                repo: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoView"
                }
              }
            },
            recordViewNotFound: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            moderation: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                }
              }
            },
            moderationDetail: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                }
              }
            },
            blobView: {
              type: "object",
              required: ["cid", "mimeType", "size", "createdAt"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                mimeType: {
                  type: "string"
                },
                size: {
                  type: "integer"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                details: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#imageDetails",
                    "lex:com.atproto.admin.defs#videoDetails"
                  ]
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                }
              }
            },
            imageDetails: {
              type: "object",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                }
              }
            },
            videoDetails: {
              type: "object",
              required: ["width", "height", "length"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                },
                length: {
                  type: "integer"
                }
              }
            },
            subjectReviewState: {
              type: "string",
              knownValues: [
                "lex:com.atproto.admin.defs#reviewOpen",
                "lex:com.atproto.admin.defs#reviewEscalated",
                "lex:com.atproto.admin.defs#reviewClosed"
              ]
            },
            reviewOpen: {
              type: "token",
              description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
            },
            reviewEscalated: {
              type: "token",
              description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
            },
            reviewClosed: {
              type: "token",
              description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
            },
            modEventTakedown: {
              type: "object",
              description: "Take down a subject permanently or temporarily",
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the takedown should be in effect before automatically expiring."
                }
              }
            },
            modEventReverseTakedown: {
              type: "object",
              description: "Revert take down action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventResolveAppeal: {
              type: "object",
              description: "Resolve appeal on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe resolution."
                }
              }
            },
            modEventComment: {
              type: "object",
              description: "Add a comment to a subject",
              required: ["comment"],
              properties: {
                comment: {
                  type: "string"
                },
                sticky: {
                  type: "boolean",
                  description: "Make the comment persistent on the subject"
                }
              }
            },
            modEventReport: {
              type: "object",
              description: "Report a subject",
              required: ["reportType"],
              properties: {
                comment: {
                  type: "string"
                },
                reportType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                }
              }
            },
            modEventLabel: {
              type: "object",
              description: "Apply/Negate labels on a subject",
              required: ["createLabelVals", "negateLabelVals"],
              properties: {
                comment: {
                  type: "string"
                },
                createLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                negateLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            },
            modEventAcknowledge: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventEscalate: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventMute: {
              type: "object",
              description: "Mute incoming reports on a subject",
              required: ["durationInHours"],
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the subject should remain muted."
                }
              }
            },
            modEventUnmute: {
              type: "object",
              description: "Unmute action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventEmail: {
              type: "object",
              description: "Keep a log of outgoing email to a user",
              required: ["subjectLine"],
              properties: {
                subjectLine: {
                  type: "string",
                  description: "The subject line of the email sent to the user."
                },
                comment: {
                  type: "string",
                  description: "Additional comment about the outgoing comm."
                }
              }
            }
          }
        },
        ComAtprotoAdminDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.admin.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a user account as an administrator.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.disableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for disabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.disableInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Disable some set of codes and/or all codes associated with a set of users.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminEmitModerationEvent: {
          lexicon: 1,
          id: "com.atproto.admin.emitModerationEvent",
          defs: {
            main: {
              type: "procedure",
              description: "Take a moderation action on an actor.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["event", "subject", "createdBy"],
                  properties: {
                    event: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#modEventTakedown",
                        "lex:com.atproto.admin.defs#modEventAcknowledge",
                        "lex:com.atproto.admin.defs#modEventEscalate",
                        "lex:com.atproto.admin.defs#modEventComment",
                        "lex:com.atproto.admin.defs#modEventLabel",
                        "lex:com.atproto.admin.defs#modEventReport",
                        "lex:com.atproto.admin.defs#modEventMute",
                        "lex:com.atproto.admin.defs#modEventReverseTakedown",
                        "lex:com.atproto.admin.defs#modEventUnmute",
                        "lex:com.atproto.admin.defs#modEventEmail"
                      ]
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    subjectBlobCids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    },
                    createdBy: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#modEventView"
                }
              },
              errors: [
                {
                  name: "SubjectHasAction"
                }
              ]
            }
          }
        },
        ComAtprotoAdminEnableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.enableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Re-enable an account's ability to receive invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for enabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetAccountInfo: {
          lexicon: 1,
          id: "com.atproto.admin.getAccountInfo",
          defs: {
            main: {
              type: "query",
              description: "Get details about an account.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#accountView"
                }
              }
            }
          }
        },
        ComAtprotoAdminGetInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.getInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get an admin view of invite codes.",
              parameters: {
                type: "params",
                properties: {
                  sort: {
                    type: "string",
                    knownValues: ["recent", "usage"],
                    default: "recent"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 500,
                    default: 100
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetModerationEvent: {
          lexicon: 1,
          id: "com.atproto.admin.getModerationEvent",
          defs: {
            main: {
              type: "query",
              description: "Get details about a moderation event.",
              parameters: {
                type: "params",
                required: ["id"],
                properties: {
                  id: {
                    type: "integer"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#modEventViewDetail"
                }
              }
            }
          }
        },
        ComAtprotoAdminGetRecord: {
          lexicon: 1,
          id: "com.atproto.admin.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get details about a record.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#recordViewDetail"
                }
              },
              errors: [
                {
                  name: "RecordNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoAdminGetRepo: {
          lexicon: 1,
          id: "com.atproto.admin.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Get details about a repository.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoViewDetail"
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoAdminGetSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.getSubjectStatus",
          defs: {
            main: {
              type: "query",
              description: "Get the service-specific admin status of a subject (account, record, or blob).",
              parameters: {
                type: "params",
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  blob: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminQueryModerationEvents: {
          lexicon: 1,
          id: "com.atproto.admin.queryModerationEvents",
          defs: {
            main: {
              type: "query",
              description: "List moderation events related to a subject.",
              parameters: {
                type: "params",
                properties: {
                  types: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "The types of events (fully qualified string in the format of com.atproto.admin#modEvent<name>) to filter by. If not specified, all events are returned."
                  },
                  createdBy: {
                    type: "string",
                    format: "did"
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"],
                    description: "Sort direction for the events. Defaults to descending order of created at timestamp."
                  },
                  subject: {
                    type: "string",
                    format: "uri"
                  },
                  includeAllUserRecords: {
                    type: "boolean",
                    default: false,
                    description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["events"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    events: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#modEventView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminQueryModerationStatuses: {
          lexicon: 1,
          id: "com.atproto.admin.queryModerationStatuses",
          defs: {
            main: {
              type: "query",
              description: "View moderation statuses of subjects (record or repo).",
              parameters: {
                type: "params",
                properties: {
                  subject: {
                    type: "string",
                    format: "uri"
                  },
                  comment: {
                    type: "string",
                    description: "Search subjects by keyword from comments"
                  },
                  reportedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported after a given timestamp"
                  },
                  reportedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported before a given timestamp"
                  },
                  reviewedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed after a given timestamp"
                  },
                  reviewedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed before a given timestamp"
                  },
                  includeMuted: {
                    type: "boolean",
                    description: "By default, we don't include muted subjects in the results. Set this to true to include them."
                  },
                  reviewState: {
                    type: "string",
                    description: "Specify when fetching subjects in a certain state"
                  },
                  ignoreSubjects: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "uri"
                    }
                  },
                  lastReviewedBy: {
                    type: "string",
                    format: "did",
                    description: "Get all subject statuses that were reviewed by a specific moderator"
                  },
                  sortField: {
                    type: "string",
                    default: "lastReportedAt",
                    enum: ["lastReviewedAt", "lastReportedAt"]
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"]
                  },
                  takendown: {
                    type: "boolean",
                    description: "Get subjects that were taken down"
                  },
                  appealed: {
                    type: "boolean",
                    description: "Get subjects in unresolved appealed status"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subjectStatuses"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    subjectStatuses: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#subjectStatusView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSearchRepos: {
          lexicon: 1,
          id: "com.atproto.admin.searchRepos",
          defs: {
            main: {
              type: "query",
              description: "Find repositories based on a search term.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead"
                  },
                  q: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#repoView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSendEmail: {
          lexicon: 1,
          id: "com.atproto.admin.sendEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Send email to a user's account email address.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["recipientDid", "content", "senderDid"],
                  properties: {
                    recipientDid: {
                      type: "string",
                      format: "did"
                    },
                    content: {
                      type: "string"
                    },
                    subject: {
                      type: "string"
                    },
                    senderDid: {
                      type: "string",
                      format: "did"
                    },
                    comment: {
                      type: "string",
                      description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["sent"],
                  properties: {
                    sent: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountEmail: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account", "email"],
                  properties: {
                    account: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountHandle: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "handle"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.updateSubjectStatus",
          defs: {
            main: {
              type: "procedure",
              description: "Update the service-specific admin status of a subject (account, record, or blob).",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityResolveHandle: {
          lexicon: 1,
          id: "com.atproto.identity.resolveHandle",
          defs: {
            main: {
              type: "query",
              description: "Provides the DID of a repo.",
              parameters: {
                type: "params",
                required: ["handle"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle",
                    description: "The handle to resolve."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityUpdateHandle: {
          lexicon: 1,
          id: "com.atproto.identity.updateHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Updates the handle of the account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelDefs: {
          lexicon: 1,
          id: "com.atproto.label.defs",
          defs: {
            label: {
              type: "object",
              description: "Metadata tag on an atproto resource (eg, repo or record).",
              required: ["src", "uri", "val", "cts"],
              properties: {
                src: {
                  type: "string",
                  format: "did",
                  description: "DID of the actor who created this label."
                },
                uri: {
                  type: "string",
                  format: "uri",
                  description: "AT URI of the record, repository (account), or other resource that this label applies to."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
                },
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                },
                neg: {
                  type: "boolean",
                  description: "If true, this is a negation label, overwriting a previous label."
                },
                cts: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp when this label was created."
                }
              }
            },
            selfLabels: {
              type: "object",
              description: "Metadata tags on an atproto record, published by the author within the record.",
              required: ["values"],
              properties: {
                values: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#selfLabel"
                  },
                  maxLength: 10
                }
              }
            },
            selfLabel: {
              type: "object",
              description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
              required: ["val"],
              properties: {
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                }
              }
            }
          }
        },
        ComAtprotoLabelQueryLabels: {
          lexicon: 1,
          id: "com.atproto.label.queryLabels",
          defs: {
            main: {
              type: "query",
              description: "Find labels relevant to the provided URI patterns.",
              parameters: {
                type: "params",
                required: ["uriPatterns"],
                properties: {
                  uriPatterns: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
                  },
                  sources: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    },
                    description: "Optional list of label sources (DIDs) to filter on."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelSubscribeLabels: {
          lexicon: 1,
          id: "com.atproto.label.subscribeLabels",
          defs: {
            main: {
              type: "subscription",
              description: "Subscribe to label updates.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.label.subscribeLabels#labels",
                    "lex:com.atproto.label.subscribeLabels#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                }
              ]
            },
            labels: {
              type: "object",
              required: ["seq", "labels"],
              properties: {
                seq: {
                  type: "integer"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoModerationCreateReport: {
          lexicon: 1,
          id: "com.atproto.moderation.createReport",
          defs: {
            main: {
              type: "procedure",
              description: "Report a repo or a record.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["reasonType", "subject"],
                  properties: {
                    reasonType: {
                      type: "ref",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string"
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "id",
                    "reasonType",
                    "subject",
                    "reportedBy",
                    "createdAt"
                  ],
                  properties: {
                    id: {
                      type: "integer"
                    },
                    reasonType: {
                      type: "ref",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string",
                      maxGraphemes: 2e3,
                      maxLength: 2e4
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    reportedBy: {
                      type: "string",
                      format: "did"
                    },
                    createdAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoModerationDefs: {
          lexicon: 1,
          id: "com.atproto.moderation.defs",
          defs: {
            reasonType: {
              type: "string",
              knownValues: [
                "com.atproto.moderation.defs#reasonSpam",
                "com.atproto.moderation.defs#reasonViolation",
                "com.atproto.moderation.defs#reasonMisleading",
                "com.atproto.moderation.defs#reasonSexual",
                "com.atproto.moderation.defs#reasonRude",
                "com.atproto.moderation.defs#reasonOther",
                "com.atproto.moderation.defs#reasonAppeal"
              ]
            },
            reasonSpam: {
              type: "token",
              description: "Spam: frequent unwanted promotion, replies, mentions"
            },
            reasonViolation: {
              type: "token",
              description: "Direct violation of server rules, laws, terms of service"
            },
            reasonMisleading: {
              type: "token",
              description: "Misleading identity, affiliation, or content"
            },
            reasonSexual: {
              type: "token",
              description: "Unwanted or mislabeled sexual content"
            },
            reasonRude: {
              type: "token",
              description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
            },
            reasonOther: {
              type: "token",
              description: "Other: reports not falling under another report category"
            },
            reasonAppeal: {
              type: "token",
              description: "Appeal: appeal a previously taken moderation action"
            }
          }
        },
        ComAtprotoRepoApplyWrites: {
          lexicon: 1,
          id: "com.atproto.repo.applyWrites",
          defs: {
            main: {
              type: "procedure",
              description: "Apply a batch transaction of creates, updates, and deletes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "writes"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the records."
                    },
                    writes: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:com.atproto.repo.applyWrites#create",
                          "lex:com.atproto.repo.applyWrites#update",
                          "lex:com.atproto.repo.applyWrites#delete"
                        ],
                        closed: true
                      }
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            },
            create: {
              type: "object",
              description: "Create a new record.",
              required: ["collection", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string",
                  maxLength: 15
                },
                value: {
                  type: "unknown"
                }
              }
            },
            update: {
              type: "object",
              description: "Update an existing record.",
              required: ["collection", "rkey", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                },
                value: {
                  type: "unknown"
                }
              }
            },
            delete: {
              type: "object",
              description: "Delete an existing record.",
              required: ["collection", "rkey"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoRepoCreateRecord: {
          lexicon: 1,
          id: "com.atproto.repo.createRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Create a new record.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "record"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record.",
                      maxLength: 15
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the record."
                    },
                    record: {
                      type: "unknown",
                      description: "The record to create."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoDeleteRecord: {
          lexicon: 1,
          id: "com.atproto.repo.deleteRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a record, or ensure it doesn't exist.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoDescribeRepo: {
          lexicon: 1,
          id: "com.atproto.repo.describeRepo",
          defs: {
            main: {
              type: "query",
              description: "Get information about the repo, including the list of collections.",
              parameters: {
                type: "params",
                required: ["repo"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "handle",
                    "did",
                    "didDoc",
                    "collections",
                    "handleIsCorrect"
                  ],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    collections: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "nsid"
                      }
                    },
                    handleIsCorrect: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoRepoGetRecord: {
          lexicon: 1,
          id: "com.atproto.repo.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get a record.",
              parameters: {
                type: "params",
                required: ["repo", "collection", "rkey"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    description: "The key of the record."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the version of the record. If not specified, then return the most recent version."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "value"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    value: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoRepoListRecords: {
          lexicon: 1,
          id: "com.atproto.repo.listRecords",
          defs: {
            main: {
              type: "query",
              description: "List a range of records in a collection.",
              parameters: {
                type: "params",
                required: ["repo", "collection"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record type."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50,
                    description: "The number of records to return."
                  },
                  cursor: {
                    type: "string"
                  },
                  rkeyStart: {
                    type: "string",
                    description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
                  },
                  rkeyEnd: {
                    type: "string",
                    description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
                  },
                  reverse: {
                    type: "boolean",
                    description: "Flag to reverse the order of the returned records."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["records"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    records: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.repo.listRecords#record"
                      }
                    }
                  }
                }
              }
            },
            record: {
              type: "object",
              required: ["uri", "cid", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        },
        ComAtprotoRepoPutRecord: {
          lexicon: 1,
          id: "com.atproto.repo.putRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Write a record, creating or updating it as needed.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey", "record"],
                  nullable: ["swapRecord"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record.",
                      maxLength: 15
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the record."
                    },
                    record: {
                      type: "unknown",
                      description: "The record to write."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoStrongRef: {
          lexicon: 1,
          id: "com.atproto.repo.strongRef",
          description: "A URI with a content-hash fingerprint.",
          defs: {
            main: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          }
        },
        ComAtprotoRepoUploadBlob: {
          lexicon: 1,
          id: "com.atproto.repo.uploadBlob",
          defs: {
            main: {
              type: "procedure",
              description: "Upload a new blob to be added to repo in a later request.",
              input: {
                encoding: "*/*"
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blob"],
                  properties: {
                    blob: {
                      type: "blob"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerConfirmEmail: {
          lexicon: 1,
          id: "com.atproto.server.confirmEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email", "token"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountNotFound"
                },
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "InvalidEmail"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAccount: {
          lexicon: 1,
          id: "com.atproto.server.createAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Create an account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    inviteCode: {
                      type: "string"
                    },
                    password: {
                      type: "string"
                    },
                    recoveryKey: {
                      type: "string"
                    },
                    plcOp: {
                      type: "unknown"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidHandle"
                },
                {
                  name: "InvalidPassword"
                },
                {
                  name: "InvalidInviteCode"
                },
                {
                  name: "HandleNotAvailable"
                },
                {
                  name: "UnsupportedDomain"
                },
                {
                  name: "UnresolvableDid"
                },
                {
                  name: "IncompatibleDidDoc"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.createAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Create an App Password.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.server.createAppPassword#appPassword"
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "password", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                password: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCode: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCode",
          defs: {
            main: {
              type: "procedure",
              description: "Create an invite code.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["useCount"],
                  properties: {
                    useCount: {
                      type: "integer"
                    },
                    forAccount: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["code"],
                  properties: {
                    code: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Create invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codeCount", "useCount"],
                  properties: {
                    codeCount: {
                      type: "integer",
                      default: 1
                    },
                    useCount: {
                      type: "integer"
                    },
                    forAccounts: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "did"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                      }
                    }
                  }
                }
              }
            },
            accountCodes: {
              type: "object",
              required: ["account", "codes"],
              properties: {
                account: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateSession: {
          lexicon: 1,
          id: "com.atproto.server.createSession",
          defs: {
            main: {
              type: "procedure",
              description: "Create an authentication session.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["identifier", "password"],
                  properties: {
                    identifier: {
                      type: "string",
                      description: "Handle or other identifier supported by the server for the authenticating user."
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            }
          }
        },
        ComAtprotoServerDefs: {
          lexicon: 1,
          id: "com.atproto.server.defs",
          defs: {
            inviteCode: {
              type: "object",
              required: [
                "code",
                "available",
                "disabled",
                "forAccount",
                "createdBy",
                "createdAt",
                "uses"
              ],
              properties: {
                code: {
                  type: "string"
                },
                available: {
                  type: "integer"
                },
                disabled: {
                  type: "boolean"
                },
                forAccount: {
                  type: "string"
                },
                createdBy: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                uses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCodeUse"
                  }
                }
              }
            },
            inviteCodeUse: {
              type: "object",
              required: ["usedBy", "usedAt"],
              properties: {
                usedBy: {
                  type: "string",
                  format: "did"
                },
                usedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.server.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete an actor's account with a token and password.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "password", "token"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    password: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerDeleteSession: {
          lexicon: 1,
          id: "com.atproto.server.deleteSession",
          defs: {
            main: {
              type: "procedure",
              description: "Delete the current session."
            }
          }
        },
        ComAtprotoServerDescribeServer: {
          lexicon: 1,
          id: "com.atproto.server.describeServer",
          defs: {
            main: {
              type: "query",
              description: "Get a document describing the service's accounts configuration.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["availableUserDomains"],
                  properties: {
                    inviteCodeRequired: {
                      type: "boolean"
                    },
                    availableUserDomains: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    links: {
                      type: "ref",
                      ref: "lex:com.atproto.server.describeServer#links"
                    }
                  }
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string"
                },
                termsOfService: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoServerGetAccountInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.getAccountInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get all invite codes for a given account.",
              parameters: {
                type: "params",
                properties: {
                  includeUsed: {
                    type: "boolean",
                    default: true
                  },
                  createAvailable: {
                    type: "boolean",
                    default: true
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "DuplicateCreate"
                }
              ]
            }
          }
        },
        ComAtprotoServerGetSession: {
          lexicon: 1,
          id: "com.atproto.server.getSession",
          defs: {
            main: {
              type: "query",
              description: "Get information about the current session.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle", "did"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerListAppPasswords: {
          lexicon: 1,
          id: "com.atproto.server.listAppPasswords",
          defs: {
            main: {
              type: "query",
              description: "List all App Passwords.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["passwords"],
                  properties: {
                    passwords: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerRefreshSession: {
          lexicon: 1,
          id: "com.atproto.server.refreshSession",
          defs: {
            main: {
              type: "procedure",
              description: "Refresh an authentication session.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            }
          }
        },
        ComAtprotoServerRequestAccountDelete: {
          lexicon: 1,
          id: "com.atproto.server.requestAccountDelete",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account deletion via email."
            }
          }
        },
        ComAtprotoServerRequestEmailConfirmation: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailConfirmation",
          defs: {
            main: {
              type: "procedure",
              description: "Request an email with a code to confirm ownership of email."
            }
          }
        },
        ComAtprotoServerRequestEmailUpdate: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Request a token in order to update email.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["tokenRequired"],
                  properties: {
                    tokenRequired: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerRequestPasswordReset: {
          lexicon: 1,
          id: "com.atproto.server.requestPasswordReset",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account password reset via email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerReserveSigningKey: {
          lexicon: 1,
          id: "com.atproto.server.reserveSigningKey",
          defs: {
            main: {
              type: "procedure",
              description: "Reserve a repo signing key for account creation.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    did: {
                      type: "string",
                      description: "The did to reserve a new did:key for"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["signingKey"],
                  properties: {
                    signingKey: {
                      type: "string",
                      description: "Public signing key in the form of a did:key."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerResetPassword: {
          lexicon: 1,
          id: "com.atproto.server.resetPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Reset a user account password using a token.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["token", "password"],
                  properties: {
                    token: {
                      type: "string"
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerRevokeAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.revokeAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Revoke an App Password by name.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerUpdateEmail: {
          lexicon: 1,
          id: "com.atproto.server.updateEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    token: {
                      type: "string",
                      description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "TokenRequired"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetBlob: {
          lexicon: 1,
          id: "com.atproto.sync.getBlob",
          defs: {
            main: {
              type: "query",
              description: "Get a blob associated with a given repo.",
              parameters: {
                type: "params",
                required: ["did", "cid"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the blob to fetch"
                  }
                }
              },
              output: {
                encoding: "*/*"
              }
            }
          }
        },
        ComAtprotoSyncGetBlocks: {
          lexicon: 1,
          id: "com.atproto.sync.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get blocks from a given repo.",
              parameters: {
                type: "params",
                required: ["did", "cids"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  cids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetCheckout: {
          lexicon: 1,
          id: "com.atproto.sync.getCheckout",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetHead: {
          lexicon: 1,
          id: "com.atproto.sync.getHead",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "HeadNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetLatestCommit: {
          lexicon: 1,
          id: "com.atproto.sync.getLatestCommit",
          defs: {
            main: {
              type: "query",
              description: "Get the current commit CID & revision of the repo.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cid", "rev"],
                  properties: {
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    rev: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRecord: {
          lexicon: 1,
          id: "com.atproto.sync.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get blocks needed for existence or non-existence of record.",
              parameters: {
                type: "params",
                required: ["did", "collection", "rkey"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid"
                  },
                  rkey: {
                    type: "string"
                  },
                  commit: {
                    type: "string",
                    format: "cid",
                    description: "An optional past commit CID."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetRepo: {
          lexicon: 1,
          id: "com.atproto.sync.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Gets the DID's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "The revision of the repo to catch up from."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncListBlobs: {
          lexicon: 1,
          id: "com.atproto.sync.listBlobs",
          defs: {
            main: {
              type: "query",
              description: "List blob CIDs since some revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "Optional revision of the repo to list blobs since."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cids"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    cids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncListRepos: {
          lexicon: 1,
          id: "com.atproto.sync.listRepos",
          defs: {
            main: {
              type: "query",
              description: "List DIDs and root CIDs of hosted repos.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.sync.listRepos#repo"
                      }
                    }
                  }
                }
              }
            },
            repo: {
              type: "object",
              required: ["did", "head", "rev"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                head: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoSyncNotifyOfUpdate: {
          lexicon: 1,
          id: "com.atproto.sync.notifyOfUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Notify a crawling service of a recent update; often when a long break between updates causes the connection with the crawling service to break.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the service that is notifying of update."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncRequestCrawl: {
          lexicon: 1,
          id: "com.atproto.sync.requestCrawl",
          defs: {
            main: {
              type: "procedure",
              description: "Request a service to persistently crawl hosted repos.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the service that is requesting to be crawled."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncSubscribeRepos: {
          lexicon: 1,
          id: "com.atproto.sync.subscribeRepos",
          defs: {
            main: {
              type: "subscription",
              description: "Subscribe to repo updates.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.sync.subscribeRepos#commit",
                    "lex:com.atproto.sync.subscribeRepos#handle",
                    "lex:com.atproto.sync.subscribeRepos#migrate",
                    "lex:com.atproto.sync.subscribeRepos#tombstone",
                    "lex:com.atproto.sync.subscribeRepos#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                },
                {
                  name: "ConsumerTooSlow"
                }
              ]
            },
            commit: {
              type: "object",
              required: [
                "seq",
                "rebase",
                "tooBig",
                "repo",
                "commit",
                "rev",
                "since",
                "blocks",
                "ops",
                "blobs",
                "time"
              ],
              nullable: ["prev", "since"],
              properties: {
                seq: {
                  type: "integer"
                },
                rebase: {
                  type: "boolean"
                },
                tooBig: {
                  type: "boolean"
                },
                repo: {
                  type: "string",
                  format: "did"
                },
                commit: {
                  type: "cid-link"
                },
                prev: {
                  type: "cid-link"
                },
                rev: {
                  type: "string",
                  description: "The rev of the emitted commit."
                },
                since: {
                  type: "string",
                  description: "The rev of the last emitted commit from this repo."
                },
                blocks: {
                  type: "bytes",
                  description: "CAR file containing relevant blocks.",
                  maxLength: 1e6
                },
                ops: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.subscribeRepos#repoOp"
                  },
                  maxLength: 200
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "cid-link"
                  }
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            handle: {
              type: "object",
              required: ["seq", "did", "handle", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            migrate: {
              type: "object",
              required: ["seq", "did", "migrateTo", "time"],
              nullable: ["migrateTo"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                migrateTo: {
                  type: "string"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            tombstone: {
              type: "object",
              required: ["seq", "did", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            },
            repoOp: {
              type: "object",
              description: "A repo operation, ie a write of a single record. For creates and updates, CID is the record's CID as of this operation. For deletes, it's null.",
              required: ["action", "path", "cid"],
              nullable: ["cid"],
              properties: {
                action: {
                  type: "string",
                  knownValues: ["create", "update", "delete"]
                },
                path: {
                  type: "string"
                },
                cid: {
                  type: "cid-link"
                }
              }
            }
          }
        },
        ComAtprotoTempFetchLabels: {
          lexicon: 1,
          id: "com.atproto.temp.fetchLabels",
          defs: {
            main: {
              type: "query",
              description: "Fetch all labels from a labeler created after a certain date.",
              parameters: {
                type: "params",
                properties: {
                  since: {
                    type: "integer"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoTempImportRepo: {
          lexicon: 1,
          id: "com.atproto.temp.importRepo",
          defs: {
            main: {
              type: "procedure",
              description: "Gets the did's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              input: {
                encoding: "application/vnd.ipld.car"
              },
              output: {
                encoding: "text/plain"
              }
            }
          }
        },
        ComAtprotoTempPushBlob: {
          lexicon: 1,
          id: "com.atproto.temp.pushBlob",
          defs: {
            main: {
              type: "procedure",
              description: "Gets the did's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              input: {
                encoding: "*/*"
              }
            }
          }
        },
        ComAtprotoTempTransferAccount: {
          lexicon: 1,
          id: "com.atproto.temp.transferAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Transfer an account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle", "did", "plcOp"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    plcOp: {
                      type: "unknown"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidHandle"
                },
                {
                  name: "InvalidPassword"
                },
                {
                  name: "InvalidInviteCode"
                },
                {
                  name: "HandleNotAvailable"
                },
                {
                  name: "UnsupportedDomain"
                },
                {
                  name: "UnresolvableDid"
                },
                {
                  name: "IncompatibleDidDoc"
                }
              ]
            }
          }
        },
        AppBskyActorDefs: {
          lexicon: 1,
          id: "app.bsky.actor.defs",
          description: "A reference to an actor in the network.",
          defs: {
            profileViewBasic: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            profileView: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            profileViewDetailed: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string"
                },
                banner: {
                  type: "string"
                },
                followersCount: {
                  type: "integer"
                },
                followsCount: {
                  type: "integer"
                },
                postsCount: {
                  type: "integer"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            viewerState: {
              type: "object",
              properties: {
                muted: {
                  type: "boolean"
                },
                mutedByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                blockedBy: {
                  type: "boolean"
                },
                blocking: {
                  type: "string",
                  format: "at-uri"
                },
                blockingByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                following: {
                  type: "string",
                  format: "at-uri"
                },
                followedBy: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            preferences: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.actor.defs#adultContentPref",
                  "lex:app.bsky.actor.defs#contentLabelPref",
                  "lex:app.bsky.actor.defs#savedFeedsPref",
                  "lex:app.bsky.actor.defs#personalDetailsPref",
                  "lex:app.bsky.actor.defs#feedViewPref",
                  "lex:app.bsky.actor.defs#threadViewPref"
                ]
              }
            },
            adultContentPref: {
              type: "object",
              required: ["enabled"],
              properties: {
                enabled: {
                  type: "boolean",
                  default: false
                }
              }
            },
            contentLabelPref: {
              type: "object",
              required: ["label", "visibility"],
              properties: {
                label: {
                  type: "string"
                },
                visibility: {
                  type: "string",
                  knownValues: ["show", "warn", "hide"]
                }
              }
            },
            savedFeedsPref: {
              type: "object",
              required: ["pinned", "saved"],
              properties: {
                pinned: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                },
                saved: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            },
            personalDetailsPref: {
              type: "object",
              properties: {
                birthDate: {
                  type: "string",
                  format: "datetime",
                  description: "The birth date of account owner."
                }
              }
            },
            feedViewPref: {
              type: "object",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  description: "The URI of the feed, or an identifier which describes the feed."
                },
                hideReplies: {
                  type: "boolean",
                  description: "Hide replies in the feed."
                },
                hideRepliesByUnfollowed: {
                  type: "boolean",
                  description: "Hide replies in the feed if they are not by followed users."
                },
                hideRepliesByLikeCount: {
                  type: "integer",
                  description: "Hide replies in the feed if they do not have this number of likes."
                },
                hideReposts: {
                  type: "boolean",
                  description: "Hide reposts in the feed."
                },
                hideQuotePosts: {
                  type: "boolean",
                  description: "Hide quote posts in the feed."
                }
              }
            },
            threadViewPref: {
              type: "object",
              properties: {
                sort: {
                  type: "string",
                  description: "Sorting mode for threads.",
                  knownValues: ["oldest", "newest", "most-likes", "random"]
                },
                prioritizeFollowedUsers: {
                  type: "boolean",
                  description: "Show followed users at the top of all replies."
                }
              }
            }
          }
        },
        AppBskyActorGetPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.getPreferences",
          defs: {
            main: {
              type: "query",
              description: "Get private preferences attached to the account.",
              parameters: {
                type: "params",
                properties: {}
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetProfile: {
          lexicon: 1,
          id: "app.bsky.actor.getProfile",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile view of an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                }
              }
            }
          }
        },
        AppBskyActorGetProfiles: {
          lexicon: 1,
          id: "app.bsky.actor.getProfiles",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile views of multiple actors.",
              parameters: {
                type: "params",
                required: ["actors"],
                properties: {
                  actors: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-identifier"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["profiles"],
                  properties: {
                    profiles: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetSuggestions: {
          lexicon: 1,
          id: "app.bsky.actor.getSuggestions",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested actors, used for discovery.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorProfile: {
          lexicon: 1,
          id: "app.bsky.actor.profile",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a profile.",
              key: "literal:self",
              record: {
                type: "object",
                properties: {
                  displayName: {
                    type: "string",
                    maxGraphemes: 64,
                    maxLength: 640
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 256,
                    maxLength: 2560
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  banner: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  }
                }
              }
            }
          }
        },
        AppBskyActorPutPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.putPreferences",
          defs: {
            main: {
              type: "procedure",
              description: "Set the private preferences attached to the account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActors: {
          lexicon: 1,
          id: "app.bsky.actor.searchActors",
          defs: {
            main: {
              type: "query",
              description: "Find actors (profiles) matching search criteria.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActorsTypeahead: {
          lexicon: 1,
          id: "app.bsky.actor.searchActorsTypeahead",
          defs: {
            main: {
              type: "query",
              description: "Find actor suggestions for a prefix search term.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query prefix; not a full query string."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 10
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyEmbedExternal: {
          lexicon: 1,
          id: "app.bsky.embed.external",
          description: "A representation of some externally linked content, embedded in another form of content.",
          defs: {
            main: {
              type: "object",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#external"
                }
              }
            },
            external: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                }
              }
            },
            view: {
              type: "object",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#viewExternal"
                }
              }
            },
            viewExternal: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyEmbedImages: {
          lexicon: 1,
          id: "app.bsky.embed.images",
          description: "A set of images embedded in some other form of content.",
          defs: {
            main: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#image"
                  },
                  maxLength: 4
                }
              }
            },
            image: {
              type: "object",
              required: ["image", "alt"],
              properties: {
                image: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                },
                alt: {
                  type: "string"
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#aspectRatio"
                }
              }
            },
            aspectRatio: {
              type: "object",
              description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer",
                  minimum: 1
                },
                height: {
                  type: "integer",
                  minimum: 1
                }
              }
            },
            view: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#viewImage"
                  },
                  maxLength: 4
                }
              }
            },
            viewImage: {
              type: "object",
              required: ["thumb", "fullsize", "alt"],
              properties: {
                thumb: {
                  type: "string"
                },
                fullsize: {
                  type: "string"
                },
                alt: {
                  type: "string"
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#aspectRatio"
                }
              }
            }
          }
        },
        AppBskyEmbedRecord: {
          lexicon: 1,
          id: "app.bsky.embed.record",
          description: "A representation of a record embedded in another form of content.",
          defs: {
            main: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            view: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.record#viewRecord",
                    "lex:app.bsky.embed.record#viewNotFound",
                    "lex:app.bsky.embed.record#viewBlocked",
                    "lex:app.bsky.feed.defs#generatorView",
                    "lex:app.bsky.graph.defs#listView"
                  ]
                }
              }
            },
            viewRecord: {
              type: "object",
              required: ["uri", "cid", "author", "value", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                value: {
                  type: "unknown"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                embeds: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images#view",
                      "lex:app.bsky.embed.external#view",
                      "lex:app.bsky.embed.record#view",
                      "lex:app.bsky.embed.recordWithMedia#view"
                    ]
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            viewNotFound: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            viewBlocked: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            }
          }
        },
        AppBskyEmbedRecordWithMedia: {
          lexicon: 1,
          id: "app.bsky.embed.recordWithMedia",
          description: "A representation of a record embedded in another form of content, alongside other compatible embeds.",
          defs: {
            main: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record"
                },
                media: {
                  type: "union",
                  refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
                }
              }
            },
            view: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record#view"
                },
                media: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.external#view"
                  ]
                }
              }
            }
          }
        },
        AppBskyFeedDefs: {
          lexicon: 1,
          id: "app.bsky.feed.defs",
          defs: {
            postView: {
              type: "object",
              required: ["uri", "cid", "author", "record", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                record: {
                  type: "unknown"
                },
                embed: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.external#view",
                    "lex:app.bsky.embed.record#view",
                    "lex:app.bsky.embed.recordWithMedia#view"
                  ]
                },
                replyCount: {
                  type: "integer"
                },
                repostCount: {
                  type: "integer"
                },
                likeCount: {
                  type: "integer"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                threadgate: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#threadgateView"
                }
              }
            },
            viewerState: {
              type: "object",
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                },
                like: {
                  type: "string",
                  format: "at-uri"
                },
                replyDisabled: {
                  type: "boolean"
                }
              }
            },
            feedViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                reply: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#replyRef"
                },
                reason: {
                  type: "union",
                  refs: ["lex:app.bsky.feed.defs#reasonRepost"]
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            },
            reasonRepost: {
              type: "object",
              required: ["by", "indexedAt"],
              properties: {
                by: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            threadViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                replies: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.defs#threadViewPost",
                      "lex:app.bsky.feed.defs#notFoundPost",
                      "lex:app.bsky.feed.defs#blockedPost"
                    ]
                  }
                }
              }
            },
            notFoundPost: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            blockedPost: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            },
            blockedAuthor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                }
              }
            },
            generatorView: {
              type: "object",
              required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                displayName: {
                  type: "string"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            generatorViewerState: {
              type: "object",
              properties: {
                like: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonFeedPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "string",
                  format: "at-uri"
                },
                reason: {
                  type: "union",
                  refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
                }
              }
            },
            skeletonReasonRepost: {
              type: "object",
              required: ["repost"],
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            threadgateView: {
              type: "object",
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listViewBasic"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedDescribeFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.describeFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator, including policies and offered feed URIs.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "feeds"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                      }
                    },
                    links: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                    }
                  }
                }
              }
            },
            feed: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string"
                },
                termsOfService: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.generator",
          defs: {
            main: {
              type: "record",
              description: "A declaration of the existence of a feed generator.",
              key: "any",
              record: {
                type: "object",
                required: ["did", "displayName", "createdAt"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  displayName: {
                    type: "string",
                    maxGraphemes: 24,
                    maxLength: 240
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getActorFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of feeds created by the actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getActorLikes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of posts liked by an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetAuthorFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getAuthorFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a view of an actor's feed.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  filter: {
                    type: "string",
                    knownValues: [
                      "posts_with_replies",
                      "posts_no_replies",
                      "posts_with_media",
                      "posts_and_author_threads"
                    ],
                    default: "posts_with_replies"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a hydrated feed from an actor's selected feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["view", "isOnline", "isValid"],
                  properties: {
                    view: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    },
                    isOnline: {
                      type: "boolean"
                    },
                    isValid: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "Get information about a list of feed generators.",
              parameters: {
                type: "params",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedSkeleton: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Get a skeleton of a feed provided by a feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getLikes",
          defs: {
            main: {
              type: "query",
              description: "Get the list of likes.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "likes"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    likes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.getLikes#like"
                      }
                    }
                  }
                }
              }
            },
            like: {
              type: "object",
              required: ["indexedAt", "createdAt", "actor"],
              properties: {
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                actor: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            }
          }
        },
        AppBskyFeedGetListFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getListFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a view of a recent posts from actors in a list.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownList"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPostThread: {
          lexicon: 1,
          id: "app.bsky.feed.getPostThread",
          defs: {
            main: {
              type: "query",
              description: "Get posts in a thread.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  depth: {
                    type: "integer",
                    default: 6,
                    minimum: 0,
                    maximum: 1e3
                  },
                  parentHeight: {
                    type: "integer",
                    default: 80,
                    minimum: 0,
                    maximum: 1e3
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["thread"],
                  properties: {
                    thread: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.defs#threadViewPost",
                        "lex:app.bsky.feed.defs#notFoundPost",
                        "lex:app.bsky.feed.defs#blockedPost"
                      ]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "NotFound"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPosts: {
          lexicon: 1,
          id: "app.bsky.feed.getPosts",
          defs: {
            main: {
              type: "query",
              description: "Get a view of an actor's feed.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetRepostedBy: {
          lexicon: 1,
          id: "app.bsky.feed.getRepostedBy",
          defs: {
            main: {
              type: "query",
              description: "Get a list of reposts.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "repostedBy"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    repostedBy: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetSuggestedFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getSuggestedFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested feeds for the viewer.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetTimeline: {
          lexicon: 1,
          id: "app.bsky.feed.getTimeline",
          defs: {
            main: {
              type: "query",
              description: "Get a view of the actor's home timeline.",
              parameters: {
                type: "params",
                properties: {
                  algorithm: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedLike: {
          lexicon: 1,
          id: "app.bsky.feed.like",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a like.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedPost: {
          lexicon: 1,
          id: "app.bsky.feed.post",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a post.",
              key: "tid",
              record: {
                type: "object",
                required: ["text", "createdAt"],
                properties: {
                  text: {
                    type: "string",
                    maxLength: 3e3,
                    maxGraphemes: 300
                  },
                  entities: {
                    type: "array",
                    description: "Deprecated: replaced by app.bsky.richtext.facet.",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.post#entity"
                    }
                  },
                  facets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  reply: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.post#replyRef"
                  },
                  embed: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images",
                      "lex:app.bsky.embed.external",
                      "lex:app.bsky.embed.record",
                      "lex:app.bsky.embed.recordWithMedia"
                    ]
                  },
                  langs: {
                    type: "array",
                    maxLength: 3,
                    items: {
                      type: "string",
                      format: "language"
                    }
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  tags: {
                    type: "array",
                    maxLength: 8,
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    },
                    description: "Additional non-inline tags describing this post."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                parent: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            entity: {
              type: "object",
              description: "Deprecated: use facets instead.",
              required: ["index", "type", "value"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#textSlice"
                },
                type: {
                  type: "string",
                  description: "Expected values are 'mention' and 'link'."
                },
                value: {
                  type: "string"
                }
              }
            },
            textSlice: {
              type: "object",
              description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
              required: ["start", "end"],
              properties: {
                start: {
                  type: "integer",
                  minimum: 0
                },
                end: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyFeedRepost: {
          lexicon: 1,
          id: "app.bsky.feed.repost",
          defs: {
            main: {
              description: "A declaration of a repost.",
              type: "record",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedSearchPosts: {
          lexicon: 1,
          id: "app.bsky.feed.searchPosts",
          defs: {
            main: {
              type: "query",
              description: "Find posts matching search criteria.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyFeedThreadgate: {
          lexicon: 1,
          id: "app.bsky.feed.threadgate",
          defs: {
            main: {
              type: "record",
              key: "tid",
              description: "Defines interaction gating rules for a thread. The rkey of the threadgate record should match the rkey of the thread's root post.",
              record: {
                type: "object",
                required: ["post", "createdAt"],
                properties: {
                  post: {
                    type: "string",
                    format: "at-uri"
                  },
                  allow: {
                    type: "array",
                    maxLength: 5,
                    items: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.threadgate#mentionRule",
                        "lex:app.bsky.feed.threadgate#followingRule",
                        "lex:app.bsky.feed.threadgate#listRule"
                      ]
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            },
            mentionRule: {
              type: "object",
              description: "Allow replies from actors mentioned in your post.",
              properties: {}
            },
            followingRule: {
              type: "object",
              description: "Allow replies from actors you follow.",
              properties: {}
            },
            listRule: {
              type: "object",
              description: "Allow replies from actors on a list.",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphBlock: {
          lexicon: 1,
          id: "app.bsky.graph.block",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a block.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphDefs: {
          lexicon: 1,
          id: "app.bsky.graph.defs",
          defs: {
            listViewBasic: {
              type: "object",
              required: ["uri", "cid", "name", "purpose"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listView: {
              type: "object",
              required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listItemView: {
              type: "object",
              required: ["uri", "subject"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            },
            listPurpose: {
              type: "string",
              knownValues: [
                "app.bsky.graph.defs#modlist",
                "app.bsky.graph.defs#curatelist"
              ]
            },
            modlist: {
              type: "token",
              description: "A list of actors to apply an aggregate moderation action (mute/block) on."
            },
            curatelist: {
              type: "token",
              description: "A list of actors used for curation purposes such as list feeds or interaction gating."
            },
            listViewerState: {
              type: "object",
              properties: {
                muted: {
                  type: "boolean"
                },
                blocked: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphFollow: {
          lexicon: 1,
          id: "app.bsky.graph.follow",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a social follow.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor is blocking.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blocks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    blocks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollowers: {
          lexicon: 1,
          id: "app.bsky.graph.getFollowers",
          defs: {
            main: {
              type: "query",
              description: "Get a list of an actor's followers.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "followers"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    followers: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollows: {
          lexicon: 1,
          id: "app.bsky.graph.getFollows",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor follows.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "follows"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    follows: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetList: {
          lexicon: 1,
          id: "app.bsky.graph.getList",
          defs: {
            main: {
              type: "query",
              description: "Get a list of actors.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list", "items"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    list: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    },
                    items: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listItemView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getListBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get lists that the actor is blocking.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getListMutes",
          defs: {
            main: {
              type: "query",
              description: "Get lists that the actor is muting.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetLists: {
          lexicon: 1,
          id: "app.bsky.graph.getLists",
          defs: {
            main: {
              type: "query",
              description: "Get a list of lists that belong to an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getMutes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor mutes.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["mutes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    mutes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetSuggestedFollowsByActor: {
          lexicon: 1,
          id: "app.bsky.graph.getSuggestedFollowsByActor",
          defs: {
            main: {
              type: "query",
              description: "Get suggested follows related to a given actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["suggestions"],
                  properties: {
                    suggestions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphList: {
          lexicon: 1,
          id: "app.bsky.graph.list",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["name", "purpose", "createdAt"],
                properties: {
                  purpose: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listPurpose"
                  },
                  name: {
                    type: "string",
                    maxLength: 64,
                    minLength: 1
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListblock: {
          lexicon: 1,
          id: "app.bsky.graph.listblock",
          defs: {
            main: {
              type: "record",
              description: "A block of an entire list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "at-uri"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListitem: {
          lexicon: 1,
          id: "app.bsky.graph.listitem",
          defs: {
            main: {
              type: "record",
              description: "An item under a declared list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "list", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.muteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Mute an actor by DID or handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.muteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Mute a list of actors.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Unmute an actor by DID or handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Unmute a list of actors.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationGetUnreadCount: {
          lexicon: 1,
          id: "app.bsky.notification.getUnreadCount",
          defs: {
            main: {
              type: "query",
              description: "Get the count of unread notifications.",
              parameters: {
                type: "params",
                properties: {
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["count"],
                  properties: {
                    count: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationListNotifications: {
          lexicon: 1,
          id: "app.bsky.notification.listNotifications",
          defs: {
            main: {
              type: "query",
              description: "Get a list of notifications.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["notifications"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    notifications: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.notification.listNotifications#notification"
                      }
                    },
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            },
            notification: {
              type: "object",
              required: [
                "uri",
                "cid",
                "author",
                "reason",
                "record",
                "isRead",
                "indexedAt"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                reason: {
                  type: "string",
                  description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.",
                  knownValues: [
                    "like",
                    "repost",
                    "follow",
                    "mention",
                    "reply",
                    "quote"
                  ]
                },
                reasonSubject: {
                  type: "string",
                  format: "at-uri"
                },
                record: {
                  type: "unknown"
                },
                isRead: {
                  type: "boolean"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationRegisterPush: {
          lexicon: 1,
          id: "app.bsky.notification.registerPush",
          defs: {
            main: {
              type: "procedure",
              description: "Register for push notifications with a service.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["serviceDid", "token", "platform", "appId"],
                  properties: {
                    serviceDid: {
                      type: "string",
                      format: "did"
                    },
                    token: {
                      type: "string"
                    },
                    platform: {
                      type: "string",
                      knownValues: ["ios", "android", "web"]
                    },
                    appId: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationUpdateSeen: {
          lexicon: 1,
          id: "app.bsky.notification.updateSeen",
          defs: {
            main: {
              type: "procedure",
              description: "Notify server that the user has seen notifications.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["seenAt"],
                  properties: {
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyRichtextFacet: {
          lexicon: 1,
          id: "app.bsky.richtext.facet",
          defs: {
            main: {
              type: "object",
              required: ["index", "features"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet#byteSlice"
                },
                features: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.richtext.facet#mention",
                      "lex:app.bsky.richtext.facet#link",
                      "lex:app.bsky.richtext.facet#tag"
                    ]
                  }
                }
              }
            },
            mention: {
              type: "object",
              description: "A facet feature for actor mentions.",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            link: {
              type: "object",
              description: "A facet feature for links.",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            tag: {
              type: "object",
              description: "A hashtag.",
              required: ["tag"],
              properties: {
                tag: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              }
            },
            byteSlice: {
              type: "object",
              description: "A text segment. Start is inclusive, end is exclusive. Indices are for utf8-encoded strings.",
              required: ["byteStart", "byteEnd"],
              properties: {
                byteStart: {
                  type: "integer",
                  minimum: 0
                },
                byteEnd: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyUnspeccedDefs: {
          lexicon: 1,
          id: "app.bsky.unspecced.defs",
          defs: {
            skeletonSearchPost: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonSearchActor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetPopular: {
          lexicon: 1,
          id: "app.bsky.unspecced.getPopular",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED: will be removed soon. Use a feed generator alternative.",
              parameters: {
                type: "params",
                properties: {
                  includeNsfw: {
                    type: "boolean",
                    default: false
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetPopularFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.unspecced.getPopularFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "An unspecced view of globally popular feed generators.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  query: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetTimelineSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.getTimelineSkeleton",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED: a skeleton of a timeline. Unspecced and will be unavailable soon.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchActorsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchActorsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Actors (profile) search, returns only skeleton.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
                  },
                  typeahead: {
                    type: "boolean",
                    description: "If true, acts as fast/simple 'typeahead' query."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchPostsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchPostsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Posts search, returns only skeleton",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        }
      };
      var schemas = Object.values(schemaDict);
      var lexicons = new Lexicons(schemas);
      var deleteAccount_exports = {};
      __export(deleteAccount_exports, {
        toKnownErr: () => toKnownErr
      });
      function toKnownErr(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var disableAccountInvites_exports = {};
      __export(disableAccountInvites_exports, {
        toKnownErr: () => toKnownErr2
      });
      function toKnownErr2(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var disableInviteCodes_exports = {};
      __export(disableInviteCodes_exports, {
        toKnownErr: () => toKnownErr3
      });
      function toKnownErr3(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var emitModerationEvent_exports = {};
      __export(emitModerationEvent_exports, {
        SubjectHasActionError: () => SubjectHasActionError,
        toKnownErr: () => toKnownErr4
      });
      var SubjectHasActionError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr4(e) {
        if (e instanceof XRPCError) {
          if (e.error === "SubjectHasAction")
            return new SubjectHasActionError(e);
        }
        return e;
      }
      var enableAccountInvites_exports = {};
      __export(enableAccountInvites_exports, {
        toKnownErr: () => toKnownErr5
      });
      function toKnownErr5(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getAccountInfo_exports = {};
      __export(getAccountInfo_exports, {
        toKnownErr: () => toKnownErr6
      });
      function toKnownErr6(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getInviteCodes_exports = {};
      __export(getInviteCodes_exports, {
        toKnownErr: () => toKnownErr7
      });
      function toKnownErr7(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getModerationEvent_exports = {};
      __export(getModerationEvent_exports, {
        toKnownErr: () => toKnownErr8
      });
      function toKnownErr8(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRecord_exports = {};
      __export(getRecord_exports, {
        RecordNotFoundError: () => RecordNotFoundError,
        toKnownErr: () => toKnownErr9
      });
      var RecordNotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr9(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RecordNotFound")
            return new RecordNotFoundError(e);
        }
        return e;
      }
      var getRepo_exports = {};
      __export(getRepo_exports, {
        RepoNotFoundError: () => RepoNotFoundError,
        toKnownErr: () => toKnownErr10
      });
      var RepoNotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr10(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RepoNotFound")
            return new RepoNotFoundError(e);
        }
        return e;
      }
      var getSubjectStatus_exports = {};
      __export(getSubjectStatus_exports, {
        toKnownErr: () => toKnownErr11
      });
      function toKnownErr11(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryModerationEvents_exports = {};
      __export(queryModerationEvents_exports, {
        toKnownErr: () => toKnownErr12
      });
      function toKnownErr12(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryModerationStatuses_exports = {};
      __export(queryModerationStatuses_exports, {
        toKnownErr: () => toKnownErr13
      });
      function toKnownErr13(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchRepos_exports = {};
      __export(searchRepos_exports, {
        toKnownErr: () => toKnownErr14
      });
      function toKnownErr14(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var sendEmail_exports = {};
      __export(sendEmail_exports, {
        toKnownErr: () => toKnownErr15
      });
      function toKnownErr15(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateAccountEmail_exports = {};
      __export(updateAccountEmail_exports, {
        toKnownErr: () => toKnownErr16
      });
      function toKnownErr16(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateAccountHandle_exports = {};
      __export(updateAccountHandle_exports, {
        toKnownErr: () => toKnownErr17
      });
      function toKnownErr17(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateSubjectStatus_exports = {};
      __export(updateSubjectStatus_exports, {
        toKnownErr: () => toKnownErr18
      });
      function toKnownErr18(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var resolveHandle_exports = {};
      __export(resolveHandle_exports, {
        toKnownErr: () => toKnownErr19
      });
      function toKnownErr19(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateHandle_exports = {};
      __export(updateHandle_exports, {
        toKnownErr: () => toKnownErr20
      });
      function toKnownErr20(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryLabels_exports = {};
      __export(queryLabels_exports, {
        toKnownErr: () => toKnownErr21
      });
      function toKnownErr21(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var createReport_exports = {};
      __export(createReport_exports, {
        toKnownErr: () => toKnownErr22
      });
      function toKnownErr22(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var applyWrites_exports = {};
      __export(applyWrites_exports, {
        InvalidSwapError: () => InvalidSwapError,
        isCreate: () => isCreate,
        isDelete: () => isDelete,
        isUpdate: () => isUpdate,
        toKnownErr: () => toKnownErr23,
        validateCreate: () => validateCreate,
        validateDelete: () => validateDelete,
        validateUpdate: () => validateUpdate
      });
      function isObj2(v) {
        return typeof v === "object" && v !== null;
      }
      function hasProp2(data, prop) {
        return prop in data;
      }
      var InvalidSwapError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr23(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError(e);
        }
        return e;
      }
      function isCreate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#create";
      }
      function validateCreate(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#create", v);
      }
      function isUpdate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#update";
      }
      function validateUpdate(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#update", v);
      }
      function isDelete(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#delete";
      }
      function validateDelete(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#delete", v);
      }
      var createRecord_exports = {};
      __export(createRecord_exports, {
        InvalidSwapError: () => InvalidSwapError2,
        toKnownErr: () => toKnownErr24
      });
      var InvalidSwapError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr24(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError2(e);
        }
        return e;
      }
      var deleteRecord_exports = {};
      __export(deleteRecord_exports, {
        InvalidSwapError: () => InvalidSwapError3,
        toKnownErr: () => toKnownErr25
      });
      var InvalidSwapError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr25(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError3(e);
        }
        return e;
      }
      var describeRepo_exports = {};
      __export(describeRepo_exports, {
        toKnownErr: () => toKnownErr26
      });
      function toKnownErr26(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRecord_exports2 = {};
      __export(getRecord_exports2, {
        toKnownErr: () => toKnownErr27
      });
      function toKnownErr27(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listRecords_exports = {};
      __export(listRecords_exports, {
        isRecord: () => isRecord,
        toKnownErr: () => toKnownErr28,
        validateRecord: () => validateRecord
      });
      function toKnownErr28(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isRecord(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.listRecords#record";
      }
      function validateRecord(v) {
        return lexicons.validate("com.atproto.repo.listRecords#record", v);
      }
      var putRecord_exports = {};
      __export(putRecord_exports, {
        InvalidSwapError: () => InvalidSwapError4,
        toKnownErr: () => toKnownErr29
      });
      var InvalidSwapError4 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr29(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError4(e);
        }
        return e;
      }
      var uploadBlob_exports = {};
      __export(uploadBlob_exports, {
        toKnownErr: () => toKnownErr30
      });
      function toKnownErr30(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var confirmEmail_exports = {};
      __export(confirmEmail_exports, {
        AccountNotFoundError: () => AccountNotFoundError,
        ExpiredTokenError: () => ExpiredTokenError,
        InvalidEmailError: () => InvalidEmailError,
        InvalidTokenError: () => InvalidTokenError,
        toKnownErr: () => toKnownErr31
      });
      var AccountNotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var ExpiredTokenError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidTokenError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidEmailError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr31(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountNotFound")
            return new AccountNotFoundError(e);
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError(e);
          if (e.error === "InvalidEmail")
            return new InvalidEmailError(e);
        }
        return e;
      }
      var createAccount_exports = {};
      __export(createAccount_exports, {
        HandleNotAvailableError: () => HandleNotAvailableError,
        IncompatibleDidDocError: () => IncompatibleDidDocError,
        InvalidHandleError: () => InvalidHandleError2,
        InvalidInviteCodeError: () => InvalidInviteCodeError,
        InvalidPasswordError: () => InvalidPasswordError,
        UnresolvableDidError: () => UnresolvableDidError,
        UnsupportedDomainError: () => UnsupportedDomainError,
        toKnownErr: () => toKnownErr32
      });
      var InvalidHandleError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidPasswordError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidInviteCodeError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var HandleNotAvailableError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var UnsupportedDomainError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var UnresolvableDidError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var IncompatibleDidDocError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr32(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidHandle")
            return new InvalidHandleError2(e);
          if (e.error === "InvalidPassword")
            return new InvalidPasswordError(e);
          if (e.error === "InvalidInviteCode")
            return new InvalidInviteCodeError(e);
          if (e.error === "HandleNotAvailable")
            return new HandleNotAvailableError(e);
          if (e.error === "UnsupportedDomain")
            return new UnsupportedDomainError(e);
          if (e.error === "UnresolvableDid")
            return new UnresolvableDidError(e);
          if (e.error === "IncompatibleDidDoc")
            return new IncompatibleDidDocError(e);
        }
        return e;
      }
      var createAppPassword_exports = {};
      __export(createAppPassword_exports, {
        AccountTakedownError: () => AccountTakedownError,
        isAppPassword: () => isAppPassword,
        toKnownErr: () => toKnownErr33,
        validateAppPassword: () => validateAppPassword
      });
      var AccountTakedownError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr33(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError(e);
        }
        return e;
      }
      function isAppPassword(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.createAppPassword#appPassword";
      }
      function validateAppPassword(v) {
        return lexicons.validate("com.atproto.server.createAppPassword#appPassword", v);
      }
      var createInviteCode_exports = {};
      __export(createInviteCode_exports, {
        toKnownErr: () => toKnownErr34
      });
      function toKnownErr34(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var createInviteCodes_exports = {};
      __export(createInviteCodes_exports, {
        isAccountCodes: () => isAccountCodes,
        toKnownErr: () => toKnownErr35,
        validateAccountCodes: () => validateAccountCodes
      });
      function toKnownErr35(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isAccountCodes(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.createInviteCodes#accountCodes";
      }
      function validateAccountCodes(v) {
        return lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", v);
      }
      var createSession_exports = {};
      __export(createSession_exports, {
        AccountTakedownError: () => AccountTakedownError2,
        toKnownErr: () => toKnownErr36
      });
      var AccountTakedownError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr36(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError2(e);
        }
        return e;
      }
      var deleteAccount_exports2 = {};
      __export(deleteAccount_exports2, {
        ExpiredTokenError: () => ExpiredTokenError2,
        InvalidTokenError: () => InvalidTokenError2,
        toKnownErr: () => toKnownErr37
      });
      var ExpiredTokenError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidTokenError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr37(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError2(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError2(e);
        }
        return e;
      }
      var deleteSession_exports = {};
      __export(deleteSession_exports, {
        toKnownErr: () => toKnownErr38
      });
      function toKnownErr38(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var describeServer_exports = {};
      __export(describeServer_exports, {
        isLinks: () => isLinks,
        toKnownErr: () => toKnownErr39,
        validateLinks: () => validateLinks
      });
      function toKnownErr39(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isLinks(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.describeServer#links";
      }
      function validateLinks(v) {
        return lexicons.validate("com.atproto.server.describeServer#links", v);
      }
      var getAccountInviteCodes_exports = {};
      __export(getAccountInviteCodes_exports, {
        DuplicateCreateError: () => DuplicateCreateError,
        toKnownErr: () => toKnownErr40
      });
      var DuplicateCreateError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr40(e) {
        if (e instanceof XRPCError) {
          if (e.error === "DuplicateCreate")
            return new DuplicateCreateError(e);
        }
        return e;
      }
      var getSession_exports = {};
      __export(getSession_exports, {
        toKnownErr: () => toKnownErr41
      });
      function toKnownErr41(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listAppPasswords_exports = {};
      __export(listAppPasswords_exports, {
        AccountTakedownError: () => AccountTakedownError3,
        isAppPassword: () => isAppPassword2,
        toKnownErr: () => toKnownErr42,
        validateAppPassword: () => validateAppPassword2
      });
      var AccountTakedownError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr42(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError3(e);
        }
        return e;
      }
      function isAppPassword2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.listAppPasswords#appPassword";
      }
      function validateAppPassword2(v) {
        return lexicons.validate("com.atproto.server.listAppPasswords#appPassword", v);
      }
      var refreshSession_exports = {};
      __export(refreshSession_exports, {
        AccountTakedownError: () => AccountTakedownError4,
        toKnownErr: () => toKnownErr43
      });
      var AccountTakedownError4 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr43(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError4(e);
        }
        return e;
      }
      var requestAccountDelete_exports = {};
      __export(requestAccountDelete_exports, {
        toKnownErr: () => toKnownErr44
      });
      function toKnownErr44(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestEmailConfirmation_exports = {};
      __export(requestEmailConfirmation_exports, {
        toKnownErr: () => toKnownErr45
      });
      function toKnownErr45(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestEmailUpdate_exports = {};
      __export(requestEmailUpdate_exports, {
        toKnownErr: () => toKnownErr46
      });
      function toKnownErr46(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestPasswordReset_exports = {};
      __export(requestPasswordReset_exports, {
        toKnownErr: () => toKnownErr47
      });
      function toKnownErr47(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var reserveSigningKey_exports = {};
      __export(reserveSigningKey_exports, {
        toKnownErr: () => toKnownErr48
      });
      function toKnownErr48(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var resetPassword_exports = {};
      __export(resetPassword_exports, {
        ExpiredTokenError: () => ExpiredTokenError3,
        InvalidTokenError: () => InvalidTokenError3,
        toKnownErr: () => toKnownErr49
      });
      var ExpiredTokenError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidTokenError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr49(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError3(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError3(e);
        }
        return e;
      }
      var revokeAppPassword_exports = {};
      __export(revokeAppPassword_exports, {
        toKnownErr: () => toKnownErr50
      });
      function toKnownErr50(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateEmail_exports = {};
      __export(updateEmail_exports, {
        ExpiredTokenError: () => ExpiredTokenError4,
        InvalidTokenError: () => InvalidTokenError4,
        TokenRequiredError: () => TokenRequiredError,
        toKnownErr: () => toKnownErr51
      });
      var ExpiredTokenError4 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidTokenError4 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var TokenRequiredError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr51(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError4(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError4(e);
          if (e.error === "TokenRequired")
            return new TokenRequiredError(e);
        }
        return e;
      }
      var getBlob_exports = {};
      __export(getBlob_exports, {
        toKnownErr: () => toKnownErr52
      });
      function toKnownErr52(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getBlocks_exports = {};
      __export(getBlocks_exports, {
        toKnownErr: () => toKnownErr53
      });
      function toKnownErr53(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getCheckout_exports = {};
      __export(getCheckout_exports, {
        toKnownErr: () => toKnownErr54
      });
      function toKnownErr54(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getHead_exports = {};
      __export(getHead_exports, {
        HeadNotFoundError: () => HeadNotFoundError,
        toKnownErr: () => toKnownErr55
      });
      var HeadNotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr55(e) {
        if (e instanceof XRPCError) {
          if (e.error === "HeadNotFound")
            return new HeadNotFoundError(e);
        }
        return e;
      }
      var getLatestCommit_exports = {};
      __export(getLatestCommit_exports, {
        RepoNotFoundError: () => RepoNotFoundError2,
        toKnownErr: () => toKnownErr56
      });
      var RepoNotFoundError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr56(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RepoNotFound")
            return new RepoNotFoundError2(e);
        }
        return e;
      }
      var getRecord_exports3 = {};
      __export(getRecord_exports3, {
        toKnownErr: () => toKnownErr57
      });
      function toKnownErr57(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRepo_exports2 = {};
      __export(getRepo_exports2, {
        toKnownErr: () => toKnownErr58
      });
      function toKnownErr58(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listBlobs_exports = {};
      __export(listBlobs_exports, {
        toKnownErr: () => toKnownErr59
      });
      function toKnownErr59(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listRepos_exports = {};
      __export(listRepos_exports, {
        isRepo: () => isRepo,
        toKnownErr: () => toKnownErr60,
        validateRepo: () => validateRepo
      });
      function toKnownErr60(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isRepo(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.listRepos#repo";
      }
      function validateRepo(v) {
        return lexicons.validate("com.atproto.sync.listRepos#repo", v);
      }
      var notifyOfUpdate_exports = {};
      __export(notifyOfUpdate_exports, {
        toKnownErr: () => toKnownErr61
      });
      function toKnownErr61(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestCrawl_exports = {};
      __export(requestCrawl_exports, {
        toKnownErr: () => toKnownErr62
      });
      function toKnownErr62(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var fetchLabels_exports = {};
      __export(fetchLabels_exports, {
        toKnownErr: () => toKnownErr63
      });
      function toKnownErr63(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var importRepo_exports = {};
      __export(importRepo_exports, {
        toKnownErr: () => toKnownErr64
      });
      function toKnownErr64(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var pushBlob_exports = {};
      __export(pushBlob_exports, {
        toKnownErr: () => toKnownErr65
      });
      function toKnownErr65(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var transferAccount_exports = {};
      __export(transferAccount_exports, {
        HandleNotAvailableError: () => HandleNotAvailableError2,
        IncompatibleDidDocError: () => IncompatibleDidDocError2,
        InvalidHandleError: () => InvalidHandleError3,
        InvalidInviteCodeError: () => InvalidInviteCodeError2,
        InvalidPasswordError: () => InvalidPasswordError2,
        UnresolvableDidError: () => UnresolvableDidError2,
        UnsupportedDomainError: () => UnsupportedDomainError2,
        toKnownErr: () => toKnownErr66
      });
      var InvalidHandleError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidPasswordError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidInviteCodeError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var HandleNotAvailableError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var UnsupportedDomainError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var UnresolvableDidError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var IncompatibleDidDocError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr66(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidHandle")
            return new InvalidHandleError3(e);
          if (e.error === "InvalidPassword")
            return new InvalidPasswordError2(e);
          if (e.error === "InvalidInviteCode")
            return new InvalidInviteCodeError2(e);
          if (e.error === "HandleNotAvailable")
            return new HandleNotAvailableError2(e);
          if (e.error === "UnsupportedDomain")
            return new UnsupportedDomainError2(e);
          if (e.error === "UnresolvableDid")
            return new UnresolvableDidError2(e);
          if (e.error === "IncompatibleDidDoc")
            return new IncompatibleDidDocError2(e);
        }
        return e;
      }
      var getPreferences_exports = {};
      __export(getPreferences_exports, {
        toKnownErr: () => toKnownErr67
      });
      function toKnownErr67(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getProfile_exports = {};
      __export(getProfile_exports, {
        toKnownErr: () => toKnownErr68
      });
      function toKnownErr68(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getProfiles_exports = {};
      __export(getProfiles_exports, {
        toKnownErr: () => toKnownErr69
      });
      function toKnownErr69(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestions_exports = {};
      __export(getSuggestions_exports, {
        toKnownErr: () => toKnownErr70
      });
      function toKnownErr70(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var putPreferences_exports = {};
      __export(putPreferences_exports, {
        toKnownErr: () => toKnownErr71
      });
      function toKnownErr71(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchActors_exports = {};
      __export(searchActors_exports, {
        toKnownErr: () => toKnownErr72
      });
      function toKnownErr72(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchActorsTypeahead_exports = {};
      __export(searchActorsTypeahead_exports, {
        toKnownErr: () => toKnownErr73
      });
      function toKnownErr73(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var describeFeedGenerator_exports = {};
      __export(describeFeedGenerator_exports, {
        isFeed: () => isFeed,
        isLinks: () => isLinks2,
        toKnownErr: () => toKnownErr74,
        validateFeed: () => validateFeed,
        validateLinks: () => validateLinks2
      });
      function toKnownErr74(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isFeed(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.describeFeedGenerator#feed";
      }
      function validateFeed(v) {
        return lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", v);
      }
      function isLinks2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.describeFeedGenerator#links";
      }
      function validateLinks2(v) {
        return lexicons.validate("app.bsky.feed.describeFeedGenerator#links", v);
      }
      var getActorFeeds_exports = {};
      __export(getActorFeeds_exports, {
        toKnownErr: () => toKnownErr75
      });
      function toKnownErr75(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getActorLikes_exports = {};
      __export(getActorLikes_exports, {
        BlockedActorError: () => BlockedActorError,
        BlockedByActorError: () => BlockedByActorError,
        toKnownErr: () => toKnownErr76
      });
      var BlockedActorError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var BlockedByActorError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr76(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BlockedActor")
            return new BlockedActorError(e);
          if (e.error === "BlockedByActor")
            return new BlockedByActorError(e);
        }
        return e;
      }
      var getAuthorFeed_exports = {};
      __export(getAuthorFeed_exports, {
        BlockedActorError: () => BlockedActorError2,
        BlockedByActorError: () => BlockedByActorError2,
        toKnownErr: () => toKnownErr77
      });
      var BlockedActorError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var BlockedByActorError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr77(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BlockedActor")
            return new BlockedActorError2(e);
          if (e.error === "BlockedByActor")
            return new BlockedByActorError2(e);
        }
        return e;
      }
      var getFeed_exports = {};
      __export(getFeed_exports, {
        UnknownFeedError: () => UnknownFeedError,
        toKnownErr: () => toKnownErr78
      });
      var UnknownFeedError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr78(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError(e);
        }
        return e;
      }
      var getFeedGenerator_exports = {};
      __export(getFeedGenerator_exports, {
        toKnownErr: () => toKnownErr79
      });
      function toKnownErr79(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFeedGenerators_exports = {};
      __export(getFeedGenerators_exports, {
        toKnownErr: () => toKnownErr80
      });
      function toKnownErr80(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFeedSkeleton_exports = {};
      __export(getFeedSkeleton_exports, {
        UnknownFeedError: () => UnknownFeedError2,
        toKnownErr: () => toKnownErr81
      });
      var UnknownFeedError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr81(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError2(e);
        }
        return e;
      }
      var getLikes_exports = {};
      __export(getLikes_exports, {
        isLike: () => isLike,
        toKnownErr: () => toKnownErr82,
        validateLike: () => validateLike
      });
      function toKnownErr82(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isLike(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.getLikes#like";
      }
      function validateLike(v) {
        return lexicons.validate("app.bsky.feed.getLikes#like", v);
      }
      var getListFeed_exports = {};
      __export(getListFeed_exports, {
        UnknownListError: () => UnknownListError,
        toKnownErr: () => toKnownErr83
      });
      var UnknownListError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr83(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownList")
            return new UnknownListError(e);
        }
        return e;
      }
      var getPostThread_exports = {};
      __export(getPostThread_exports, {
        NotFoundError: () => NotFoundError,
        toKnownErr: () => toKnownErr84
      });
      var NotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr84(e) {
        if (e instanceof XRPCError) {
          if (e.error === "NotFound")
            return new NotFoundError(e);
        }
        return e;
      }
      var getPosts_exports = {};
      __export(getPosts_exports, {
        toKnownErr: () => toKnownErr85
      });
      function toKnownErr85(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRepostedBy_exports = {};
      __export(getRepostedBy_exports, {
        toKnownErr: () => toKnownErr86
      });
      function toKnownErr86(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestedFeeds_exports = {};
      __export(getSuggestedFeeds_exports, {
        toKnownErr: () => toKnownErr87
      });
      function toKnownErr87(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getTimeline_exports = {};
      __export(getTimeline_exports, {
        toKnownErr: () => toKnownErr88
      });
      function toKnownErr88(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchPosts_exports = {};
      __export(searchPosts_exports, {
        BadQueryStringError: () => BadQueryStringError,
        toKnownErr: () => toKnownErr89
      });
      var BadQueryStringError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr89(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError(e);
        }
        return e;
      }
      var getBlocks_exports2 = {};
      __export(getBlocks_exports2, {
        toKnownErr: () => toKnownErr90
      });
      function toKnownErr90(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFollowers_exports = {};
      __export(getFollowers_exports, {
        toKnownErr: () => toKnownErr91
      });
      function toKnownErr91(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFollows_exports = {};
      __export(getFollows_exports, {
        toKnownErr: () => toKnownErr92
      });
      function toKnownErr92(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getList_exports = {};
      __export(getList_exports, {
        toKnownErr: () => toKnownErr93
      });
      function toKnownErr93(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getListBlocks_exports = {};
      __export(getListBlocks_exports, {
        toKnownErr: () => toKnownErr94
      });
      function toKnownErr94(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getListMutes_exports = {};
      __export(getListMutes_exports, {
        toKnownErr: () => toKnownErr95
      });
      function toKnownErr95(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getLists_exports = {};
      __export(getLists_exports, {
        toKnownErr: () => toKnownErr96
      });
      function toKnownErr96(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getMutes_exports = {};
      __export(getMutes_exports, {
        toKnownErr: () => toKnownErr97
      });
      function toKnownErr97(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestedFollowsByActor_exports = {};
      __export(getSuggestedFollowsByActor_exports, {
        toKnownErr: () => toKnownErr98
      });
      function toKnownErr98(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var muteActor_exports = {};
      __export(muteActor_exports, {
        toKnownErr: () => toKnownErr99
      });
      function toKnownErr99(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var muteActorList_exports = {};
      __export(muteActorList_exports, {
        toKnownErr: () => toKnownErr100
      });
      function toKnownErr100(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var unmuteActor_exports = {};
      __export(unmuteActor_exports, {
        toKnownErr: () => toKnownErr101
      });
      function toKnownErr101(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var unmuteActorList_exports = {};
      __export(unmuteActorList_exports, {
        toKnownErr: () => toKnownErr102
      });
      function toKnownErr102(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getUnreadCount_exports = {};
      __export(getUnreadCount_exports, {
        toKnownErr: () => toKnownErr103
      });
      function toKnownErr103(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listNotifications_exports = {};
      __export(listNotifications_exports, {
        isNotification: () => isNotification,
        toKnownErr: () => toKnownErr104,
        validateNotification: () => validateNotification
      });
      function toKnownErr104(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isNotification(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.notification.listNotifications#notification";
      }
      function validateNotification(v) {
        return lexicons.validate("app.bsky.notification.listNotifications#notification", v);
      }
      var registerPush_exports = {};
      __export(registerPush_exports, {
        toKnownErr: () => toKnownErr105
      });
      function toKnownErr105(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateSeen_exports = {};
      __export(updateSeen_exports, {
        toKnownErr: () => toKnownErr106
      });
      function toKnownErr106(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getPopular_exports = {};
      __export(getPopular_exports, {
        toKnownErr: () => toKnownErr107
      });
      function toKnownErr107(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getPopularFeedGenerators_exports = {};
      __export(getPopularFeedGenerators_exports, {
        toKnownErr: () => toKnownErr108
      });
      function toKnownErr108(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getTimelineSkeleton_exports = {};
      __export(getTimelineSkeleton_exports, {
        UnknownFeedError: () => UnknownFeedError3,
        toKnownErr: () => toKnownErr109
      });
      var UnknownFeedError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr109(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError3(e);
        }
        return e;
      }
      var searchActorsSkeleton_exports = {};
      __export(searchActorsSkeleton_exports, {
        BadQueryStringError: () => BadQueryStringError2,
        toKnownErr: () => toKnownErr110
      });
      var BadQueryStringError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr110(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError2(e);
        }
        return e;
      }
      var searchPostsSkeleton_exports = {};
      __export(searchPostsSkeleton_exports, {
        BadQueryStringError: () => BadQueryStringError3,
        toKnownErr: () => toKnownErr111
      });
      var BadQueryStringError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr111(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError3(e);
        }
        return e;
      }
      var defs_exports = {};
      __export(defs_exports, {
        REVIEWCLOSED: () => REVIEWCLOSED,
        REVIEWESCALATED: () => REVIEWESCALATED,
        REVIEWOPEN: () => REVIEWOPEN,
        isAccountView: () => isAccountView,
        isBlobView: () => isBlobView,
        isImageDetails: () => isImageDetails,
        isModEventAcknowledge: () => isModEventAcknowledge,
        isModEventComment: () => isModEventComment,
        isModEventEmail: () => isModEventEmail,
        isModEventEscalate: () => isModEventEscalate,
        isModEventLabel: () => isModEventLabel,
        isModEventMute: () => isModEventMute,
        isModEventReport: () => isModEventReport,
        isModEventResolveAppeal: () => isModEventResolveAppeal,
        isModEventReverseTakedown: () => isModEventReverseTakedown,
        isModEventTakedown: () => isModEventTakedown,
        isModEventUnmute: () => isModEventUnmute,
        isModEventView: () => isModEventView,
        isModEventViewDetail: () => isModEventViewDetail,
        isModeration: () => isModeration,
        isModerationDetail: () => isModerationDetail,
        isRecordView: () => isRecordView,
        isRecordViewDetail: () => isRecordViewDetail,
        isRecordViewNotFound: () => isRecordViewNotFound,
        isRepoBlobRef: () => isRepoBlobRef,
        isRepoRef: () => isRepoRef,
        isRepoView: () => isRepoView,
        isRepoViewDetail: () => isRepoViewDetail,
        isRepoViewNotFound: () => isRepoViewNotFound,
        isReportView: () => isReportView,
        isReportViewDetail: () => isReportViewDetail,
        isStatusAttr: () => isStatusAttr,
        isSubjectStatusView: () => isSubjectStatusView,
        isVideoDetails: () => isVideoDetails,
        validateAccountView: () => validateAccountView,
        validateBlobView: () => validateBlobView,
        validateImageDetails: () => validateImageDetails,
        validateModEventAcknowledge: () => validateModEventAcknowledge,
        validateModEventComment: () => validateModEventComment,
        validateModEventEmail: () => validateModEventEmail,
        validateModEventEscalate: () => validateModEventEscalate,
        validateModEventLabel: () => validateModEventLabel,
        validateModEventMute: () => validateModEventMute,
        validateModEventReport: () => validateModEventReport,
        validateModEventResolveAppeal: () => validateModEventResolveAppeal,
        validateModEventReverseTakedown: () => validateModEventReverseTakedown,
        validateModEventTakedown: () => validateModEventTakedown,
        validateModEventUnmute: () => validateModEventUnmute,
        validateModEventView: () => validateModEventView,
        validateModEventViewDetail: () => validateModEventViewDetail,
        validateModeration: () => validateModeration,
        validateModerationDetail: () => validateModerationDetail,
        validateRecordView: () => validateRecordView,
        validateRecordViewDetail: () => validateRecordViewDetail,
        validateRecordViewNotFound: () => validateRecordViewNotFound,
        validateRepoBlobRef: () => validateRepoBlobRef,
        validateRepoRef: () => validateRepoRef,
        validateRepoView: () => validateRepoView,
        validateRepoViewDetail: () => validateRepoViewDetail,
        validateRepoViewNotFound: () => validateRepoViewNotFound,
        validateReportView: () => validateReportView,
        validateReportViewDetail: () => validateReportViewDetail,
        validateStatusAttr: () => validateStatusAttr,
        validateSubjectStatusView: () => validateSubjectStatusView,
        validateVideoDetails: () => validateVideoDetails
      });
      function isStatusAttr(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#statusAttr";
      }
      function validateStatusAttr(v) {
        return lexicons.validate("com.atproto.admin.defs#statusAttr", v);
      }
      function isModEventView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventView";
      }
      function validateModEventView(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventView", v);
      }
      function isModEventViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventViewDetail";
      }
      function validateModEventViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventViewDetail", v);
      }
      function isReportView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#reportView";
      }
      function validateReportView(v) {
        return lexicons.validate("com.atproto.admin.defs#reportView", v);
      }
      function isSubjectStatusView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#subjectStatusView";
      }
      function validateSubjectStatusView(v) {
        return lexicons.validate("com.atproto.admin.defs#subjectStatusView", v);
      }
      function isReportViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#reportViewDetail";
      }
      function validateReportViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#reportViewDetail", v);
      }
      function isRepoView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoView";
      }
      function validateRepoView(v) {
        return lexicons.validate("com.atproto.admin.defs#repoView", v);
      }
      function isRepoViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoViewDetail";
      }
      function validateRepoViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#repoViewDetail", v);
      }
      function isAccountView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#accountView";
      }
      function validateAccountView(v) {
        return lexicons.validate("com.atproto.admin.defs#accountView", v);
      }
      function isRepoViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoViewNotFound";
      }
      function validateRepoViewNotFound(v) {
        return lexicons.validate("com.atproto.admin.defs#repoViewNotFound", v);
      }
      function isRepoRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoRef";
      }
      function validateRepoRef(v) {
        return lexicons.validate("com.atproto.admin.defs#repoRef", v);
      }
      function isRepoBlobRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoBlobRef";
      }
      function validateRepoBlobRef(v) {
        return lexicons.validate("com.atproto.admin.defs#repoBlobRef", v);
      }
      function isRecordView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordView";
      }
      function validateRecordView(v) {
        return lexicons.validate("com.atproto.admin.defs#recordView", v);
      }
      function isRecordViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordViewDetail";
      }
      function validateRecordViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#recordViewDetail", v);
      }
      function isRecordViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordViewNotFound";
      }
      function validateRecordViewNotFound(v) {
        return lexicons.validate("com.atproto.admin.defs#recordViewNotFound", v);
      }
      function isModeration(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#moderation";
      }
      function validateModeration(v) {
        return lexicons.validate("com.atproto.admin.defs#moderation", v);
      }
      function isModerationDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#moderationDetail";
      }
      function validateModerationDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#moderationDetail", v);
      }
      function isBlobView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#blobView";
      }
      function validateBlobView(v) {
        return lexicons.validate("com.atproto.admin.defs#blobView", v);
      }
      function isImageDetails(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#imageDetails";
      }
      function validateImageDetails(v) {
        return lexicons.validate("com.atproto.admin.defs#imageDetails", v);
      }
      function isVideoDetails(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#videoDetails";
      }
      function validateVideoDetails(v) {
        return lexicons.validate("com.atproto.admin.defs#videoDetails", v);
      }
      var REVIEWOPEN = "com.atproto.admin.defs#reviewOpen";
      var REVIEWESCALATED = "com.atproto.admin.defs#reviewEscalated";
      var REVIEWCLOSED = "com.atproto.admin.defs#reviewClosed";
      function isModEventTakedown(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventTakedown";
      }
      function validateModEventTakedown(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventTakedown", v);
      }
      function isModEventReverseTakedown(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventReverseTakedown";
      }
      function validateModEventReverseTakedown(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventReverseTakedown", v);
      }
      function isModEventResolveAppeal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventResolveAppeal";
      }
      function validateModEventResolveAppeal(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventResolveAppeal", v);
      }
      function isModEventComment(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventComment";
      }
      function validateModEventComment(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventComment", v);
      }
      function isModEventReport(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventReport";
      }
      function validateModEventReport(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventReport", v);
      }
      function isModEventLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventLabel";
      }
      function validateModEventLabel(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventLabel", v);
      }
      function isModEventAcknowledge(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventAcknowledge";
      }
      function validateModEventAcknowledge(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventAcknowledge", v);
      }
      function isModEventEscalate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventEscalate";
      }
      function validateModEventEscalate(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventEscalate", v);
      }
      function isModEventMute(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventMute";
      }
      function validateModEventMute(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventMute", v);
      }
      function isModEventUnmute(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventUnmute";
      }
      function validateModEventUnmute(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventUnmute", v);
      }
      function isModEventEmail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventEmail";
      }
      function validateModEventEmail(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventEmail", v);
      }
      var defs_exports2 = {};
      __export(defs_exports2, {
        isLabel: () => isLabel,
        isSelfLabel: () => isSelfLabel,
        isSelfLabels: () => isSelfLabels,
        validateLabel: () => validateLabel,
        validateSelfLabel: () => validateSelfLabel,
        validateSelfLabels: () => validateSelfLabels
      });
      function isLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#label";
      }
      function validateLabel(v) {
        return lexicons.validate("com.atproto.label.defs#label", v);
      }
      function isSelfLabels(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#selfLabels";
      }
      function validateSelfLabels(v) {
        return lexicons.validate("com.atproto.label.defs#selfLabels", v);
      }
      function isSelfLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#selfLabel";
      }
      function validateSelfLabel(v) {
        return lexicons.validate("com.atproto.label.defs#selfLabel", v);
      }
      var subscribeLabels_exports = {};
      __export(subscribeLabels_exports, {
        isInfo: () => isInfo,
        isLabels: () => isLabels,
        validateInfo: () => validateInfo,
        validateLabels: () => validateLabels
      });
      function isLabels(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.subscribeLabels#labels";
      }
      function validateLabels(v) {
        return lexicons.validate("com.atproto.label.subscribeLabels#labels", v);
      }
      function isInfo(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.subscribeLabels#info";
      }
      function validateInfo(v) {
        return lexicons.validate("com.atproto.label.subscribeLabels#info", v);
      }
      var defs_exports3 = {};
      __export(defs_exports3, {
        REASONAPPEAL: () => REASONAPPEAL,
        REASONMISLEADING: () => REASONMISLEADING,
        REASONOTHER: () => REASONOTHER,
        REASONRUDE: () => REASONRUDE,
        REASONSEXUAL: () => REASONSEXUAL,
        REASONSPAM: () => REASONSPAM,
        REASONVIOLATION: () => REASONVIOLATION
      });
      var REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
      var REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
      var REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
      var REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
      var REASONRUDE = "com.atproto.moderation.defs#reasonRude";
      var REASONOTHER = "com.atproto.moderation.defs#reasonOther";
      var REASONAPPEAL = "com.atproto.moderation.defs#reasonAppeal";
      var strongRef_exports = {};
      __export(strongRef_exports, {
        isMain: () => isMain,
        validateMain: () => validateMain
      });
      function isMain(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "com.atproto.repo.strongRef#main" || v.$type === "com.atproto.repo.strongRef");
      }
      function validateMain(v) {
        return lexicons.validate("com.atproto.repo.strongRef#main", v);
      }
      var defs_exports4 = {};
      __export(defs_exports4, {
        isInviteCode: () => isInviteCode,
        isInviteCodeUse: () => isInviteCodeUse,
        validateInviteCode: () => validateInviteCode,
        validateInviteCodeUse: () => validateInviteCodeUse
      });
      function isInviteCode(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.defs#inviteCode";
      }
      function validateInviteCode(v) {
        return lexicons.validate("com.atproto.server.defs#inviteCode", v);
      }
      function isInviteCodeUse(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.defs#inviteCodeUse";
      }
      function validateInviteCodeUse(v) {
        return lexicons.validate("com.atproto.server.defs#inviteCodeUse", v);
      }
      var subscribeRepos_exports = {};
      __export(subscribeRepos_exports, {
        isCommit: () => isCommit,
        isHandle: () => isHandle,
        isInfo: () => isInfo2,
        isMigrate: () => isMigrate,
        isRepoOp: () => isRepoOp,
        isTombstone: () => isTombstone,
        validateCommit: () => validateCommit,
        validateHandle: () => validateHandle,
        validateInfo: () => validateInfo2,
        validateMigrate: () => validateMigrate,
        validateRepoOp: () => validateRepoOp,
        validateTombstone: () => validateTombstone
      });
      function isCommit(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#commit";
      }
      function validateCommit(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#commit", v);
      }
      function isHandle(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#handle";
      }
      function validateHandle(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#handle", v);
      }
      function isMigrate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#migrate";
      }
      function validateMigrate(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#migrate", v);
      }
      function isTombstone(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#tombstone";
      }
      function validateTombstone(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", v);
      }
      function isInfo2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#info";
      }
      function validateInfo2(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#info", v);
      }
      function isRepoOp(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#repoOp";
      }
      function validateRepoOp(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", v);
      }
      var defs_exports5 = {};
      __export(defs_exports5, {
        isAdultContentPref: () => isAdultContentPref,
        isContentLabelPref: () => isContentLabelPref,
        isFeedViewPref: () => isFeedViewPref,
        isPersonalDetailsPref: () => isPersonalDetailsPref,
        isProfileView: () => isProfileView,
        isProfileViewBasic: () => isProfileViewBasic,
        isProfileViewDetailed: () => isProfileViewDetailed,
        isSavedFeedsPref: () => isSavedFeedsPref,
        isThreadViewPref: () => isThreadViewPref,
        isViewerState: () => isViewerState,
        validateAdultContentPref: () => validateAdultContentPref,
        validateContentLabelPref: () => validateContentLabelPref,
        validateFeedViewPref: () => validateFeedViewPref,
        validatePersonalDetailsPref: () => validatePersonalDetailsPref,
        validateProfileView: () => validateProfileView,
        validateProfileViewBasic: () => validateProfileViewBasic,
        validateProfileViewDetailed: () => validateProfileViewDetailed,
        validateSavedFeedsPref: () => validateSavedFeedsPref,
        validateThreadViewPref: () => validateThreadViewPref,
        validateViewerState: () => validateViewerState
      });
      function isProfileViewBasic(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileViewBasic";
      }
      function validateProfileViewBasic(v) {
        return lexicons.validate("app.bsky.actor.defs#profileViewBasic", v);
      }
      function isProfileView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileView";
      }
      function validateProfileView(v) {
        return lexicons.validate("app.bsky.actor.defs#profileView", v);
      }
      function isProfileViewDetailed(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileViewDetailed";
      }
      function validateProfileViewDetailed(v) {
        return lexicons.validate("app.bsky.actor.defs#profileViewDetailed", v);
      }
      function isViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#viewerState";
      }
      function validateViewerState(v) {
        return lexicons.validate("app.bsky.actor.defs#viewerState", v);
      }
      function isAdultContentPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#adultContentPref";
      }
      function validateAdultContentPref(v) {
        return lexicons.validate("app.bsky.actor.defs#adultContentPref", v);
      }
      function isContentLabelPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#contentLabelPref";
      }
      function validateContentLabelPref(v) {
        return lexicons.validate("app.bsky.actor.defs#contentLabelPref", v);
      }
      function isSavedFeedsPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#savedFeedsPref";
      }
      function validateSavedFeedsPref(v) {
        return lexicons.validate("app.bsky.actor.defs#savedFeedsPref", v);
      }
      function isPersonalDetailsPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#personalDetailsPref";
      }
      function validatePersonalDetailsPref(v) {
        return lexicons.validate("app.bsky.actor.defs#personalDetailsPref", v);
      }
      function isFeedViewPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#feedViewPref";
      }
      function validateFeedViewPref(v) {
        return lexicons.validate("app.bsky.actor.defs#feedViewPref", v);
      }
      function isThreadViewPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#threadViewPref";
      }
      function validateThreadViewPref(v) {
        return lexicons.validate("app.bsky.actor.defs#threadViewPref", v);
      }
      var profile_exports = {};
      __export(profile_exports, {
        isRecord: () => isRecord2,
        validateRecord: () => validateRecord2
      });
      function isRecord2(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.actor.profile#main" || v.$type === "app.bsky.actor.profile");
      }
      function validateRecord2(v) {
        return lexicons.validate("app.bsky.actor.profile#main", v);
      }
      var external_exports = {};
      __export(external_exports, {
        isExternal: () => isExternal,
        isMain: () => isMain2,
        isView: () => isView,
        isViewExternal: () => isViewExternal,
        validateExternal: () => validateExternal,
        validateMain: () => validateMain2,
        validateView: () => validateView,
        validateViewExternal: () => validateViewExternal
      });
      function isMain2(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.external#main" || v.$type === "app.bsky.embed.external");
      }
      function validateMain2(v) {
        return lexicons.validate("app.bsky.embed.external#main", v);
      }
      function isExternal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#external";
      }
      function validateExternal(v) {
        return lexicons.validate("app.bsky.embed.external#external", v);
      }
      function isView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#view";
      }
      function validateView(v) {
        return lexicons.validate("app.bsky.embed.external#view", v);
      }
      function isViewExternal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#viewExternal";
      }
      function validateViewExternal(v) {
        return lexicons.validate("app.bsky.embed.external#viewExternal", v);
      }
      var images_exports = {};
      __export(images_exports, {
        isAspectRatio: () => isAspectRatio,
        isImage: () => isImage,
        isMain: () => isMain3,
        isView: () => isView2,
        isViewImage: () => isViewImage,
        validateAspectRatio: () => validateAspectRatio,
        validateImage: () => validateImage,
        validateMain: () => validateMain3,
        validateView: () => validateView2,
        validateViewImage: () => validateViewImage
      });
      function isMain3(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.images#main" || v.$type === "app.bsky.embed.images");
      }
      function validateMain3(v) {
        return lexicons.validate("app.bsky.embed.images#main", v);
      }
      function isImage(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#image";
      }
      function validateImage(v) {
        return lexicons.validate("app.bsky.embed.images#image", v);
      }
      function isAspectRatio(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#aspectRatio";
      }
      function validateAspectRatio(v) {
        return lexicons.validate("app.bsky.embed.images#aspectRatio", v);
      }
      function isView2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#view";
      }
      function validateView2(v) {
        return lexicons.validate("app.bsky.embed.images#view", v);
      }
      function isViewImage(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#viewImage";
      }
      function validateViewImage(v) {
        return lexicons.validate("app.bsky.embed.images#viewImage", v);
      }
      var record_exports = {};
      __export(record_exports, {
        isMain: () => isMain4,
        isView: () => isView3,
        isViewBlocked: () => isViewBlocked,
        isViewNotFound: () => isViewNotFound,
        isViewRecord: () => isViewRecord,
        validateMain: () => validateMain4,
        validateView: () => validateView3,
        validateViewBlocked: () => validateViewBlocked,
        validateViewNotFound: () => validateViewNotFound,
        validateViewRecord: () => validateViewRecord
      });
      function isMain4(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.record#main" || v.$type === "app.bsky.embed.record");
      }
      function validateMain4(v) {
        return lexicons.validate("app.bsky.embed.record#main", v);
      }
      function isView3(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#view";
      }
      function validateView3(v) {
        return lexicons.validate("app.bsky.embed.record#view", v);
      }
      function isViewRecord(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewRecord";
      }
      function validateViewRecord(v) {
        return lexicons.validate("app.bsky.embed.record#viewRecord", v);
      }
      function isViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewNotFound";
      }
      function validateViewNotFound(v) {
        return lexicons.validate("app.bsky.embed.record#viewNotFound", v);
      }
      function isViewBlocked(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewBlocked";
      }
      function validateViewBlocked(v) {
        return lexicons.validate("app.bsky.embed.record#viewBlocked", v);
      }
      var recordWithMedia_exports = {};
      __export(recordWithMedia_exports, {
        isMain: () => isMain5,
        isView: () => isView4,
        validateMain: () => validateMain5,
        validateView: () => validateView4
      });
      function isMain5(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.recordWithMedia#main" || v.$type === "app.bsky.embed.recordWithMedia");
      }
      function validateMain5(v) {
        return lexicons.validate("app.bsky.embed.recordWithMedia#main", v);
      }
      function isView4(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.recordWithMedia#view";
      }
      function validateView4(v) {
        return lexicons.validate("app.bsky.embed.recordWithMedia#view", v);
      }
      var defs_exports6 = {};
      __export(defs_exports6, {
        isBlockedAuthor: () => isBlockedAuthor,
        isBlockedPost: () => isBlockedPost,
        isFeedViewPost: () => isFeedViewPost,
        isGeneratorView: () => isGeneratorView,
        isGeneratorViewerState: () => isGeneratorViewerState,
        isNotFoundPost: () => isNotFoundPost,
        isPostView: () => isPostView,
        isReasonRepost: () => isReasonRepost,
        isReplyRef: () => isReplyRef,
        isSkeletonFeedPost: () => isSkeletonFeedPost,
        isSkeletonReasonRepost: () => isSkeletonReasonRepost,
        isThreadViewPost: () => isThreadViewPost,
        isThreadgateView: () => isThreadgateView,
        isViewerState: () => isViewerState2,
        validateBlockedAuthor: () => validateBlockedAuthor,
        validateBlockedPost: () => validateBlockedPost,
        validateFeedViewPost: () => validateFeedViewPost,
        validateGeneratorView: () => validateGeneratorView,
        validateGeneratorViewerState: () => validateGeneratorViewerState,
        validateNotFoundPost: () => validateNotFoundPost,
        validatePostView: () => validatePostView,
        validateReasonRepost: () => validateReasonRepost,
        validateReplyRef: () => validateReplyRef,
        validateSkeletonFeedPost: () => validateSkeletonFeedPost,
        validateSkeletonReasonRepost: () => validateSkeletonReasonRepost,
        validateThreadViewPost: () => validateThreadViewPost,
        validateThreadgateView: () => validateThreadgateView,
        validateViewerState: () => validateViewerState2
      });
      function isPostView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#postView";
      }
      function validatePostView(v) {
        return lexicons.validate("app.bsky.feed.defs#postView", v);
      }
      function isViewerState2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#viewerState";
      }
      function validateViewerState2(v) {
        return lexicons.validate("app.bsky.feed.defs#viewerState", v);
      }
      function isFeedViewPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#feedViewPost";
      }
      function validateFeedViewPost(v) {
        return lexicons.validate("app.bsky.feed.defs#feedViewPost", v);
      }
      function isReplyRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#replyRef";
      }
      function validateReplyRef(v) {
        return lexicons.validate("app.bsky.feed.defs#replyRef", v);
      }
      function isReasonRepost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#reasonRepost";
      }
      function validateReasonRepost(v) {
        return lexicons.validate("app.bsky.feed.defs#reasonRepost", v);
      }
      function isThreadViewPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#threadViewPost";
      }
      function validateThreadViewPost(v) {
        return lexicons.validate("app.bsky.feed.defs#threadViewPost", v);
      }
      function isNotFoundPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#notFoundPost";
      }
      function validateNotFoundPost(v) {
        return lexicons.validate("app.bsky.feed.defs#notFoundPost", v);
      }
      function isBlockedPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#blockedPost";
      }
      function validateBlockedPost(v) {
        return lexicons.validate("app.bsky.feed.defs#blockedPost", v);
      }
      function isBlockedAuthor(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#blockedAuthor";
      }
      function validateBlockedAuthor(v) {
        return lexicons.validate("app.bsky.feed.defs#blockedAuthor", v);
      }
      function isGeneratorView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#generatorView";
      }
      function validateGeneratorView(v) {
        return lexicons.validate("app.bsky.feed.defs#generatorView", v);
      }
      function isGeneratorViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#generatorViewerState";
      }
      function validateGeneratorViewerState(v) {
        return lexicons.validate("app.bsky.feed.defs#generatorViewerState", v);
      }
      function isSkeletonFeedPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#skeletonFeedPost";
      }
      function validateSkeletonFeedPost(v) {
        return lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", v);
      }
      function isSkeletonReasonRepost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#skeletonReasonRepost";
      }
      function validateSkeletonReasonRepost(v) {
        return lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", v);
      }
      function isThreadgateView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#threadgateView";
      }
      function validateThreadgateView(v) {
        return lexicons.validate("app.bsky.feed.defs#threadgateView", v);
      }
      var generator_exports = {};
      __export(generator_exports, {
        isRecord: () => isRecord3,
        validateRecord: () => validateRecord3
      });
      function isRecord3(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.generator#main" || v.$type === "app.bsky.feed.generator");
      }
      function validateRecord3(v) {
        return lexicons.validate("app.bsky.feed.generator#main", v);
      }
      var like_exports = {};
      __export(like_exports, {
        isRecord: () => isRecord4,
        validateRecord: () => validateRecord4
      });
      function isRecord4(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.like#main" || v.$type === "app.bsky.feed.like");
      }
      function validateRecord4(v) {
        return lexicons.validate("app.bsky.feed.like#main", v);
      }
      var post_exports = {};
      __export(post_exports, {
        isEntity: () => isEntity,
        isRecord: () => isRecord5,
        isReplyRef: () => isReplyRef2,
        isTextSlice: () => isTextSlice,
        validateEntity: () => validateEntity,
        validateRecord: () => validateRecord5,
        validateReplyRef: () => validateReplyRef2,
        validateTextSlice: () => validateTextSlice
      });
      function isRecord5(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.post#main" || v.$type === "app.bsky.feed.post");
      }
      function validateRecord5(v) {
        return lexicons.validate("app.bsky.feed.post#main", v);
      }
      function isReplyRef2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#replyRef";
      }
      function validateReplyRef2(v) {
        return lexicons.validate("app.bsky.feed.post#replyRef", v);
      }
      function isEntity(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#entity";
      }
      function validateEntity(v) {
        return lexicons.validate("app.bsky.feed.post#entity", v);
      }
      function isTextSlice(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#textSlice";
      }
      function validateTextSlice(v) {
        return lexicons.validate("app.bsky.feed.post#textSlice", v);
      }
      var repost_exports = {};
      __export(repost_exports, {
        isRecord: () => isRecord6,
        validateRecord: () => validateRecord6
      });
      function isRecord6(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.repost#main" || v.$type === "app.bsky.feed.repost");
      }
      function validateRecord6(v) {
        return lexicons.validate("app.bsky.feed.repost#main", v);
      }
      var threadgate_exports = {};
      __export(threadgate_exports, {
        isFollowingRule: () => isFollowingRule,
        isListRule: () => isListRule,
        isMentionRule: () => isMentionRule,
        isRecord: () => isRecord7,
        validateFollowingRule: () => validateFollowingRule,
        validateListRule: () => validateListRule,
        validateMentionRule: () => validateMentionRule,
        validateRecord: () => validateRecord7
      });
      function isRecord7(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.threadgate#main" || v.$type === "app.bsky.feed.threadgate");
      }
      function validateRecord7(v) {
        return lexicons.validate("app.bsky.feed.threadgate#main", v);
      }
      function isMentionRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#mentionRule";
      }
      function validateMentionRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#mentionRule", v);
      }
      function isFollowingRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#followingRule";
      }
      function validateFollowingRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#followingRule", v);
      }
      function isListRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#listRule";
      }
      function validateListRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#listRule", v);
      }
      var block_exports = {};
      __export(block_exports, {
        isRecord: () => isRecord8,
        validateRecord: () => validateRecord8
      });
      function isRecord8(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.block#main" || v.$type === "app.bsky.graph.block");
      }
      function validateRecord8(v) {
        return lexicons.validate("app.bsky.graph.block#main", v);
      }
      var defs_exports7 = {};
      __export(defs_exports7, {
        CURATELIST: () => CURATELIST,
        MODLIST: () => MODLIST,
        isListItemView: () => isListItemView,
        isListView: () => isListView,
        isListViewBasic: () => isListViewBasic,
        isListViewerState: () => isListViewerState,
        validateListItemView: () => validateListItemView,
        validateListView: () => validateListView,
        validateListViewBasic: () => validateListViewBasic,
        validateListViewerState: () => validateListViewerState
      });
      function isListViewBasic(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listViewBasic";
      }
      function validateListViewBasic(v) {
        return lexicons.validate("app.bsky.graph.defs#listViewBasic", v);
      }
      function isListView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listView";
      }
      function validateListView(v) {
        return lexicons.validate("app.bsky.graph.defs#listView", v);
      }
      function isListItemView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listItemView";
      }
      function validateListItemView(v) {
        return lexicons.validate("app.bsky.graph.defs#listItemView", v);
      }
      var MODLIST = "app.bsky.graph.defs#modlist";
      var CURATELIST = "app.bsky.graph.defs#curatelist";
      function isListViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listViewerState";
      }
      function validateListViewerState(v) {
        return lexicons.validate("app.bsky.graph.defs#listViewerState", v);
      }
      var follow_exports = {};
      __export(follow_exports, {
        isRecord: () => isRecord9,
        validateRecord: () => validateRecord9
      });
      function isRecord9(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.follow#main" || v.$type === "app.bsky.graph.follow");
      }
      function validateRecord9(v) {
        return lexicons.validate("app.bsky.graph.follow#main", v);
      }
      var list_exports = {};
      __export(list_exports, {
        isRecord: () => isRecord10,
        validateRecord: () => validateRecord10
      });
      function isRecord10(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.list#main" || v.$type === "app.bsky.graph.list");
      }
      function validateRecord10(v) {
        return lexicons.validate("app.bsky.graph.list#main", v);
      }
      var listblock_exports = {};
      __export(listblock_exports, {
        isRecord: () => isRecord11,
        validateRecord: () => validateRecord11
      });
      function isRecord11(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.listblock#main" || v.$type === "app.bsky.graph.listblock");
      }
      function validateRecord11(v) {
        return lexicons.validate("app.bsky.graph.listblock#main", v);
      }
      var listitem_exports = {};
      __export(listitem_exports, {
        isRecord: () => isRecord12,
        validateRecord: () => validateRecord12
      });
      function isRecord12(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.listitem#main" || v.$type === "app.bsky.graph.listitem");
      }
      function validateRecord12(v) {
        return lexicons.validate("app.bsky.graph.listitem#main", v);
      }
      var facet_exports = {};
      __export(facet_exports, {
        isByteSlice: () => isByteSlice,
        isLink: () => isLink,
        isMain: () => isMain6,
        isMention: () => isMention,
        isTag: () => isTag,
        validateByteSlice: () => validateByteSlice,
        validateLink: () => validateLink,
        validateMain: () => validateMain6,
        validateMention: () => validateMention,
        validateTag: () => validateTag
      });
      function isMain6(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.richtext.facet#main" || v.$type === "app.bsky.richtext.facet");
      }
      function validateMain6(v) {
        return lexicons.validate("app.bsky.richtext.facet#main", v);
      }
      function isMention(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#mention";
      }
      function validateMention(v) {
        return lexicons.validate("app.bsky.richtext.facet#mention", v);
      }
      function isLink(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#link";
      }
      function validateLink(v) {
        return lexicons.validate("app.bsky.richtext.facet#link", v);
      }
      function isTag(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#tag";
      }
      function validateTag(v) {
        return lexicons.validate("app.bsky.richtext.facet#tag", v);
      }
      function isByteSlice(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#byteSlice";
      }
      function validateByteSlice(v) {
        return lexicons.validate("app.bsky.richtext.facet#byteSlice", v);
      }
      var defs_exports8 = {};
      __export(defs_exports8, {
        isSkeletonSearchActor: () => isSkeletonSearchActor,
        isSkeletonSearchPost: () => isSkeletonSearchPost,
        validateSkeletonSearchActor: () => validateSkeletonSearchActor,
        validateSkeletonSearchPost: () => validateSkeletonSearchPost
      });
      function isSkeletonSearchPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
      }
      function validateSkeletonSearchPost(v) {
        return lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", v);
      }
      function isSkeletonSearchActor(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
      }
      function validateSkeletonSearchActor(v) {
        return lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", v);
      }
      var COM_ATPROTO_ADMIN = {
        DefsReviewOpen: "com.atproto.admin.defs#reviewOpen",
        DefsReviewEscalated: "com.atproto.admin.defs#reviewEscalated",
        DefsReviewClosed: "com.atproto.admin.defs#reviewClosed"
      };
      var COM_ATPROTO_MODERATION = {
        DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
        DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
        DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
        DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
        DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
        DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
        DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
      };
      var APP_BSKY_GRAPH = {
        DefsModlist: "app.bsky.graph.defs#modlist",
        DefsCuratelist: "app.bsky.graph.defs#curatelist"
      };
      var AtpBaseClient = class {
        constructor() {
          this.xrpc = new Client();
          this.xrpc.addLexicons(schemas);
        }
        service(serviceUri) {
          return new AtpServiceClient(this, this.xrpc.service(serviceUri));
        }
      };
      var AtpServiceClient = class {
        constructor(baseClient, xrpcService) {
          this._baseClient = baseClient;
          this.xrpc = xrpcService;
          this.com = new ComNS(this);
          this.app = new AppNS(this);
        }
        setHeader(key, value) {
          this.xrpc.setHeader(key, value);
        }
      };
      var ComNS = class {
        constructor(service2) {
          this._service = service2;
          this.atproto = new AtprotoNS(service2);
        }
      };
      var AtprotoNS = class {
        constructor(service2) {
          this._service = service2;
          this.admin = new AdminNS(service2);
          this.identity = new IdentityNS(service2);
          this.label = new LabelNS(service2);
          this.moderation = new ModerationNS(service2);
          this.repo = new RepoNS(service2);
          this.server = new ServerNS(service2);
          this.sync = new SyncNS(service2);
          this.temp = new TempNS(service2);
        }
      };
      var AdminNS = class {
        constructor(service2) {
          this._service = service2;
        }
        deleteAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.deleteAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr(e);
          });
        }
        disableAccountInvites(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr2(e);
          });
        }
        disableInviteCodes(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr3(e);
          });
        }
        emitModerationEvent(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.emitModerationEvent", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr4(e);
          });
        }
        enableAccountInvites(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr5(e);
          });
        }
        getAccountInfo(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getAccountInfo", params2, void 0, opts).catch((e) => {
            throw toKnownErr6(e);
          });
        }
        getInviteCodes(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getInviteCodes", params2, void 0, opts).catch((e) => {
            throw toKnownErr7(e);
          });
        }
        getModerationEvent(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getModerationEvent", params2, void 0, opts).catch((e) => {
            throw toKnownErr8(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr9(e);
          });
        }
        getRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr10(e);
          });
        }
        getSubjectStatus(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", params2, void 0, opts).catch((e) => {
            throw toKnownErr11(e);
          });
        }
        queryModerationEvents(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.queryModerationEvents", params2, void 0, opts).catch((e) => {
            throw toKnownErr12(e);
          });
        }
        queryModerationStatuses(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.queryModerationStatuses", params2, void 0, opts).catch((e) => {
            throw toKnownErr13(e);
          });
        }
        searchRepos(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.searchRepos", params2, void 0, opts).catch((e) => {
            throw toKnownErr14(e);
          });
        }
        sendEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.sendEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr15(e);
          });
        }
        updateAccountEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr16(e);
          });
        }
        updateAccountHandle(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr17(e);
          });
        }
        updateSubjectStatus(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr18(e);
          });
        }
      };
      var IdentityNS = class {
        constructor(service2) {
          this._service = service2;
        }
        resolveHandle(params2, opts) {
          return this._service.xrpc.call("com.atproto.identity.resolveHandle", params2, void 0, opts).catch((e) => {
            throw toKnownErr19(e);
          });
        }
        updateHandle(data, opts) {
          return this._service.xrpc.call("com.atproto.identity.updateHandle", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr20(e);
          });
        }
      };
      var LabelNS = class {
        constructor(service2) {
          this._service = service2;
        }
        queryLabels(params2, opts) {
          return this._service.xrpc.call("com.atproto.label.queryLabels", params2, void 0, opts).catch((e) => {
            throw toKnownErr21(e);
          });
        }
      };
      var ModerationNS = class {
        constructor(service2) {
          this._service = service2;
        }
        createReport(data, opts) {
          return this._service.xrpc.call("com.atproto.moderation.createReport", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr22(e);
          });
        }
      };
      var RepoNS = class {
        constructor(service2) {
          this._service = service2;
        }
        applyWrites(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.applyWrites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr23(e);
          });
        }
        createRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.createRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr24(e);
          });
        }
        deleteRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.deleteRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr25(e);
          });
        }
        describeRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.describeRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr26(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr27(e);
          });
        }
        listRecords(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.listRecords", params2, void 0, opts).catch((e) => {
            throw toKnownErr28(e);
          });
        }
        putRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.putRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr29(e);
          });
        }
        uploadBlob(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.uploadBlob", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr30(e);
          });
        }
      };
      var ServerNS = class {
        constructor(service2) {
          this._service = service2;
        }
        confirmEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.server.confirmEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr31(e);
          });
        }
        createAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr32(e);
          });
        }
        createAppPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createAppPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr33(e);
          });
        }
        createInviteCode(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createInviteCode", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr34(e);
          });
        }
        createInviteCodes(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createInviteCodes", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr35(e);
          });
        }
        createSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr36(e);
          });
        }
        deleteAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.server.deleteAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr37(e);
          });
        }
        deleteSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.deleteSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr38(e);
          });
        }
        describeServer(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.describeServer", params2, void 0, opts).catch((e) => {
            throw toKnownErr39(e);
          });
        }
        getAccountInviteCodes(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", params2, void 0, opts).catch((e) => {
            throw toKnownErr40(e);
          });
        }
        getSession(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.getSession", params2, void 0, opts).catch((e) => {
            throw toKnownErr41(e);
          });
        }
        listAppPasswords(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.listAppPasswords", params2, void 0, opts).catch((e) => {
            throw toKnownErr42(e);
          });
        }
        refreshSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.refreshSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr43(e);
          });
        }
        requestAccountDelete(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestAccountDelete", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr44(e);
          });
        }
        requestEmailConfirmation(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr45(e);
          });
        }
        requestEmailUpdate(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr46(e);
          });
        }
        requestPasswordReset(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestPasswordReset", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr47(e);
          });
        }
        reserveSigningKey(data, opts) {
          return this._service.xrpc.call("com.atproto.server.reserveSigningKey", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr48(e);
          });
        }
        resetPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.resetPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr49(e);
          });
        }
        revokeAppPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.revokeAppPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr50(e);
          });
        }
        updateEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.server.updateEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr51(e);
          });
        }
      };
      var SyncNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getBlob(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getBlob", params2, void 0, opts).catch((e) => {
            throw toKnownErr52(e);
          });
        }
        getBlocks(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr53(e);
          });
        }
        getCheckout(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getCheckout", params2, void 0, opts).catch((e) => {
            throw toKnownErr54(e);
          });
        }
        getHead(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getHead", params2, void 0, opts).catch((e) => {
            throw toKnownErr55(e);
          });
        }
        getLatestCommit(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getLatestCommit", params2, void 0, opts).catch((e) => {
            throw toKnownErr56(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr57(e);
          });
        }
        getRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr58(e);
          });
        }
        listBlobs(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.listBlobs", params2, void 0, opts).catch((e) => {
            throw toKnownErr59(e);
          });
        }
        listRepos(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.listRepos", params2, void 0, opts).catch((e) => {
            throw toKnownErr60(e);
          });
        }
        notifyOfUpdate(data, opts) {
          return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr61(e);
          });
        }
        requestCrawl(data, opts) {
          return this._service.xrpc.call("com.atproto.sync.requestCrawl", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr62(e);
          });
        }
      };
      var TempNS = class {
        constructor(service2) {
          this._service = service2;
        }
        fetchLabels(params2, opts) {
          return this._service.xrpc.call("com.atproto.temp.fetchLabels", params2, void 0, opts).catch((e) => {
            throw toKnownErr63(e);
          });
        }
        importRepo(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.importRepo", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr64(e);
          });
        }
        pushBlob(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.pushBlob", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr65(e);
          });
        }
        transferAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.transferAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr66(e);
          });
        }
      };
      var AppNS = class {
        constructor(service2) {
          this._service = service2;
          this.bsky = new BskyNS(service2);
        }
      };
      var BskyNS = class {
        constructor(service2) {
          this._service = service2;
          this.actor = new ActorNS(service2);
          this.embed = new EmbedNS(service2);
          this.feed = new FeedNS(service2);
          this.graph = new GraphNS(service2);
          this.notification = new NotificationNS(service2);
          this.richtext = new RichtextNS(service2);
          this.unspecced = new UnspeccedNS(service2);
        }
      };
      var ActorNS = class {
        constructor(service2) {
          this._service = service2;
          this.profile = new ProfileRecord(service2);
        }
        getPreferences(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getPreferences", params2, void 0, opts).catch((e) => {
            throw toKnownErr67(e);
          });
        }
        getProfile(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getProfile", params2, void 0, opts).catch((e) => {
            throw toKnownErr68(e);
          });
        }
        getProfiles(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getProfiles", params2, void 0, opts).catch((e) => {
            throw toKnownErr69(e);
          });
        }
        getSuggestions(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getSuggestions", params2, void 0, opts).catch((e) => {
            throw toKnownErr70(e);
          });
        }
        putPreferences(data, opts) {
          return this._service.xrpc.call("app.bsky.actor.putPreferences", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr71(e);
          });
        }
        searchActors(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.searchActors", params2, void 0, opts).catch((e) => {
            throw toKnownErr72(e);
          });
        }
        searchActorsTypeahead(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", params2, void 0, opts).catch((e) => {
            throw toKnownErr73(e);
          });
        }
      };
      var ProfileRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.actor.profile"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.actor.profile"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.actor.profile";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.actor.profile", rkey: "self" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.actor.profile" }, params2), { headers });
          });
        }
      };
      var EmbedNS = class {
        constructor(service2) {
          this._service = service2;
        }
      };
      var FeedNS = class {
        constructor(service2) {
          this._service = service2;
          this.generator = new GeneratorRecord(service2);
          this.like = new LikeRecord(service2);
          this.post = new PostRecord(service2);
          this.repost = new RepostRecord(service2);
          this.threadgate = new ThreadgateRecord(service2);
        }
        describeFeedGenerator(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", params2, void 0, opts).catch((e) => {
            throw toKnownErr74(e);
          });
        }
        getActorFeeds(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getActorFeeds", params2, void 0, opts).catch((e) => {
            throw toKnownErr75(e);
          });
        }
        getActorLikes(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getActorLikes", params2, void 0, opts).catch((e) => {
            throw toKnownErr76(e);
          });
        }
        getAuthorFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr77(e);
          });
        }
        getFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr78(e);
          });
        }
        getFeedGenerator(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", params2, void 0, opts).catch((e) => {
            throw toKnownErr79(e);
          });
        }
        getFeedGenerators(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", params2, void 0, opts).catch((e) => {
            throw toKnownErr80(e);
          });
        }
        getFeedSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr81(e);
          });
        }
        getLikes(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getLikes", params2, void 0, opts).catch((e) => {
            throw toKnownErr82(e);
          });
        }
        getListFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getListFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr83(e);
          });
        }
        getPostThread(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getPostThread", params2, void 0, opts).catch((e) => {
            throw toKnownErr84(e);
          });
        }
        getPosts(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getPosts", params2, void 0, opts).catch((e) => {
            throw toKnownErr85(e);
          });
        }
        getRepostedBy(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getRepostedBy", params2, void 0, opts).catch((e) => {
            throw toKnownErr86(e);
          });
        }
        getSuggestedFeeds(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", params2, void 0, opts).catch((e) => {
            throw toKnownErr87(e);
          });
        }
        getTimeline(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getTimeline", params2, void 0, opts).catch((e) => {
            throw toKnownErr88(e);
          });
        }
        searchPosts(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.searchPosts", params2, void 0, opts).catch((e) => {
            throw toKnownErr89(e);
          });
        }
      };
      var GeneratorRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.generator"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.generator"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.generator";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.generator" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.generator" }, params2), { headers });
          });
        }
      };
      var LikeRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.like"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.like"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.like";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.like" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.like" }, params2), { headers });
          });
        }
      };
      var PostRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.post"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.post"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.post";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.post" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.post" }, params2), { headers });
          });
        }
      };
      var RepostRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.repost"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.repost"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.repost";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.repost" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.repost" }, params2), { headers });
          });
        }
      };
      var ThreadgateRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.threadgate"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.threadgate"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.threadgate";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.threadgate" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.threadgate" }, params2), { headers });
          });
        }
      };
      var GraphNS = class {
        constructor(service2) {
          this._service = service2;
          this.block = new BlockRecord(service2);
          this.follow = new FollowRecord(service2);
          this.list = new ListRecord(service2);
          this.listblock = new ListblockRecord(service2);
          this.listitem = new ListitemRecord(service2);
        }
        getBlocks(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr90(e);
          });
        }
        getFollowers(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getFollowers", params2, void 0, opts).catch((e) => {
            throw toKnownErr91(e);
          });
        }
        getFollows(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getFollows", params2, void 0, opts).catch((e) => {
            throw toKnownErr92(e);
          });
        }
        getList(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getList", params2, void 0, opts).catch((e) => {
            throw toKnownErr93(e);
          });
        }
        getListBlocks(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getListBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr94(e);
          });
        }
        getListMutes(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getListMutes", params2, void 0, opts).catch((e) => {
            throw toKnownErr95(e);
          });
        }
        getLists(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getLists", params2, void 0, opts).catch((e) => {
            throw toKnownErr96(e);
          });
        }
        getMutes(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getMutes", params2, void 0, opts).catch((e) => {
            throw toKnownErr97(e);
          });
        }
        getSuggestedFollowsByActor(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", params2, void 0, opts).catch((e) => {
            throw toKnownErr98(e);
          });
        }
        muteActor(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.muteActor", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr99(e);
          });
        }
        muteActorList(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.muteActorList", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr100(e);
          });
        }
        unmuteActor(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.unmuteActor", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr101(e);
          });
        }
        unmuteActorList(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.unmuteActorList", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr102(e);
          });
        }
      };
      var BlockRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.block"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.block"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.block";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.block" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.block" }, params2), { headers });
          });
        }
      };
      var FollowRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.follow"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.follow"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.follow";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.follow" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.follow" }, params2), { headers });
          });
        }
      };
      var ListRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.list"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.list"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.list";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.list" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.list" }, params2), { headers });
          });
        }
      };
      var ListblockRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.listblock"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.listblock"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.listblock";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.listblock" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.listblock" }, params2), { headers });
          });
        }
      };
      var ListitemRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.listitem"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.listitem"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.listitem";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.listitem" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.listitem" }, params2), { headers });
          });
        }
      };
      var NotificationNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getUnreadCount(params2, opts) {
          return this._service.xrpc.call("app.bsky.notification.getUnreadCount", params2, void 0, opts).catch((e) => {
            throw toKnownErr103(e);
          });
        }
        listNotifications(params2, opts) {
          return this._service.xrpc.call("app.bsky.notification.listNotifications", params2, void 0, opts).catch((e) => {
            throw toKnownErr104(e);
          });
        }
        registerPush(data, opts) {
          return this._service.xrpc.call("app.bsky.notification.registerPush", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr105(e);
          });
        }
        updateSeen(data, opts) {
          return this._service.xrpc.call("app.bsky.notification.updateSeen", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr106(e);
          });
        }
      };
      var RichtextNS = class {
        constructor(service2) {
          this._service = service2;
        }
      };
      var UnspeccedNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getPopular(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getPopular", params2, void 0, opts).catch((e) => {
            throw toKnownErr107(e);
          });
        }
        getPopularFeedGenerators(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", params2, void 0, opts).catch((e) => {
            throw toKnownErr108(e);
          });
        }
        getTimelineSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getTimelineSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr109(e);
          });
        }
        searchActorsSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr110(e);
          });
        }
        searchPostsSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr111(e);
          });
        }
      };
      var REFRESH_SESSION = "com.atproto.server.refreshSession";
      var _AtpAgent = class {
        constructor(opts) {
          this.uploadBlob = (data, opts2) => this.api.com.atproto.repo.uploadBlob(data, opts2);
          this.resolveHandle = (params2, opts2) => this.api.com.atproto.identity.resolveHandle(params2, opts2);
          this.updateHandle = (data, opts2) => this.api.com.atproto.identity.updateHandle(data, opts2);
          this.createModerationReport = (data, opts2) => this.api.com.atproto.moderation.createReport(data, opts2);
          this.service = opts.service instanceof URL ? opts.service : new URL(opts.service);
          this._persistSession = opts.persistSession;
          this._baseClient = new AtpBaseClient();
          this._baseClient.xrpc.fetch = this._fetch.bind(this);
          this.api = this._baseClient.service(opts.service);
        }
        get com() {
          return this.api.com;
        }
        static configure(opts) {
          _AtpAgent.fetch = opts.fetch;
        }
        get hasSession() {
          return !!this.session;
        }
        setPersistSessionHandler(handler) {
          this._persistSession = handler;
        }
        createAccount(opts) {
          return __async(this, null, function* () {
            var _a2, _b;
            try {
              const res = yield this.api.com.atproto.server.createAccount({
                handle: opts.handle,
                password: opts.password,
                email: opts.email,
                inviteCode: opts.inviteCode
              });
              this.session = {
                accessJwt: res.data.accessJwt,
                refreshJwt: res.data.refreshJwt,
                handle: res.data.handle,
                did: res.data.did,
                email: opts.email,
                emailConfirmed: false
              };
              this._updateApiEndpoint(res.data.didDoc);
              return res;
            } catch (e) {
              this.session = void 0;
              throw e;
            } finally {
              if (this.session) {
                (_a2 = this._persistSession) == null ? void 0 : _a2.call(this, "create", this.session);
              } else {
                (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
              }
            }
          });
        }
        login(opts) {
          return __async(this, null, function* () {
            var _a2, _b;
            try {
              const res = yield this.api.com.atproto.server.createSession({
                identifier: opts.identifier,
                password: opts.password
              });
              this.session = {
                accessJwt: res.data.accessJwt,
                refreshJwt: res.data.refreshJwt,
                handle: res.data.handle,
                did: res.data.did,
                email: res.data.email,
                emailConfirmed: res.data.emailConfirmed
              };
              this._updateApiEndpoint(res.data.didDoc);
              return res;
            } catch (e) {
              this.session = void 0;
              throw e;
            } finally {
              if (this.session) {
                (_a2 = this._persistSession) == null ? void 0 : _a2.call(this, "create", this.session);
              } else {
                (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
              }
            }
          });
        }
        resumeSession(session) {
          return __async(this, null, function* () {
            var _a2, _b, _c, _d;
            try {
              this.session = session;
              const res = yield this.api.com.atproto.server.getSession();
              if (res.data.did !== this.session.did) {
                throw new XRPCError(400, "Invalid session", "InvalidDID");
              }
              this.session.email = res.data.email;
              this.session.handle = res.data.handle;
              this.session.emailConfirmed = res.data.emailConfirmed;
              this._updateApiEndpoint(res.data.didDoc);
              (_a2 = this._persistSession) == null ? void 0 : _a2.call(this, "update", this.session);
              return res;
            } catch (e) {
              this.session = void 0;
              if (e instanceof XRPCError) {
                if ([1, 408, 425, 429, 500, 502, 503, 504, 522, 524].includes(e.status)) {
                  (_b = this._persistSession) == null ? void 0 : _b.call(this, "network-error", void 0);
                } else {
                  (_c = this._persistSession) == null ? void 0 : _c.call(this, "expired", void 0);
                }
              } else {
                (_d = this._persistSession) == null ? void 0 : _d.call(this, "network-error", void 0);
              }
              throw e;
            }
          });
        }
        _addAuthHeader(reqHeaders) {
          var _a2;
          if (!reqHeaders.authorization && ((_a2 = this.session) == null ? void 0 : _a2.accessJwt)) {
            return __spreadProps(__spreadValues({}, reqHeaders), {
              authorization: `Bearer ${this.session.accessJwt}`
            });
          }
          return reqHeaders;
        }
        _fetch(reqUri, reqMethod, reqHeaders, reqBody) {
          return __async(this, null, function* () {
            var _a2;
            if (!_AtpAgent.fetch) {
              throw new Error("AtpAgent fetch() method not configured");
            }
            yield this._refreshSessionPromise;
            let res = yield _AtpAgent.fetch(reqUri, reqMethod, this._addAuthHeader(reqHeaders), reqBody);
            if (isErrorResponse(res, ["ExpiredToken"]) && ((_a2 = this.session) == null ? void 0 : _a2.refreshJwt)) {
              yield this._refreshSession();
              res = yield _AtpAgent.fetch(reqUri, reqMethod, this._addAuthHeader(reqHeaders), reqBody);
            }
            return res;
          });
        }
        _refreshSession() {
          return __async(this, null, function* () {
            if (this._refreshSessionPromise) {
              return this._refreshSessionPromise;
            }
            this._refreshSessionPromise = this._refreshSessionInner();
            try {
              yield this._refreshSessionPromise;
            } finally {
              this._refreshSessionPromise = void 0;
            }
          });
        }
        _refreshSessionInner() {
          return __async(this, null, function* () {
            var _a2, _b, _c;
            if (!_AtpAgent.fetch) {
              throw new Error("AtpAgent fetch() method not configured");
            }
            if (!((_a2 = this.session) == null ? void 0 : _a2.refreshJwt)) {
              return;
            }
            const url = new URL((this.pdsUrl || this.service).origin);
            url.pathname = `/xrpc/${REFRESH_SESSION}`;
            const res = yield _AtpAgent.fetch(url.toString(), "POST", {
              authorization: `Bearer ${this.session.refreshJwt}`
            }, void 0);
            if (isErrorResponse(res, ["ExpiredToken", "InvalidToken"])) {
              this.session = void 0;
              (_b = this._persistSession) == null ? void 0 : _b.call(this, "expired", void 0);
            } else if (isNewSessionObject(this._baseClient, res.body)) {
              this.session = __spreadProps(__spreadValues({}, this.session || {}), {
                accessJwt: res.body.accessJwt,
                refreshJwt: res.body.refreshJwt,
                handle: res.body.handle,
                did: res.body.did
              });
              this._updateApiEndpoint(res.body.didDoc);
              (_c = this._persistSession) == null ? void 0 : _c.call(this, "update", this.session);
            }
          });
        }
        _updateApiEndpoint(didDoc) {
          if (isValidDidDoc(didDoc)) {
            const endpoint = getPdsEndpoint(didDoc);
            this.pdsUrl = endpoint ? new URL(endpoint) : void 0;
          }
          this.api.xrpc.uri = this.pdsUrl || this.service;
        }
      };
      var AtpAgent = _AtpAgent;
      AtpAgent.fetch = defaultFetchHandler;
      function isErrorObject(v) {
        return errorResponseBody.safeParse(v).success;
      }
      function isErrorResponse(res, errorNames) {
        if (res.status !== 400) {
          return false;
        }
        if (!isErrorObject(res.body)) {
          return false;
        }
        return typeof res.body.error === "string" && errorNames.includes(res.body.error);
      }
      function isNewSessionObject(client, v) {
        try {
          client.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", v);
          return true;
        } catch (e) {
          return false;
        }
      }
      var encoder = new TextEncoder();
      var decoder2 = new TextDecoder();
      var UnicodeString = class {
        constructor(utf16) {
          this.utf16 = utf16;
          this.utf8 = encoder.encode(utf16);
        }
        get length() {
          return this.utf8.byteLength;
        }
        get graphemeLength() {
          if (!this._graphemeLen) {
            this._graphemeLen = graphemeLen(this.utf16);
          }
          return this._graphemeLen;
        }
        slice(start, end) {
          return decoder2.decode(this.utf8.slice(start, end));
        }
        utf16IndexToUtf8Index(i) {
          return encoder.encode(this.utf16.slice(0, i)).byteLength;
        }
        toString() {
          return this.utf16;
        }
      };
      var EXCESS_SPACE_RE = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/;
      var REPLACEMENT_STR = "\n\n";
      function sanitizeRichText(richText, opts) {
        if (opts.cleanNewlines) {
          richText = clean(richText, EXCESS_SPACE_RE, REPLACEMENT_STR);
        }
        return richText;
      }
      function clean(richText, targetRegexp, replacementString) {
        richText = richText.clone();
        let match = richText.unicodeText.utf16.match(targetRegexp);
        while (match && typeof match.index !== "undefined") {
          const oldText = richText.unicodeText;
          const removeStartIndex = richText.unicodeText.utf16IndexToUtf8Index(match.index);
          const removeEndIndex = removeStartIndex + new UnicodeString(match[0]).length;
          richText.delete(removeStartIndex, removeEndIndex);
          if (richText.unicodeText.utf16 === oldText.utf16) {
            break;
          }
          richText.insert(removeStartIndex, replacementString);
          match = richText.unicodeText.utf16.match(targetRegexp);
        }
        return richText;
      }
      var tlds_default = [
        "aaa",
        "aarp",
        "abarth",
        "abb",
        "abbott",
        "abbvie",
        "abc",
        "able",
        "abogado",
        "abudhabi",
        "ac",
        "academy",
        "accenture",
        "accountant",
        "accountants",
        "aco",
        "actor",
        "ad",
        "ads",
        "adult",
        "ae",
        "aeg",
        "aero",
        "aetna",
        "af",
        "afl",
        "africa",
        "ag",
        "agakhan",
        "agency",
        "ai",
        "aig",
        "airbus",
        "airforce",
        "airtel",
        "akdn",
        "al",
        "alfaromeo",
        "alibaba",
        "alipay",
        "allfinanz",
        "allstate",
        "ally",
        "alsace",
        "alstom",
        "am",
        "amazon",
        "americanexpress",
        "americanfamily",
        "amex",
        "amfam",
        "amica",
        "amsterdam",
        "analytics",
        "android",
        "anquan",
        "anz",
        "ao",
        "aol",
        "apartments",
        "app",
        "apple",
        "aq",
        "aquarelle",
        "ar",
        "arab",
        "aramco",
        "archi",
        "army",
        "arpa",
        "art",
        "arte",
        "as",
        "asda",
        "asia",
        "associates",
        "at",
        "athleta",
        "attorney",
        "au",
        "auction",
        "audi",
        "audible",
        "audio",
        "auspost",
        "author",
        "auto",
        "autos",
        "avianca",
        "aw",
        "aws",
        "ax",
        "axa",
        "az",
        "azure",
        "ba",
        "baby",
        "baidu",
        "banamex",
        "bananarepublic",
        "band",
        "bank",
        "bar",
        "barcelona",
        "barclaycard",
        "barclays",
        "barefoot",
        "bargains",
        "baseball",
        "basketball",
        "bauhaus",
        "bayern",
        "bb",
        "bbc",
        "bbt",
        "bbva",
        "bcg",
        "bcn",
        "bd",
        "be",
        "beats",
        "beauty",
        "beer",
        "bentley",
        "berlin",
        "best",
        "bestbuy",
        "bet",
        "bf",
        "bg",
        "bh",
        "bharti",
        "bi",
        "bible",
        "bid",
        "bike",
        "bing",
        "bingo",
        "bio",
        "biz",
        "bj",
        "black",
        "blackfriday",
        "blockbuster",
        "blog",
        "bloomberg",
        "blue",
        "bm",
        "bms",
        "bmw",
        "bn",
        "bnpparibas",
        "bo",
        "boats",
        "boehringer",
        "bofa",
        "bom",
        "bond",
        "boo",
        "book",
        "booking",
        "bosch",
        "bostik",
        "boston",
        "bot",
        "boutique",
        "box",
        "br",
        "bradesco",
        "bridgestone",
        "broadway",
        "broker",
        "brother",
        "brussels",
        "bs",
        "bt",
        "build",
        "builders",
        "business",
        "buy",
        "buzz",
        "bv",
        "bw",
        "by",
        "bz",
        "bzh",
        "ca",
        "cab",
        "cafe",
        "cal",
        "call",
        "calvinklein",
        "cam",
        "camera",
        "camp",
        "canon",
        "capetown",
        "capital",
        "capitalone",
        "car",
        "caravan",
        "cards",
        "care",
        "career",
        "careers",
        "cars",
        "casa",
        "case",
        "cash",
        "casino",
        "cat",
        "catering",
        "catholic",
        "cba",
        "cbn",
        "cbre",
        "cbs",
        "cc",
        "cd",
        "center",
        "ceo",
        "cern",
        "cf",
        "cfa",
        "cfd",
        "cg",
        "ch",
        "chanel",
        "channel",
        "charity",
        "chase",
        "chat",
        "cheap",
        "chintai",
        "christmas",
        "chrome",
        "church",
        "ci",
        "cipriani",
        "circle",
        "cisco",
        "citadel",
        "citi",
        "citic",
        "city",
        "cityeats",
        "ck",
        "cl",
        "claims",
        "cleaning",
        "click",
        "clinic",
        "clinique",
        "clothing",
        "cloud",
        "club",
        "clubmed",
        "cm",
        "cn",
        "co",
        "coach",
        "codes",
        "coffee",
        "college",
        "cologne",
        "com",
        "comcast",
        "commbank",
        "community",
        "company",
        "compare",
        "computer",
        "comsec",
        "condos",
        "construction",
        "consulting",
        "contact",
        "contractors",
        "cooking",
        "cookingchannel",
        "cool",
        "coop",
        "corsica",
        "country",
        "coupon",
        "coupons",
        "courses",
        "cpa",
        "cr",
        "credit",
        "creditcard",
        "creditunion",
        "cricket",
        "crown",
        "crs",
        "cruise",
        "cruises",
        "cu",
        "cuisinella",
        "cv",
        "cw",
        "cx",
        "cy",
        "cymru",
        "cyou",
        "cz",
        "dabur",
        "dad",
        "dance",
        "data",
        "date",
        "dating",
        "datsun",
        "day",
        "dclk",
        "dds",
        "de",
        "deal",
        "dealer",
        "deals",
        "degree",
        "delivery",
        "dell",
        "deloitte",
        "delta",
        "democrat",
        "dental",
        "dentist",
        "desi",
        "design",
        "dev",
        "dhl",
        "diamonds",
        "diet",
        "digital",
        "direct",
        "directory",
        "discount",
        "discover",
        "dish",
        "diy",
        "dj",
        "dk",
        "dm",
        "dnp",
        "do",
        "docs",
        "doctor",
        "dog",
        "domains",
        "dot",
        "download",
        "drive",
        "dtv",
        "dubai",
        "dunlop",
        "dupont",
        "durban",
        "dvag",
        "dvr",
        "dz",
        "earth",
        "eat",
        "ec",
        "eco",
        "edeka",
        "edu",
        "education",
        "ee",
        "eg",
        "email",
        "emerck",
        "energy",
        "engineer",
        "engineering",
        "enterprises",
        "epson",
        "equipment",
        "er",
        "ericsson",
        "erni",
        "es",
        "esq",
        "estate",
        "et",
        "etisalat",
        "eu",
        "eurovision",
        "eus",
        "events",
        "exchange",
        "expert",
        "exposed",
        "express",
        "extraspace",
        "fage",
        "fail",
        "fairwinds",
        "faith",
        "family",
        "fan",
        "fans",
        "farm",
        "farmers",
        "fashion",
        "fast",
        "fedex",
        "feedback",
        "ferrari",
        "ferrero",
        "fi",
        "fiat",
        "fidelity",
        "fido",
        "film",
        "final",
        "finance",
        "financial",
        "fire",
        "firestone",
        "firmdale",
        "fish",
        "fishing",
        "fit",
        "fitness",
        "fj",
        "fk",
        "flickr",
        "flights",
        "flir",
        "florist",
        "flowers",
        "fly",
        "fm",
        "fo",
        "foo",
        "food",
        "foodnetwork",
        "football",
        "ford",
        "forex",
        "forsale",
        "forum",
        "foundation",
        "fox",
        "fr",
        "free",
        "fresenius",
        "frl",
        "frogans",
        "frontdoor",
        "frontier",
        "ftr",
        "fujitsu",
        "fun",
        "fund",
        "furniture",
        "futbol",
        "fyi",
        "ga",
        "gal",
        "gallery",
        "gallo",
        "gallup",
        "game",
        "games",
        "gap",
        "garden",
        "gay",
        "gb",
        "gbiz",
        "gd",
        "gdn",
        "ge",
        "gea",
        "gent",
        "genting",
        "george",
        "gf",
        "gg",
        "ggee",
        "gh",
        "gi",
        "gift",
        "gifts",
        "gives",
        "giving",
        "gl",
        "glass",
        "gle",
        "global",
        "globo",
        "gm",
        "gmail",
        "gmbh",
        "gmo",
        "gmx",
        "gn",
        "godaddy",
        "gold",
        "goldpoint",
        "golf",
        "goo",
        "goodyear",
        "goog",
        "google",
        "gop",
        "got",
        "gov",
        "gp",
        "gq",
        "gr",
        "grainger",
        "graphics",
        "gratis",
        "green",
        "gripe",
        "grocery",
        "group",
        "gs",
        "gt",
        "gu",
        "guardian",
        "gucci",
        "guge",
        "guide",
        "guitars",
        "guru",
        "gw",
        "gy",
        "hair",
        "hamburg",
        "hangout",
        "haus",
        "hbo",
        "hdfc",
        "hdfcbank",
        "health",
        "healthcare",
        "help",
        "helsinki",
        "here",
        "hermes",
        "hgtv",
        "hiphop",
        "hisamitsu",
        "hitachi",
        "hiv",
        "hk",
        "hkt",
        "hm",
        "hn",
        "hockey",
        "holdings",
        "holiday",
        "homedepot",
        "homegoods",
        "homes",
        "homesense",
        "honda",
        "horse",
        "hospital",
        "host",
        "hosting",
        "hot",
        "hoteles",
        "hotels",
        "hotmail",
        "house",
        "how",
        "hr",
        "hsbc",
        "ht",
        "hu",
        "hughes",
        "hyatt",
        "hyundai",
        "ibm",
        "icbc",
        "ice",
        "icu",
        "id",
        "ie",
        "ieee",
        "ifm",
        "ikano",
        "il",
        "im",
        "imamat",
        "imdb",
        "immo",
        "immobilien",
        "in",
        "inc",
        "industries",
        "infiniti",
        "info",
        "ing",
        "ink",
        "institute",
        "insurance",
        "insure",
        "int",
        "international",
        "intuit",
        "investments",
        "io",
        "ipiranga",
        "iq",
        "ir",
        "irish",
        "is",
        "ismaili",
        "ist",
        "istanbul",
        "it",
        "itau",
        "itv",
        "jaguar",
        "java",
        "jcb",
        "je",
        "jeep",
        "jetzt",
        "jewelry",
        "jio",
        "jll",
        "jm",
        "jmp",
        "jnj",
        "jo",
        "jobs",
        "joburg",
        "jot",
        "joy",
        "jp",
        "jpmorgan",
        "jprs",
        "juegos",
        "juniper",
        "kaufen",
        "kddi",
        "ke",
        "kerryhotels",
        "kerrylogistics",
        "kerryproperties",
        "kfh",
        "kg",
        "kh",
        "ki",
        "kia",
        "kids",
        "kim",
        "kinder",
        "kindle",
        "kitchen",
        "kiwi",
        "km",
        "kn",
        "koeln",
        "komatsu",
        "kosher",
        "kp",
        "kpmg",
        "kpn",
        "kr",
        "krd",
        "kred",
        "kuokgroup",
        "kw",
        "ky",
        "kyoto",
        "kz",
        "la",
        "lacaixa",
        "lamborghini",
        "lamer",
        "lancaster",
        "lancia",
        "land",
        "landrover",
        "lanxess",
        "lasalle",
        "lat",
        "latino",
        "latrobe",
        "law",
        "lawyer",
        "lb",
        "lc",
        "lds",
        "lease",
        "leclerc",
        "lefrak",
        "legal",
        "lego",
        "lexus",
        "lgbt",
        "li",
        "lidl",
        "life",
        "lifeinsurance",
        "lifestyle",
        "lighting",
        "like",
        "lilly",
        "limited",
        "limo",
        "lincoln",
        "linde",
        "link",
        "lipsy",
        "live",
        "living",
        "lk",
        "llc",
        "llp",
        "loan",
        "loans",
        "locker",
        "locus",
        "loft",
        "lol",
        "london",
        "lotte",
        "lotto",
        "love",
        "lpl",
        "lplfinancial",
        "lr",
        "ls",
        "lt",
        "ltd",
        "ltda",
        "lu",
        "lundbeck",
        "luxe",
        "luxury",
        "lv",
        "ly",
        "ma",
        "macys",
        "madrid",
        "maif",
        "maison",
        "makeup",
        "man",
        "management",
        "mango",
        "map",
        "market",
        "marketing",
        "markets",
        "marriott",
        "marshalls",
        "maserati",
        "mattel",
        "mba",
        "mc",
        "mckinsey",
        "md",
        "me",
        "med",
        "media",
        "meet",
        "melbourne",
        "meme",
        "memorial",
        "men",
        "menu",
        "merckmsd",
        "mg",
        "mh",
        "miami",
        "microsoft",
        "mil",
        "mini",
        "mint",
        "mit",
        "mitsubishi",
        "mk",
        "ml",
        "mlb",
        "mls",
        "mm",
        "mma",
        "mn",
        "mo",
        "mobi",
        "mobile",
        "moda",
        "moe",
        "moi",
        "mom",
        "monash",
        "money",
        "monster",
        "mormon",
        "mortgage",
        "moscow",
        "moto",
        "motorcycles",
        "mov",
        "movie",
        "mp",
        "mq",
        "mr",
        "ms",
        "msd",
        "mt",
        "mtn",
        "mtr",
        "mu",
        "museum",
        "music",
        "mutual",
        "mv",
        "mw",
        "mx",
        "my",
        "mz",
        "na",
        "nab",
        "nagoya",
        "name",
        "natura",
        "navy",
        "nba",
        "nc",
        "ne",
        "nec",
        "net",
        "netbank",
        "netflix",
        "network",
        "neustar",
        "new",
        "news",
        "next",
        "nextdirect",
        "nexus",
        "nf",
        "nfl",
        "ng",
        "ngo",
        "nhk",
        "ni",
        "nico",
        "nike",
        "nikon",
        "ninja",
        "nissan",
        "nissay",
        "nl",
        "no",
        "nokia",
        "northwesternmutual",
        "norton",
        "now",
        "nowruz",
        "nowtv",
        "np",
        "nr",
        "nra",
        "nrw",
        "ntt",
        "nu",
        "nyc",
        "nz",
        "obi",
        "observer",
        "office",
        "okinawa",
        "olayan",
        "olayangroup",
        "oldnavy",
        "ollo",
        "om",
        "omega",
        "one",
        "ong",
        "onl",
        "online",
        "ooo",
        "open",
        "oracle",
        "orange",
        "org",
        "organic",
        "origins",
        "osaka",
        "otsuka",
        "ott",
        "ovh",
        "pa",
        "page",
        "panasonic",
        "paris",
        "pars",
        "partners",
        "parts",
        "party",
        "passagens",
        "pay",
        "pccw",
        "pe",
        "pet",
        "pf",
        "pfizer",
        "pg",
        "ph",
        "pharmacy",
        "phd",
        "philips",
        "phone",
        "photo",
        "photography",
        "photos",
        "physio",
        "pics",
        "pictet",
        "pictures",
        "pid",
        "pin",
        "ping",
        "pink",
        "pioneer",
        "pizza",
        "pk",
        "pl",
        "place",
        "play",
        "playstation",
        "plumbing",
        "plus",
        "pm",
        "pn",
        "pnc",
        "pohl",
        "poker",
        "politie",
        "porn",
        "post",
        "pr",
        "pramerica",
        "praxi",
        "press",
        "prime",
        "pro",
        "prod",
        "productions",
        "prof",
        "progressive",
        "promo",
        "properties",
        "property",
        "protection",
        "pru",
        "prudential",
        "ps",
        "pt",
        "pub",
        "pw",
        "pwc",
        "py",
        "qa",
        "qpon",
        "quebec",
        "quest",
        "racing",
        "radio",
        "re",
        "read",
        "realestate",
        "realtor",
        "realty",
        "recipes",
        "red",
        "redstone",
        "redumbrella",
        "rehab",
        "reise",
        "reisen",
        "reit",
        "reliance",
        "ren",
        "rent",
        "rentals",
        "repair",
        "report",
        "republican",
        "rest",
        "restaurant",
        "review",
        "reviews",
        "rexroth",
        "rich",
        "richardli",
        "ricoh",
        "ril",
        "rio",
        "rip",
        "ro",
        "rocher",
        "rocks",
        "rodeo",
        "rogers",
        "room",
        "rs",
        "rsvp",
        "ru",
        "rugby",
        "ruhr",
        "run",
        "rw",
        "rwe",
        "ryukyu",
        "sa",
        "saarland",
        "safe",
        "safety",
        "sakura",
        "sale",
        "salon",
        "samsclub",
        "samsung",
        "sandvik",
        "sandvikcoromant",
        "sanofi",
        "sap",
        "sarl",
        "sas",
        "save",
        "saxo",
        "sb",
        "sbi",
        "sbs",
        "sc",
        "sca",
        "scb",
        "schaeffler",
        "schmidt",
        "scholarships",
        "school",
        "schule",
        "schwarz",
        "science",
        "scot",
        "sd",
        "se",
        "search",
        "seat",
        "secure",
        "security",
        "seek",
        "select",
        "sener",
        "services",
        "ses",
        "seven",
        "sew",
        "sex",
        "sexy",
        "sfr",
        "sg",
        "sh",
        "shangrila",
        "sharp",
        "shaw",
        "shell",
        "shia",
        "shiksha",
        "shoes",
        "shop",
        "shopping",
        "shouji",
        "show",
        "showtime",
        "si",
        "silk",
        "sina",
        "singles",
        "site",
        "sj",
        "sk",
        "ski",
        "skin",
        "sky",
        "skype",
        "sl",
        "sling",
        "sm",
        "smart",
        "smile",
        "sn",
        "sncf",
        "so",
        "soccer",
        "social",
        "softbank",
        "software",
        "sohu",
        "solar",
        "solutions",
        "song",
        "sony",
        "soy",
        "spa",
        "space",
        "sport",
        "spot",
        "sr",
        "srl",
        "ss",
        "st",
        "stada",
        "staples",
        "star",
        "statebank",
        "statefarm",
        "stc",
        "stcgroup",
        "stockholm",
        "storage",
        "store",
        "stream",
        "studio",
        "study",
        "style",
        "su",
        "sucks",
        "supplies",
        "supply",
        "support",
        "surf",
        "surgery",
        "suzuki",
        "sv",
        "swatch",
        "swiss",
        "sx",
        "sy",
        "sydney",
        "systems",
        "sz",
        "tab",
        "taipei",
        "talk",
        "taobao",
        "target",
        "tatamotors",
        "tatar",
        "tattoo",
        "tax",
        "taxi",
        "tc",
        "tci",
        "td",
        "tdk",
        "team",
        "tech",
        "technology",
        "tel",
        "temasek",
        "tennis",
        "teva",
        "tf",
        "tg",
        "th",
        "thd",
        "theater",
        "theatre",
        "tiaa",
        "tickets",
        "tienda",
        "tiffany",
        "tips",
        "tires",
        "tirol",
        "tj",
        "tjmaxx",
        "tjx",
        "tk",
        "tkmaxx",
        "tl",
        "tm",
        "tmall",
        "tn",
        "to",
        "today",
        "tokyo",
        "tools",
        "top",
        "toray",
        "toshiba",
        "total",
        "tours",
        "town",
        "toyota",
        "toys",
        "tr",
        "trade",
        "trading",
        "training",
        "travel",
        "travelchannel",
        "travelers",
        "travelersinsurance",
        "trust",
        "trv",
        "tt",
        "tube",
        "tui",
        "tunes",
        "tushu",
        "tv",
        "tvs",
        "tw",
        "tz",
        "ua",
        "ubank",
        "ubs",
        "ug",
        "uk",
        "unicom",
        "university",
        "uno",
        "uol",
        "ups",
        "us",
        "uy",
        "uz",
        "va",
        "vacations",
        "vana",
        "vanguard",
        "vc",
        "ve",
        "vegas",
        "ventures",
        "verisign",
        "verm\xF6gensberater",
        "verm\xF6gensberatung",
        "versicherung",
        "vet",
        "vg",
        "vi",
        "viajes",
        "video",
        "vig",
        "viking",
        "villas",
        "vin",
        "vip",
        "virgin",
        "visa",
        "vision",
        "viva",
        "vivo",
        "vlaanderen",
        "vn",
        "vodka",
        "volkswagen",
        "volvo",
        "vote",
        "voting",
        "voto",
        "voyage",
        "vu",
        "vuelos",
        "wales",
        "walmart",
        "walter",
        "wang",
        "wanggou",
        "watch",
        "watches",
        "weather",
        "weatherchannel",
        "webcam",
        "weber",
        "website",
        "wed",
        "wedding",
        "weibo",
        "weir",
        "wf",
        "whoswho",
        "wien",
        "wiki",
        "williamhill",
        "win",
        "windows",
        "wine",
        "winners",
        "wme",
        "wolterskluwer",
        "woodside",
        "work",
        "works",
        "world",
        "wow",
        "ws",
        "wtc",
        "wtf",
        "xbox",
        "xerox",
        "xfinity",
        "xihuan",
        "xin",
        "xxx",
        "xyz",
        "yachts",
        "yahoo",
        "yamaxun",
        "yandex",
        "ye",
        "yodobashi",
        "yoga",
        "yokohama",
        "you",
        "youtube",
        "yt",
        "yun",
        "za",
        "zappos",
        "zara",
        "zero",
        "zip",
        "zm",
        "zone",
        "zuerich",
        "zw",
        "\u03B5\u03BB",
        "\u03B5\u03C5",
        "\u0431\u0433",
        "\u0431\u0435\u043B",
        "\u0434\u0435\u0442\u0438",
        "\u0435\u044E",
        "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
        "\u043A\u043E\u043C",
        "\u043C\u043A\u0434",
        "\u043C\u043E\u043D",
        "\u043C\u043E\u0441\u043A\u0432\u0430",
        "\u043E\u043D\u043B\u0430\u0439\u043D",
        "\u043E\u0440\u0433",
        "\u0440\u0443\u0441",
        "\u0440\u0444",
        "\u0441\u0430\u0439\u0442",
        "\u0441\u0440\u0431",
        "\u0443\u043A\u0440",
        "\u049B\u0430\u0437",
        "\u0570\u0561\u0575",
        "\u05D9\u05E9\u05E8\u05D0\u05DC",
        "\u05E7\u05D5\u05DD",
        "\u0627\u0628\u0648\u0638\u0628\u064A",
        "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
        "\u0627\u0631\u0627\u0645\u0643\u0648",
        "\u0627\u0644\u0627\u0631\u062F\u0646",
        "\u0627\u0644\u0628\u062D\u0631\u064A\u0646",
        "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
        "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
        "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
        "\u0627\u0644\u0645\u063A\u0631\u0628",
        "\u0627\u0645\u0627\u0631\u0627\u062A",
        "\u0627\u06CC\u0631\u0627\u0646",
        "\u0628\u0627\u0631\u062A",
        "\u0628\u0627\u0632\u0627\u0631",
        "\u0628\u064A\u062A\u0643",
        "\u0628\u06BE\u0627\u0631\u062A",
        "\u062A\u0648\u0646\u0633",
        "\u0633\u0648\u062F\u0627\u0646",
        "\u0633\u0648\u0631\u064A\u0629",
        "\u0634\u0628\u0643\u0629",
        "\u0639\u0631\u0627\u0642",
        "\u0639\u0631\u0628",
        "\u0639\u0645\u0627\u0646",
        "\u0641\u0644\u0633\u0637\u064A\u0646",
        "\u0642\u0637\u0631",
        "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
        "\u0643\u0648\u0645",
        "\u0645\u0635\u0631",
        "\u0645\u0644\u064A\u0633\u064A\u0627",
        "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
        "\u0645\u0648\u0642\u0639",
        "\u0647\u0645\u0631\u0627\u0647",
        "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
        "\u0680\u0627\u0631\u062A",
        "\u0915\u0949\u092E",
        "\u0928\u0947\u091F",
        "\u092D\u093E\u0930\u0924",
        "\u092D\u093E\u0930\u0924\u092E\u094D",
        "\u092D\u093E\u0930\u094B\u0924",
        "\u0938\u0902\u0917\u0920\u0928",
        "\u09AC\u09BE\u0982\u09B2\u09BE",
        "\u09AD\u09BE\u09B0\u09A4",
        "\u09AD\u09BE\u09F0\u09A4",
        "\u0A2D\u0A3E\u0A30\u0A24",
        "\u0AAD\u0ABE\u0AB0\u0AA4",
        "\u0B2D\u0B3E\u0B30\u0B24",
        "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
        "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
        "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
        "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
        "\u0CAD\u0CBE\u0CB0\u0CA4",
        "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
        "\u0DBD\u0D82\u0D9A\u0DCF",
        "\u0E04\u0E2D\u0E21",
        "\u0E44\u0E17\u0E22",
        "\u0EA5\u0EB2\u0EA7",
        "\u10D2\u10D4",
        "\u307F\u3093\u306A",
        "\u30A2\u30DE\u30BE\u30F3",
        "\u30AF\u30E9\u30A6\u30C9",
        "\u30B0\u30FC\u30B0\u30EB",
        "\u30B3\u30E0",
        "\u30B9\u30C8\u30A2",
        "\u30BB\u30FC\u30EB",
        "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
        "\u30DD\u30A4\u30F3\u30C8",
        "\u4E16\u754C",
        "\u4E2D\u4FE1",
        "\u4E2D\u56FD",
        "\u4E2D\u570B",
        "\u4E2D\u6587\u7F51",
        "\u4E9A\u9A6C\u900A",
        "\u4F01\u4E1A",
        "\u4F5B\u5C71",
        "\u4FE1\u606F",
        "\u5065\u5EB7",
        "\u516B\u5366",
        "\u516C\u53F8",
        "\u516C\u76CA",
        "\u53F0\u6E7E",
        "\u53F0\u7063",
        "\u5546\u57CE",
        "\u5546\u5E97",
        "\u5546\u6807",
        "\u5609\u91CC",
        "\u5609\u91CC\u5927\u9152\u5E97",
        "\u5728\u7EBF",
        "\u5927\u62FF",
        "\u5929\u4E3B\u6559",
        "\u5A31\u4E50",
        "\u5BB6\u96FB",
        "\u5E7F\u4E1C",
        "\u5FAE\u535A",
        "\u6148\u5584",
        "\u6211\u7231\u4F60",
        "\u624B\u673A",
        "\u62DB\u8058",
        "\u653F\u52A1",
        "\u653F\u5E9C",
        "\u65B0\u52A0\u5761",
        "\u65B0\u95FB",
        "\u65F6\u5C1A",
        "\u66F8\u7C4D",
        "\u673A\u6784",
        "\u6DE1\u9A6C\u9521",
        "\u6E38\u620F",
        "\u6FB3\u9580",
        "\u70B9\u770B",
        "\u79FB\u52A8",
        "\u7EC4\u7EC7\u673A\u6784",
        "\u7F51\u5740",
        "\u7F51\u5E97",
        "\u7F51\u7AD9",
        "\u7F51\u7EDC",
        "\u8054\u901A",
        "\u8BFA\u57FA\u4E9A",
        "\u8C37\u6B4C",
        "\u8D2D\u7269",
        "\u901A\u8CA9",
        "\u96C6\u56E2",
        "\u96FB\u8A0A\u76C8\u79D1",
        "\u98DE\u5229\u6D66",
        "\u98DF\u54C1",
        "\u9910\u5385",
        "\u9999\u683C\u91CC\u62C9",
        "\u9999\u6E2F",
        "\uB2F7\uB137",
        "\uB2F7\uCEF4",
        "\uC0BC\uC131",
        "\uD55C\uAD6D"
      ];
      function detectFacets(text) {
        var _a2;
        let match;
        const facets = [];
        {
          const re = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
          while (match = re.exec(text.utf16)) {
            if (!isValidDomain(match[3]) && !match[3].endsWith(".test")) {
              continue;
            }
            const start = text.utf16.indexOf(match[3], match.index) - 1;
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(start),
                byteEnd: text.utf16IndexToUtf8Index(start + match[3].length + 1)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#mention",
                  did: match[3]
                }
              ]
            });
          }
        }
        {
          const re = new RegExp("(^|\\s|\\()((https?:\\/\\/[\\S]+)|((?<domain>[a-z][a-z0-9]*(\\.[a-z0-9]+)+)[\\S]*))", "gim");
          while (match = re.exec(text.utf16)) {
            let uri2 = match[2];
            if (!uri2.startsWith("http")) {
              const domain = (_a2 = match.groups) == null ? void 0 : _a2.domain;
              if (!domain || !isValidDomain(domain)) {
                continue;
              }
              uri2 = `https://${uri2}`;
            }
            const start = text.utf16.indexOf(match[2], match.index);
            const index = { start, end: start + match[2].length };
            if (/[.,;:!?]$/.test(uri2)) {
              uri2 = uri2.slice(0, -1);
              index.end--;
            }
            if (/[)]$/.test(uri2) && !uri2.includes("(")) {
              uri2 = uri2.slice(0, -1);
              index.end--;
            }
            facets.push({
              index: {
                byteStart: text.utf16IndexToUtf8Index(index.start),
                byteEnd: text.utf16IndexToUtf8Index(index.end)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#link",
                  uri: uri2
                }
              ]
            });
          }
        }
        {
          const re = /(?:^|\s)(#[^\d\s]\S*)(?=\s)?/g;
          while (match = re.exec(text.utf16)) {
            let [tag] = match;
            const hasLeadingSpace = /^\s/.test(tag);
            tag = tag.trim().replace(new RegExp("\\p{P}+$", "gu"), "");
            if (tag.length > 66)
              continue;
            const index = match.index + (hasLeadingSpace ? 1 : 0);
            facets.push({
              index: {
                byteStart: text.utf16IndexToUtf8Index(index),
                byteEnd: text.utf16IndexToUtf8Index(index + tag.length)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#tag",
                  tag: tag.replace(/^#/, "")
                }
              ]
            });
          }
        }
        return facets.length > 0 ? facets : void 0;
      }
      function isValidDomain(str) {
        return !!tlds_default.find((tld) => {
          const i = str.lastIndexOf(tld);
          if (i === -1) {
            return false;
          }
          return str.charAt(i - 1) === "." && i === str.length - tld.length;
        });
      }
      var RichTextSegment = class {
        constructor(text, facet) {
          this.text = text;
          this.facet = facet;
        }
        get link() {
          var _a2;
          const link = (_a2 = this.facet) == null ? void 0 : _a2.features.find(facet_exports.isLink);
          if (facet_exports.isLink(link)) {
            return link;
          }
          return void 0;
        }
        isLink() {
          return !!this.link;
        }
        get mention() {
          var _a2;
          const mention = (_a2 = this.facet) == null ? void 0 : _a2.features.find(facet_exports.isMention);
          if (facet_exports.isMention(mention)) {
            return mention;
          }
          return void 0;
        }
        isMention() {
          return !!this.mention;
        }
        get tag() {
          var _a2;
          const tag = (_a2 = this.facet) == null ? void 0 : _a2.features.find(facet_exports.isTag);
          if (facet_exports.isTag(tag)) {
            return tag;
          }
          return void 0;
        }
        isTag() {
          return !!this.tag;
        }
      };
      var RichText = class {
        constructor(props, opts) {
          var _a2, _b;
          this.unicodeText = new UnicodeString(props.text);
          this.facets = props.facets;
          if (!((_a2 = this.facets) == null ? void 0 : _a2.length) && ((_b = props.entities) == null ? void 0 : _b.length)) {
            this.facets = entitiesToFacets(this.unicodeText, props.entities);
          }
          if (this.facets) {
            this.facets.sort(facetSort);
          }
          if (opts == null ? void 0 : opts.cleanNewlines) {
            sanitizeRichText(this, { cleanNewlines: true }).copyInto(this);
          }
        }
        get text() {
          return this.unicodeText.toString();
        }
        get length() {
          return this.unicodeText.length;
        }
        get graphemeLength() {
          return this.unicodeText.graphemeLength;
        }
        clone() {
          return new RichText({
            text: this.unicodeText.utf16,
            facets: cloneDeep(this.facets)
          });
        }
        copyInto(target2) {
          target2.unicodeText = this.unicodeText;
          target2.facets = cloneDeep(this.facets);
        }
        *segments() {
          const facets = this.facets || [];
          if (!facets.length) {
            yield new RichTextSegment(this.unicodeText.utf16);
            return;
          }
          let textCursor = 0;
          let facetCursor = 0;
          do {
            const currFacet = facets[facetCursor];
            if (textCursor < currFacet.index.byteStart) {
              yield new RichTextSegment(this.unicodeText.slice(textCursor, currFacet.index.byteStart));
            } else if (textCursor > currFacet.index.byteStart) {
              facetCursor++;
              continue;
            }
            if (currFacet.index.byteStart < currFacet.index.byteEnd) {
              const subtext = this.unicodeText.slice(currFacet.index.byteStart, currFacet.index.byteEnd);
              if (!subtext.trim()) {
                yield new RichTextSegment(subtext);
              } else {
                yield new RichTextSegment(subtext, currFacet);
              }
            }
            textCursor = currFacet.index.byteEnd;
            facetCursor++;
          } while (facetCursor < facets.length);
          if (textCursor < this.unicodeText.length) {
            yield new RichTextSegment(this.unicodeText.slice(textCursor, this.unicodeText.length));
          }
        }
        insert(insertIndex, insertText) {
          var _a2;
          this.unicodeText = new UnicodeString(this.unicodeText.slice(0, insertIndex) + insertText + this.unicodeText.slice(insertIndex));
          if (!((_a2 = this.facets) == null ? void 0 : _a2.length)) {
            return this;
          }
          const numCharsAdded = insertText.length;
          for (const ent of this.facets) {
            if (insertIndex <= ent.index.byteStart) {
              ent.index.byteStart += numCharsAdded;
              ent.index.byteEnd += numCharsAdded;
            } else if (insertIndex >= ent.index.byteStart && insertIndex < ent.index.byteEnd) {
              ent.index.byteEnd += numCharsAdded;
            }
          }
          return this;
        }
        delete(removeStartIndex, removeEndIndex) {
          var _a2;
          this.unicodeText = new UnicodeString(this.unicodeText.slice(0, removeStartIndex) + this.unicodeText.slice(removeEndIndex));
          if (!((_a2 = this.facets) == null ? void 0 : _a2.length)) {
            return this;
          }
          const numCharsRemoved = removeEndIndex - removeStartIndex;
          for (const ent of this.facets) {
            if (removeStartIndex <= ent.index.byteStart && removeEndIndex >= ent.index.byteEnd) {
              ent.index.byteStart = 0;
              ent.index.byteEnd = 0;
            } else if (removeStartIndex > ent.index.byteEnd) {
            } else if (removeStartIndex > ent.index.byteStart && removeStartIndex <= ent.index.byteEnd && removeEndIndex > ent.index.byteEnd) {
              ent.index.byteEnd = removeStartIndex;
            } else if (removeStartIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
              ent.index.byteEnd -= numCharsRemoved;
            } else if (removeStartIndex < ent.index.byteStart && removeEndIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
              ent.index.byteStart = removeStartIndex;
              ent.index.byteEnd -= numCharsRemoved;
            } else if (removeEndIndex < ent.index.byteStart) {
              ent.index.byteStart -= numCharsRemoved;
              ent.index.byteEnd -= numCharsRemoved;
            }
          }
          this.facets = this.facets.filter((ent) => ent.index.byteStart < ent.index.byteEnd);
          return this;
        }
        detectFacets(agent) {
          return __async(this, null, function* () {
            this.facets = detectFacets(this.unicodeText);
            if (this.facets) {
              for (const facet of this.facets) {
                for (const feature of facet.features) {
                  if (facet_exports.isMention(feature)) {
                    const did2 = yield agent.resolveHandle({ handle: feature.did }).catch((_) => void 0).then((res) => res == null ? void 0 : res.data.did);
                    feature.did = did2 || "";
                  }
                }
              }
              this.facets.sort(facetSort);
            }
          });
        }
        detectFacetsWithoutResolution() {
          this.facets = detectFacets(this.unicodeText);
          if (this.facets) {
            this.facets.sort(facetSort);
          }
        }
      };
      var facetSort = (a, b) => a.index.byteStart - b.index.byteStart;
      function entitiesToFacets(text, entities) {
        const facets = [];
        for (const ent of entities) {
          if (ent.type === "link") {
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(ent.index.start),
                byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
              },
              features: [{ $type: "app.bsky.richtext.facet#link", uri: ent.value }]
            });
          } else if (ent.type === "mention") {
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(ent.index.start),
                byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
              },
              features: [
                { $type: "app.bsky.richtext.facet#mention", did: ent.value }
              ]
            });
          }
        }
        return facets;
      }
      function cloneDeep(v) {
        if (typeof v === "undefined") {
          return v;
        }
        return JSON.parse(JSON.stringify(v));
      }
      var ModerationDecision = class {
        constructor(cause = void 0, alert = false, blur = false, blurMedia = false, filter = false, noOverride = false, additionalCauses = [], did2 = "") {
          this.cause = cause;
          this.alert = alert;
          this.blur = blur;
          this.blurMedia = blurMedia;
          this.filter = filter;
          this.noOverride = noOverride;
          this.additionalCauses = additionalCauses;
          this.did = did2;
        }
        static noop() {
          return new ModerationDecision();
        }
      };
      var LABELS = {
        "!hide": {
          id: "!hide",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Hide",
                description: "Moderator has chosen to hide the content."
              }
            },
            account: {
              en: {
                name: "Content Blocked",
                description: "This account has been hidden by the moderators."
              }
            },
            content: {
              en: {
                name: "Content Blocked",
                description: "This content has been hidden by the moderators."
              }
            }
          }
        },
        "!no-promote": {
          id: "!no-promote",
          preferences: ["hide"],
          flags: [],
          onwarn: null,
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Filter",
                description: "Moderator has chosen to filter the content from feeds."
              }
            },
            account: {
              en: {
                name: "N/A",
                description: "N/A"
              }
            },
            content: {
              en: {
                name: "N/A",
                description: "N/A"
              }
            }
          }
        },
        "!warn": {
          id: "!warn",
          preferences: ["warn"],
          flags: [],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Warn",
                description: "Moderator has chosen to set a general warning on the content."
              }
            },
            account: {
              en: {
                name: "Content Warning",
                description: "This account has received a general warning from moderators."
              }
            },
            content: {
              en: {
                name: "Content Warning",
                description: "This content has received a general warning from moderators."
              }
            }
          }
        },
        "!no-unauthenticated": {
          id: "!no-unauthenticated",
          preferences: ["hide"],
          flags: ["no-override", "unauthed"],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their account only be shown to signed-in users."
              }
            },
            account: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their account only be shown to signed-in users."
              }
            },
            content: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their content only be shown to signed-in users."
              }
            }
          }
        },
        "dmca-violation": {
          id: "dmca-violation",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "legal",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Copyright Violation",
                description: "The content has received a DMCA takedown request."
              }
            },
            account: {
              en: {
                name: "Copyright Violation",
                description: "This account has received a DMCA takedown request. It will be restored if the concerns can be resolved."
              }
            },
            content: {
              en: {
                name: "Copyright Violation",
                description: "This content has received a DMCA takedown request. It will be restored if the concerns can be resolved."
              }
            }
          }
        },
        doxxing: {
          id: "doxxing",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "legal",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Doxxing",
                description: "Information that reveals private information about someone which has been shared without the consent of the subject."
              }
            },
            account: {
              en: {
                name: "Doxxing",
                description: "This account has been reported to publish private information about someone without their consent. This report is currently under review."
              }
            },
            content: {
              en: {
                name: "Doxxing",
                description: "This content has been reported to include private information about someone without their consent."
              }
            }
          }
        },
        porn: {
          id: "porn",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Pornography",
                description: "Images of full-frontal nudity (genitalia) in any sexualized context, or explicit sexual activity (meaning contact with genitalia or breasts) even if partially covered. Includes graphic sexual cartoons (often jokes/memes)."
              }
            },
            account: {
              en: {
                name: "Adult Content",
                description: "This account contains imagery of full-frontal nudity or explicit sexual activity."
              }
            },
            content: {
              en: {
                name: "Adult Content",
                description: "This content contains imagery of full-frontal nudity or explicit sexual activity."
              }
            }
          }
        },
        sexual: {
          id: "sexual",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Sexually Suggestive",
                description: 'Content that does not meet the level of "pornography", but is still sexual. Some common examples have been selfies and "hornyposting" with underwear on, or partially naked (naked but covered, eg with hands or from side perspective). Sheer/see-through nipples may end up in this category.'
              }
            },
            account: {
              en: {
                name: "Suggestive Content",
                description: "This account contains imagery which is sexually suggestive. Common examples include selfies in underwear or in partial undress."
              }
            },
            content: {
              en: {
                name: "Suggestive Content",
                description: "This content contains imagery which is sexually suggestive. Common examples include selfies in underwear or in partial undress."
              }
            }
          }
        },
        nudity: {
          id: "nudity",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Nudity",
                description: 'Nudity which is not sexual, or that is primarily "artistic" in nature. For example: breastfeeding; classic art paintings and sculptures; newspaper images with some nudity; fashion modeling. "Erotic photography" is likely to end up in sexual or porn.'
              }
            },
            account: {
              en: {
                name: "Adult Content",
                description: "This account contains imagery which portrays nudity in a non-sexual or artistic setting."
              }
            },
            content: {
              en: {
                name: "Adult Content",
                description: "This content contains imagery which portrays nudity in a non-sexual or artistic setting."
              }
            }
          }
        },
        nsfl: {
          id: "nsfl",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "NSFL",
                description: `"Not Suitable For Life." This includes graphic images like the infamous "goatse" (don't look it up).`
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (NSFL)",
                description: 'This account contains graphic images which are often referred to as "Not Suitable For Life."'
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (NSFL)",
                description: 'This content contains graphic images which are often referred to as "Not Suitable For Life."'
              }
            }
          }
        },
        corpse: {
          id: "corpse",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Corpse",
                description: "Visual image of a dead human body in any context. Includes war images, hanging, funeral caskets. Does not include all figurative cases (cartoons), but can include realistic figurative images or renderings."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Corpse)",
                description: "This account contains images of a dead human body in any context. Includes war images, hanging, funeral caskets."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Corpse)",
                description: "This content contains images of a dead human body in any context. Includes war images, hanging, funeral caskets."
              }
            }
          }
        },
        gore: {
          id: "gore",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Gore",
                description: "Intended for shocking images, typically involving blood or visible wounds."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Gore)",
                description: "This account contains shocking images involving blood or visible wounds."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Gore)",
                description: "This content contains shocking images involving blood or visible wounds."
              }
            }
          }
        },
        torture: {
          id: "torture",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Torture",
                description: "Depictions of torture of a human or animal (animal cruelty)."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Torture)",
                description: "This account contains depictions of torture of a human or animal."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Torture)",
                description: "This content contains depictions of torture of a human or animal."
              }
            }
          }
        },
        "self-harm": {
          id: "self-harm",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Self-Harm",
                description: "A visual depiction (photo or figurative) of cutting, suicide, or similar."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Self-Harm)",
                description: "This account includes depictions of cutting, suicide, or other forms of self-harm."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Self-Harm)",
                description: "This content includes depictions of cutting, suicide, or other forms of self-harm."
              }
            }
          }
        },
        "intolerant-race": {
          id: "intolerant-race",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Racial Intolerance",
                description: "Hateful or intolerant content related to race."
              }
            },
            account: {
              en: {
                name: "Intolerance (Racial)",
                description: "This account includes hateful or intolerant content related to race."
              }
            },
            content: {
              en: {
                name: "Intolerance (Racial)",
                description: "This content includes hateful or intolerant views related to race."
              }
            }
          }
        },
        "intolerant-gender": {
          id: "intolerant-gender",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Gender Intolerance",
                description: "Hateful or intolerant content related to gender or gender identity."
              }
            },
            account: {
              en: {
                name: "Intolerance (Gender)",
                description: "This account includes hateful or intolerant content related to gender or gender identity."
              }
            },
            content: {
              en: {
                name: "Intolerance (Gender)",
                description: "This content includes hateful or intolerant views related to gender or gender identity."
              }
            }
          }
        },
        "intolerant-sexual-orientation": {
          id: "intolerant-sexual-orientation",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Sexual Orientation Intolerance",
                description: "Hateful or intolerant content related to sexual preferences."
              }
            },
            account: {
              en: {
                name: "Intolerance (Orientation)",
                description: "This account includes hateful or intolerant content related to sexual preferences."
              }
            },
            content: {
              en: {
                name: "Intolerance (Orientation)",
                description: "This content includes hateful or intolerant views related to sexual preferences."
              }
            }
          }
        },
        "intolerant-religion": {
          id: "intolerant-religion",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Religious Intolerance",
                description: "Hateful or intolerant content related to religious views or practices."
              }
            },
            account: {
              en: {
                name: "Intolerance (Religious)",
                description: "This account includes hateful or intolerant content related to religious views or practices."
              }
            },
            content: {
              en: {
                name: "Intolerance (Religious)",
                description: "This content includes hateful or intolerant views related to religious views or practices."
              }
            }
          }
        },
        intolerant: {
          id: "intolerant",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Intolerance",
                description: "A catchall for hateful or intolerant content which is not covered elsewhere."
              }
            },
            account: {
              en: {
                name: "Intolerance",
                description: "This account includes hateful or intolerant content."
              }
            },
            content: {
              en: {
                name: "Intolerance",
                description: "This content includes hateful or intolerant views."
              }
            }
          }
        },
        "icon-intolerant": {
          id: "icon-intolerant",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur-media",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Intolerant Iconography",
                description: "Visual imagery associated with a hate group, such as the KKK or Nazi, in any context (supportive, critical, documentary, etc)."
              }
            },
            account: {
              en: {
                name: "Intolerant Iconography",
                description: "This account includes imagery associated with a hate group such as the KKK or Nazis. This warning may apply to content any context, including critical or documentary purposes."
              }
            },
            content: {
              en: {
                name: "Intolerant Iconography",
                description: "This content includes imagery associated with a hate group such as the KKK or Nazis. This warning may apply to content any context, including critical or documentary purposes."
              }
            }
          }
        },
        threat: {
          id: "threat",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "rude",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Threats",
                description: "Statements or imagery published with the intent to threaten, intimidate, or harm."
              }
            },
            account: {
              en: {
                name: "Threats",
                description: "The moderators believe this account has published statements or imagery with the intent to threaten, intimidate, or harm others."
              }
            },
            content: {
              en: {
                name: "Threats",
                description: "The moderators believe this content was published with the intent to threaten, intimidate, or harm others."
              }
            }
          }
        },
        spoiler: {
          id: "spoiler",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "curation",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Spoiler",
                description: "Discussion about film, TV, etc which gives away plot points."
              }
            },
            account: {
              en: {
                name: "Spoiler Warning",
                description: "This account contains discussion about film, TV, etc which gives away plot points."
              }
            },
            content: {
              en: {
                name: "Spoiler Warning",
                description: "This content contains discussion about film, TV, etc which gives away plot points."
              }
            }
          }
        },
        spam: {
          id: "spam",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "spam",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Spam",
                description: "Repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            },
            account: {
              en: {
                name: "Spam",
                description: "This account publishes repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            },
            content: {
              en: {
                name: "Spam",
                description: "This content is a part of repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            }
          }
        },
        "account-security": {
          id: "account-security",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Security Concerns",
                description: "Content designed to hijack user accounts such as a phishing attack."
              }
            },
            account: {
              en: {
                name: "Security Warning",
                description: "This account has published content designed to hijack user accounts such as a phishing attack."
              }
            },
            content: {
              en: {
                name: "Security Warning",
                description: "This content is designed to hijack user accounts such as a phishing attack."
              }
            }
          }
        },
        "net-abuse": {
          id: "net-abuse",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Network Attacks",
                description: "Content designed to attack network systems such as denial-of-service attacks."
              }
            },
            account: {
              en: {
                name: "Network Attack Warning",
                description: "This account has published content designed to attack network systems such as denial-of-service attacks."
              }
            },
            content: {
              en: {
                name: "Network Attack Warning",
                description: "This content is designed to attack network systems such as denial-of-service attacks."
              }
            }
          }
        },
        impersonation: {
          id: "impersonation",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Impersonation",
                description: "Accounts which falsely assert some identity."
              }
            },
            account: {
              en: {
                name: "Impersonation Warning",
                description: "The moderators believe this account is lying about their identity."
              }
            },
            content: {
              en: {
                name: "Impersonation Warning",
                description: "The moderators believe this account is lying about their identity."
              }
            }
          }
        },
        scam: {
          id: "scam",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Scam",
                description: "Fraudulent content."
              }
            },
            account: {
              en: {
                name: "Scam Warning",
                description: "The moderators believe this account publishes fraudulent content."
              }
            },
            content: {
              en: {
                name: "Scam Warning",
                description: "The moderators believe this is fraudulent content."
              }
            }
          }
        },
        misleading: {
          id: "misleading",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Misleading",
                description: "Accounts which share misleading information."
              }
            },
            account: {
              en: {
                name: "Misleading",
                description: "The moderators believe this account is spreading misleading information."
              }
            },
            content: {
              en: {
                name: "Misleading",
                description: "The moderators believe this account is spreading misleading information."
              }
            }
          }
        }
      };
      var ModerationCauseAccumulator = class {
        constructor() {
          this.did = "";
          this.causes = [];
        }
        setDid(did2) {
          this.did = did2;
        }
        addBlocking(blocking) {
          if (blocking) {
            this.causes.push({
              type: "blocking",
              source: { type: "user" },
              priority: 3
            });
          }
        }
        addBlockingByList(blockingByList) {
          if (blockingByList) {
            this.causes.push({
              type: "blocking",
              source: { type: "list", list: blockingByList },
              priority: 3
            });
          }
        }
        addBlockedBy(blockedBy) {
          if (blockedBy) {
            this.causes.push({
              type: "blocked-by",
              source: { type: "user" },
              priority: 4
            });
          }
        }
        addBlockOther(blockOther) {
          if (blockOther) {
            this.causes.push({
              type: "block-other",
              source: { type: "user" },
              priority: 4
            });
          }
        }
        addLabel(label, opts) {
          const labelDef = LABELS[label.val];
          if (!labelDef) {
            return;
          }
          const isSelf = label.src === this.did;
          const labeler = isSelf ? void 0 : opts.labelers.find((s) => s.labeler.did === label.src);
          let labelPref = "ignore";
          if (!labelDef.configurable) {
            labelPref = labelDef.preferences[0];
          } else if (labelDef.flags.includes("adult") && !opts.adultContentEnabled) {
            labelPref = "hide";
          } else if (labeler == null ? void 0 : labeler.labels[label.val]) {
            labelPref = labeler.labels[label.val];
          } else if (opts.labels[label.val]) {
            labelPref = opts.labels[label.val];
          }
          if (labelPref === "ignore") {
            return;
          }
          if (labelDef.flags.includes("unauthed") && !!opts.userDid) {
            return;
          }
          let priority;
          if (labelDef.flags.includes("no-override")) {
            priority = 1;
          } else if (labelPref === "hide") {
            priority = 2;
          } else if (labelDef.onwarn === "blur") {
            priority = 5;
          } else if (labelDef.onwarn === "blur-media") {
            priority = 7;
          } else {
            priority = 8;
          }
          this.causes.push({
            type: "label",
            source: isSelf || !labeler ? { type: "user" } : { type: "labeler", labeler: labeler.labeler },
            label,
            labelDef,
            setting: labelPref,
            priority
          });
        }
        addMuted(muted) {
          if (muted) {
            this.causes.push({
              type: "muted",
              source: { type: "user" },
              priority: 6
            });
          }
        }
        addMutedByList(mutedByList) {
          if (mutedByList) {
            this.causes.push({
              type: "muted",
              source: { type: "list", list: mutedByList },
              priority: 6
            });
          }
        }
        finalizeDecision(opts) {
          const mod = new ModerationDecision();
          mod.did = this.did;
          if (!this.causes.length) {
            return mod;
          }
          this.causes.sort((a, b) => a.priority - b.priority);
          mod.cause = this.causes[0];
          mod.additionalCauses = this.causes.slice(1);
          if (mod.cause.type === "blocking" || mod.cause.type === "blocked-by" || mod.cause.type === "block-other") {
            mod.filter = true;
            mod.blur = true;
            mod.noOverride = true;
          } else if (mod.cause.type === "muted") {
            mod.filter = true;
            mod.blur = true;
          } else if (mod.cause.type === "label") {
            if (mod.cause.setting === "hide") {
              mod.filter = true;
            }
            switch (mod.cause.labelDef.onwarn) {
              case "alert":
                mod.alert = true;
                break;
              case "blur":
                mod.blur = true;
                break;
              case "blur-media":
                mod.blurMedia = true;
                break;
              case null:
                break;
            }
            if (mod.cause.labelDef.flags.includes("no-override")) {
              mod.noOverride = true;
            } else if (mod.cause.labelDef.flags.includes("adult") && !opts.adultContentEnabled) {
              mod.noOverride = true;
            }
          }
          return mod;
        }
      };
      function decideAccount(subject, opts) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.did);
        if ((_a2 = subject.viewer) == null ? void 0 : _a2.muted) {
          if ((_b = subject.viewer) == null ? void 0 : _b.mutedByList) {
            acc.addMutedByList((_c = subject.viewer) == null ? void 0 : _c.mutedByList);
          } else {
            acc.addMuted((_d = subject.viewer) == null ? void 0 : _d.muted);
          }
        }
        if ((_e = subject.viewer) == null ? void 0 : _e.blocking) {
          if ((_f = subject.viewer) == null ? void 0 : _f.blockingByList) {
            acc.addBlockingByList((_g = subject.viewer) == null ? void 0 : _g.blockingByList);
          } else {
            acc.addBlocking((_h = subject.viewer) == null ? void 0 : _h.blocking);
          }
        }
        acc.addBlockedBy((_i = subject.viewer) == null ? void 0 : _i.blockedBy);
        for (const label of filterAccountLabels(subject.labels)) {
          acc.addLabel(label, opts);
        }
        return acc.finalizeDecision(opts);
      }
      function filterAccountLabels(labels) {
        if (!labels) {
          return [];
        }
        return labels.filter((label) => !label.uri.endsWith("/app.bsky.actor.profile/self") || label.val === "!no-unauthenticated");
      }
      function decideProfile(subject, opts) {
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.did);
        for (const label of filterProfileLabels(subject.labels)) {
          acc.addLabel(label, opts);
        }
        return acc.finalizeDecision(opts);
      }
      function filterProfileLabels(labels) {
        if (!labels) {
          return [];
        }
        return labels.filter((label) => label.uri.endsWith("/app.bsky.actor.profile/self"));
      }
      function decidePost(subject, opts) {
        var _a2;
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.author.did);
        if ((_a2 = subject.labels) == null ? void 0 : _a2.length) {
          for (const label of subject.labels) {
            acc.addLabel(label, opts);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPost(subject, opts) {
        var _a2, _b, _c, _d, _e;
        const acc = new ModerationCauseAccumulator();
        if (record_exports.isViewRecord(subject.record)) {
          acc.setDid(subject.record.author.did);
          if ((_a2 = subject.record.labels) == null ? void 0 : _a2.length) {
            for (const label of subject.record.labels) {
              acc.addLabel(label, opts);
            }
          }
        } else if (record_exports.isViewBlocked(subject.record)) {
          acc.setDid(subject.record.author.did);
          if ((_b = subject.record.author.viewer) == null ? void 0 : _b.blocking) {
            acc.addBlocking((_c = subject.record.author.viewer) == null ? void 0 : _c.blocking);
          } else if ((_d = subject.record.author.viewer) == null ? void 0 : _d.blockedBy) {
            acc.addBlockedBy((_e = subject.record.author.viewer) == null ? void 0 : _e.blockedBy);
          } else {
            acc.addBlockOther(true);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPostAccount(subject, opts) {
        if (record_exports.isViewRecord(subject.record)) {
          return decideAccount(subject.record.author, opts);
        }
        return ModerationDecision.noop();
      }
      function decideQuotedPostWithMedia(subject, opts) {
        var _a2, _b, _c, _d, _e;
        const acc = new ModerationCauseAccumulator();
        if (record_exports.isViewRecord(subject.record.record)) {
          acc.setDid(subject.record.record.author.did);
          if ((_a2 = subject.record.record.labels) == null ? void 0 : _a2.length) {
            for (const label of subject.record.record.labels) {
              acc.addLabel(label, opts);
            }
          }
        } else if (record_exports.isViewBlocked(subject.record.record)) {
          acc.setDid(subject.record.record.author.did);
          if ((_b = subject.record.record.author.viewer) == null ? void 0 : _b.blocking) {
            acc.addBlocking((_c = subject.record.record.author.viewer) == null ? void 0 : _c.blocking);
          } else if ((_d = subject.record.record.author.viewer) == null ? void 0 : _d.blockedBy) {
            acc.addBlockedBy((_e = subject.record.record.author.viewer) == null ? void 0 : _e.blockedBy);
          } else {
            acc.addBlockOther(true);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPostWithMediaAccount(subject, opts) {
        if (record_exports.isViewRecord(subject.record.record)) {
          return decideAccount(subject.record.record.author, opts);
        }
        return ModerationDecision.noop();
      }
      function decideFeedGenerator(_subject, _opts) {
        return ModerationDecision.noop();
      }
      function decideUserList(_subject, _opts) {
        return ModerationDecision.noop();
      }
      function takeHighestPriorityDecision(...decisions) {
        const filtered = decisions.filter((d) => !!d);
        if (filtered.length === 0) {
          return ModerationDecision.noop();
        }
        filtered.sort((a, b) => {
          if (a.cause && b.cause) {
            return a.cause.priority - b.cause.priority;
          }
          if (a.cause) {
            return -1;
          }
          if (b.cause) {
            return 1;
          }
          return 0;
        });
        return filtered[0];
      }
      function downgradeDecision(decision, to) {
        decision.filter = false;
        decision.noOverride = false;
        if (to === "noop") {
          decision.blur = false;
          decision.blurMedia = false;
          decision.alert = false;
          delete decision.cause;
        } else if (to === "alert") {
          decision.blur = false;
          decision.blurMedia = false;
          decision.alert = true;
        }
      }
      function isModerationDecisionNoop(decision, { ignoreFilter } = { ignoreFilter: false }) {
        if (!decision) {
          return true;
        }
        if (decision.alert) {
          return false;
        }
        if (decision.blur) {
          return false;
        }
        if (decision.filter && !ignoreFilter) {
          return false;
        }
        return true;
      }
      function isQuotedPost(embed) {
        return Boolean(embed && record_exports.isView(embed));
      }
      function isQuotedPostWithMedia(embed) {
        return Boolean(embed && recordWithMedia_exports.isView(embed));
      }
      function toModerationUI(decision) {
        return {
          cause: decision.cause,
          filter: decision.filter,
          blur: decision.blur,
          alert: decision.alert,
          noOverride: decision.noOverride
        };
      }
      function moderateProfile(subject, opts) {
        var _a2, _b, _c, _d;
        const account = decideAccount(subject, opts);
        const profile = decideProfile(subject, opts);
        if (account.blurMedia) {
          account.blur = true;
        }
        profile.filter = false;
        if (!isModerationDecisionNoop(account) && account.did === opts.userDid) {
          downgradeDecision(account, "alert");
        }
        if (!isModerationDecisionNoop(profile) && profile.did === opts.userDid) {
          downgradeDecision(profile, "alert");
        }
        let avatarBlur = false;
        let avatarNoOverride = false;
        if ((account.blur || account.blurMedia) && ((_a2 = account.cause) == null ? void 0 : _a2.type) !== "muted") {
          avatarBlur = true;
          avatarNoOverride = account.noOverride || profile.noOverride;
        } else if (profile.blur || profile.blurMedia) {
          avatarBlur = true;
          avatarNoOverride = account.noOverride || profile.noOverride;
        }
        if (((_b = account.cause) == null ? void 0 : _b.type) === "blocking" || ((_c = account.cause) == null ? void 0 : _c.type) === "blocked-by" || ((_d = account.cause) == null ? void 0 : _d.type) === "muted") {
          account.blur = false;
          account.noOverride = false;
        }
        return {
          decisions: { account, profile },
          account: account.filter || account.blur || account.alert ? toModerationUI(account) : {},
          profile: profile.filter || profile.blur || profile.alert ? toModerationUI(profile) : {},
          avatar: {
            blur: avatarBlur,
            alert: account.alert || profile.alert,
            noOverride: avatarNoOverride
          }
        };
      }
      function moderatePost(subject, opts) {
        var _a2, _b;
        const post = decidePost(subject, opts);
        const account = decideAccount(subject.author, opts);
        const profile = decideProfile(subject.author, opts);
        let quote;
        let quotedAccount;
        if (isQuotedPost(subject.embed)) {
          quote = decideQuotedPost(subject.embed, opts);
          quotedAccount = decideQuotedPostAccount(subject.embed, opts);
        } else if (isQuotedPostWithMedia(subject.embed)) {
          quote = decideQuotedPostWithMedia(subject.embed, opts);
          quotedAccount = decideQuotedPostWithMediaAccount(subject.embed, opts);
        }
        if (quote == null ? void 0 : quote.blurMedia) {
          quote.blur = true;
        }
        if (!isModerationDecisionNoop(post) && post.did === opts.userDid) {
          downgradeDecision(post, "blur");
        }
        if (account.cause && account.did === opts.userDid) {
          downgradeDecision(account, "noop");
        }
        if (profile.cause && profile.did === opts.userDid) {
          downgradeDecision(profile, "noop");
        }
        if (quote && !isModerationDecisionNoop(quote) && quote.did === opts.userDid) {
          downgradeDecision(quote, "blur");
        }
        if (quotedAccount && !isModerationDecisionNoop(quotedAccount) && quotedAccount.did === opts.userDid) {
          downgradeDecision(quotedAccount, "noop");
        }
        const mergedForFeed = takeHighestPriorityDecision(post, account, quote, quotedAccount);
        const mergedForView = takeHighestPriorityDecision(post, account);
        const mergedQuote = takeHighestPriorityDecision(quote, quotedAccount);
        let blurAvatar = false;
        if ((account.blur || account.blurMedia) && ((_a2 = account.cause) == null ? void 0 : _a2.type) !== "muted") {
          blurAvatar = true;
        } else if ((profile.blur || profile.blurMedia) && ((_b = profile.cause) == null ? void 0 : _b.type) !== "muted") {
          blurAvatar = true;
        }
        return {
          decisions: { post, account, profile, quote, quotedAccount },
          content: {
            cause: !isModerationDecisionNoop(mergedForView) ? mergedForView.cause : mergedForFeed.filter ? mergedForFeed.cause : void 0,
            filter: mergedForFeed.filter,
            blur: mergedForView.blur,
            alert: mergedForView.alert,
            noOverride: mergedForView.noOverride
          },
          avatar: {
            blur: blurAvatar,
            alert: account.alert || profile.alert,
            noOverride: account.noOverride || profile.noOverride
          },
          embed: !isModerationDecisionNoop(mergedQuote, { ignoreFilter: true }) ? {
            cause: mergedQuote.cause,
            blur: mergedQuote.blur,
            alert: mergedQuote.alert,
            noOverride: mergedQuote.noOverride
          } : account.blurMedia ? {
            cause: account.cause,
            blur: true,
            noOverride: account.noOverride
          } : post.blurMedia ? {
            cause: post.cause,
            blur: true,
            noOverride: post.noOverride
          } : {}
        };
      }
      function moderateFeedGenerator(subject, opts) {
        const feedGenerator = decideFeedGenerator(subject, opts);
        const account = decideAccount(subject.creator, opts);
        const profile = decideProfile(subject.creator, opts);
        const merged = takeHighestPriorityDecision(feedGenerator, account);
        return {
          decisions: { feedGenerator, account, profile },
          content: {
            cause: isModerationDecisionNoop(merged) ? void 0 : merged.cause,
            filter: merged.filter,
            blur: merged.blur,
            alert: merged.alert,
            noOverride: merged.noOverride
          },
          avatar: {
            blur: account.blurMedia || profile.blurMedia,
            alert: account.alert,
            noOverride: account.noOverride || profile.noOverride
          }
        };
      }
      function moderateUserList(subject, opts) {
        const userList = decideUserList(subject, opts);
        const account = defs_exports5.isProfileViewBasic(subject.creator) ? decideAccount(subject.creator, opts) : ModerationDecision.noop();
        const profile = defs_exports5.isProfileViewBasic(subject.creator) ? decideProfile(subject.creator, opts) : ModerationDecision.noop();
        const merged = takeHighestPriorityDecision(userList, account);
        return {
          decisions: { userList, account, profile },
          content: {
            cause: isModerationDecisionNoop(merged) ? void 0 : merged.cause,
            filter: merged.filter,
            blur: merged.blur,
            alert: merged.alert,
            noOverride: merged.noOverride
          },
          avatar: {
            blur: account.blurMedia || profile.blurMedia,
            alert: account.alert,
            noOverride: account.noOverride || profile.noOverride
          }
        };
      }
      var LABEL_GROUPS = {
        system: {
          id: "system",
          configurable: false,
          labels: [
            LABELS["!hide"],
            LABELS["!no-promote"],
            LABELS["!warn"],
            LABELS["!no-unauthenticated"]
          ],
          strings: {
            settings: {
              en: {
                name: "System",
                description: "Moderator overrides for special cases."
              }
            }
          }
        },
        legal: {
          id: "legal",
          configurable: false,
          labels: [LABELS["dmca-violation"], LABELS["doxxing"]],
          strings: {
            settings: {
              en: {
                name: "Legal",
                description: "Content removed for legal reasons."
              }
            }
          }
        },
        sexual: {
          id: "sexual",
          configurable: true,
          labels: [LABELS["porn"], LABELS["sexual"], LABELS["nudity"]],
          strings: {
            settings: {
              en: {
                name: "Adult Content",
                description: "Content which is sexual in nature."
              }
            }
          }
        },
        violence: {
          id: "violence",
          configurable: true,
          labels: [
            LABELS["nsfl"],
            LABELS["corpse"],
            LABELS["gore"],
            LABELS["torture"],
            LABELS["self-harm"]
          ],
          strings: {
            settings: {
              en: {
                name: "Violence",
                description: "Content which is violent or deeply disturbing."
              }
            }
          }
        },
        intolerance: {
          id: "intolerance",
          configurable: true,
          labels: [
            LABELS["intolerant-race"],
            LABELS["intolerant-gender"],
            LABELS["intolerant-sexual-orientation"],
            LABELS["intolerant-religion"],
            LABELS["intolerant"],
            LABELS["icon-intolerant"]
          ],
          strings: {
            settings: {
              en: {
                name: "Intolerance",
                description: "Content or behavior which is hateful or intolerant toward a group of people."
              }
            }
          }
        },
        rude: {
          id: "rude",
          configurable: true,
          labels: [LABELS["threat"]],
          strings: {
            settings: {
              en: {
                name: "Rude",
                description: "Behavior which is rude toward other users."
              }
            }
          }
        },
        curation: {
          id: "curation",
          configurable: true,
          labels: [LABELS["spoiler"]],
          strings: {
            settings: {
              en: {
                name: "Curational",
                description: "Subjective moderation geared towards curating a more positive environment."
              }
            }
          }
        },
        spam: {
          id: "spam",
          configurable: true,
          labels: [LABELS["spam"]],
          strings: {
            settings: {
              en: {
                name: "Spam",
                description: "Content which doesn't add to the conversation."
              }
            }
          }
        },
        misinfo: {
          id: "misinfo",
          configurable: true,
          labels: [
            LABELS["account-security"],
            LABELS["net-abuse"],
            LABELS["impersonation"],
            LABELS["scam"],
            LABELS["misleading"]
          ],
          strings: {
            settings: {
              en: {
                name: "Misinformation",
                description: "Content which misleads or defrauds users."
              }
            }
          }
        }
      };
      var FEED_VIEW_PREF_DEFAULTS = {
        hideReplies: false,
        hideRepliesByUnfollowed: false,
        hideRepliesByLikeCount: 0,
        hideReposts: false,
        hideQuotePosts: false
      };
      var THREAD_VIEW_PREF_DEFAULTS = {
        sort: "oldest",
        prioritizeFollowedUsers: true
      };
      var BskyAgent2 = class extends AtpAgent {
        constructor() {
          super(...arguments);
          this.getTimeline = (params2, opts) => this.api.app.bsky.feed.getTimeline(params2, opts);
          this.getAuthorFeed = (params2, opts) => this.api.app.bsky.feed.getAuthorFeed(params2, opts);
          this.getActorLikes = (params2, opts) => this.api.app.bsky.feed.getActorLikes(params2, opts);
          this.getPostThread = (params2, opts) => this.api.app.bsky.feed.getPostThread(params2, opts);
          this.getPost = (params2) => this.api.app.bsky.feed.post.get(params2);
          this.getPosts = (params2, opts) => this.api.app.bsky.feed.getPosts(params2, opts);
          this.getLikes = (params2, opts) => this.api.app.bsky.feed.getLikes(params2, opts);
          this.getRepostedBy = (params2, opts) => this.api.app.bsky.feed.getRepostedBy(params2, opts);
          this.getFollows = (params2, opts) => this.api.app.bsky.graph.getFollows(params2, opts);
          this.getFollowers = (params2, opts) => this.api.app.bsky.graph.getFollowers(params2, opts);
          this.getProfile = (params2, opts) => this.api.app.bsky.actor.getProfile(params2, opts);
          this.getProfiles = (params2, opts) => this.api.app.bsky.actor.getProfiles(params2, opts);
          this.getSuggestions = (params2, opts) => this.api.app.bsky.actor.getSuggestions(params2, opts);
          this.searchActors = (params2, opts) => this.api.app.bsky.actor.searchActors(params2, opts);
          this.searchActorsTypeahead = (params2, opts) => this.api.app.bsky.actor.searchActorsTypeahead(params2, opts);
          this.listNotifications = (params2, opts) => this.api.app.bsky.notification.listNotifications(params2, opts);
          this.countUnreadNotifications = (params2, opts) => this.api.app.bsky.notification.getUnreadCount(params2, opts);
        }
        get app() {
          return this.api.app;
        }
        post(record) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            record.createdAt = record.createdAt || (/* @__PURE__ */ new Date()).toISOString();
            return this.api.app.bsky.feed.post.create({ repo: this.session.did }, record);
          });
        }
        deletePost(postUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const postUrip = new AtUri(postUri);
            return yield this.api.app.bsky.feed.post.delete({
              repo: postUrip.hostname,
              rkey: postUrip.rkey
            });
          });
        }
        like(uri2, cid2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
              subject: { uri: uri2, cid: cid2 },
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteLike(likeUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const likeUrip = new AtUri(likeUri);
            return yield this.api.app.bsky.feed.like.delete({
              repo: likeUrip.hostname,
              rkey: likeUrip.rkey
            });
          });
        }
        repost(uri2, cid2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
              subject: { uri: uri2, cid: cid2 },
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteRepost(repostUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const repostUrip = new AtUri(repostUri);
            return yield this.api.app.bsky.feed.repost.delete({
              repo: repostUrip.hostname,
              rkey: repostUrip.rkey
            });
          });
        }
        follow(subjectDid) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
              subject: subjectDid,
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteFollow(followUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const followUrip = new AtUri(followUri);
            return yield this.api.app.bsky.graph.follow.delete({
              repo: followUrip.hostname,
              rkey: followUrip.rkey
            });
          });
        }
        upsertProfile(updateFn) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            let retriesRemaining = 5;
            while (retriesRemaining >= 0) {
              const existing = yield this.com.atproto.repo.getRecord({
                repo: this.session.did,
                collection: "app.bsky.actor.profile",
                rkey: "self"
              }).catch((_) => void 0);
              const updated = yield updateFn(existing == null ? void 0 : existing.data.value);
              if (updated) {
                updated.$type = "app.bsky.actor.profile";
              }
              const validation = profile_exports.validateRecord(updated);
              if (!validation.success) {
                throw validation.error;
              }
              try {
                yield this.com.atproto.repo.putRecord({
                  repo: this.session.did,
                  collection: "app.bsky.actor.profile",
                  rkey: "self",
                  record: updated,
                  swapRecord: (existing == null ? void 0 : existing.data.cid) || null
                });
              } catch (e) {
                if (retriesRemaining > 0 && e instanceof putRecord_exports.InvalidSwapError) {
                  retriesRemaining--;
                  continue;
                } else {
                  throw e;
                }
              }
              break;
            }
          });
        }
        mute(actor) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.muteActor({ actor });
          });
        }
        unmute(actor) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.unmuteActor({ actor });
          });
        }
        muteModList(uri2) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.muteActorList({
              list: uri2
            });
          });
        }
        unmuteModList(uri2) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.unmuteActorList({
              list: uri2
            });
          });
        }
        blockModList(uri2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
              subject: uri2,
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        unblockModList(uri2) {
          return __async(this, null, function* () {
            var _a2;
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const listInfo = yield this.api.app.bsky.graph.getList({
              list: uri2,
              limit: 1
            });
            if (!((_a2 = listInfo.data.list.viewer) == null ? void 0 : _a2.blocked)) {
              return;
            }
            const { rkey } = new AtUri(listInfo.data.list.viewer.blocked);
            return yield this.api.app.bsky.graph.listblock.delete({
              repo: this.session.did,
              rkey
            });
          });
        }
        updateSeenNotifications(seenAt) {
          return __async(this, null, function* () {
            seenAt = seenAt || (/* @__PURE__ */ new Date()).toISOString();
            return this.api.app.bsky.notification.updateSeen({
              seenAt
            });
          });
        }
        getPreferences() {
          return __async(this, null, function* () {
            const prefs = {
              feeds: {
                saved: void 0,
                pinned: void 0
              },
              feedViewPrefs: {
                home: __spreadValues({}, FEED_VIEW_PREF_DEFAULTS)
              },
              threadViewPrefs: __spreadValues({}, THREAD_VIEW_PREF_DEFAULTS),
              adultContentEnabled: false,
              contentLabels: {},
              birthDate: void 0
            };
            const res = yield this.app.bsky.actor.getPreferences({});
            for (const pref of res.data.preferences) {
              if (defs_exports5.isAdultContentPref(pref) && defs_exports5.validateAdultContentPref(pref).success) {
                prefs.adultContentEnabled = pref.enabled;
              } else if (defs_exports5.isContentLabelPref(pref) && defs_exports5.validateAdultContentPref(pref).success) {
                let value = pref.visibility;
                if (value === "show") {
                  value = "ignore";
                }
                if (value === "ignore" || value === "warn" || value === "hide") {
                  prefs.contentLabels[pref.label] = value;
                }
              } else if (defs_exports5.isSavedFeedsPref(pref) && defs_exports5.validateSavedFeedsPref(pref).success) {
                prefs.feeds.saved = pref.saved;
                prefs.feeds.pinned = pref.pinned;
              } else if (defs_exports5.isPersonalDetailsPref(pref) && defs_exports5.validatePersonalDetailsPref(pref).success) {
                if (pref.birthDate) {
                  prefs.birthDate = new Date(pref.birthDate);
                }
              } else if (defs_exports5.isFeedViewPref(pref) && defs_exports5.validateFeedViewPref(pref).success) {
                const _a2 = pref, { $type, feed } = _a2, v = __objRest(_a2, ["$type", "feed"]);
                prefs.feedViewPrefs[pref.feed] = __spreadValues(__spreadValues({}, FEED_VIEW_PREF_DEFAULTS), v);
              } else if (defs_exports5.isThreadViewPref(pref) && defs_exports5.validateThreadViewPref(pref).success) {
                const _b = pref, { $type } = _b, v = __objRest(_b, ["$type"]);
                prefs.threadViewPrefs = __spreadValues(__spreadValues({}, prefs.threadViewPrefs), v);
              }
            }
            return prefs;
          });
        }
        setSavedFeeds(saved, pinned) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, () => ({
              saved,
              pinned
            }));
          });
        }
        addSavedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: [...saved.filter((uri2) => uri2 !== v), v],
              pinned
            }));
          });
        }
        removeSavedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: saved.filter((uri2) => uri2 !== v),
              pinned: pinned.filter((uri2) => uri2 !== v)
            }));
          });
        }
        addPinnedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: [...saved.filter((uri2) => uri2 !== v), v],
              pinned: [...pinned.filter((uri2) => uri2 !== v), v]
            }));
          });
        }
        removePinnedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved,
              pinned: pinned.filter((uri2) => uri2 !== v)
            }));
          });
        }
        setAdultContentEnabled(v) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              let adultContentPref = prefs.findLast((pref) => defs_exports5.isAdultContentPref(pref) && defs_exports5.validateAdultContentPref(pref).success);
              if (adultContentPref) {
                adultContentPref.enabled = v;
              } else {
                adultContentPref = {
                  $type: "app.bsky.actor.defs#adultContentPref",
                  enabled: v
                };
              }
              return prefs.filter((pref) => !defs_exports5.isAdultContentPref(pref)).concat([adultContentPref]);
            });
          });
        }
        setContentLabelPref(key, value) {
          return __async(this, null, function* () {
            if (value === "show") {
              value = "ignore";
            }
            yield updatePreferences(this, (prefs) => {
              let labelPref = prefs.findLast((pref) => defs_exports5.isContentLabelPref(pref) && defs_exports5.validateAdultContentPref(pref).success && pref.label === key);
              if (labelPref) {
                labelPref.visibility = value;
              } else {
                labelPref = {
                  $type: "app.bsky.actor.defs#contentLabelPref",
                  label: key,
                  visibility: value
                };
              }
              return prefs.filter((pref) => !defs_exports5.isContentLabelPref(pref) || pref.label !== key).concat([labelPref]);
            });
          });
        }
        setPersonalDetails(_0) {
          return __async(this, arguments, function* ({
            birthDate
          }) {
            birthDate = birthDate instanceof Date ? birthDate.toISOString() : birthDate;
            yield updatePreferences(this, (prefs) => {
              let personalDetailsPref = prefs.findLast((pref) => defs_exports5.isPersonalDetailsPref(pref) && defs_exports5.validatePersonalDetailsPref(pref).success);
              if (personalDetailsPref) {
                personalDetailsPref.birthDate = birthDate;
              } else {
                personalDetailsPref = {
                  $type: "app.bsky.actor.defs#personalDetailsPref",
                  birthDate
                };
              }
              return prefs.filter((pref) => !defs_exports5.isPersonalDetailsPref(pref)).concat([personalDetailsPref]);
            });
          });
        }
        setFeedViewPrefs(feed, pref) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              const existing = prefs.findLast((pref2) => defs_exports5.isFeedViewPref(pref2) && defs_exports5.validateFeedViewPref(pref2).success && pref2.feed === feed);
              if (existing) {
                pref = __spreadValues(__spreadValues({}, existing), pref);
              }
              return prefs.filter((p) => !defs_exports5.isFeedViewPref(pref) || p.feed !== feed).concat([__spreadProps(__spreadValues({}, pref), { $type: "app.bsky.actor.defs#feedViewPref", feed })]);
            });
          });
        }
        setThreadViewPrefs(pref) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              const existing = prefs.findLast((pref2) => defs_exports5.isThreadViewPref(pref2) && defs_exports5.validateThreadViewPref(pref2).success);
              if (existing) {
                pref = __spreadValues(__spreadValues({}, existing), pref);
              }
              return prefs.filter((p) => !defs_exports5.isThreadViewPref(p)).concat([__spreadProps(__spreadValues({}, pref), { $type: "app.bsky.actor.defs#threadViewPref" })]);
            });
          });
        }
      };
      function updatePreferences(agent, cb) {
        return __async(this, null, function* () {
          const res = yield agent.app.bsky.actor.getPreferences({});
          const newPrefs = cb(res.data.preferences);
          if (newPrefs === false) {
            return;
          }
          yield agent.app.bsky.actor.putPreferences({
            preferences: newPrefs
          });
        });
      }
      function updateFeedPreferences(agent, cb) {
        return __async(this, null, function* () {
          let res;
          yield updatePreferences(agent, (prefs) => {
            let feedsPref = prefs.findLast((pref) => defs_exports5.isSavedFeedsPref(pref) && defs_exports5.validateSavedFeedsPref(pref).success);
            if (feedsPref) {
              res = cb(feedsPref.saved, feedsPref.pinned);
              feedsPref.saved = res.saved;
              feedsPref.pinned = res.pinned;
            } else {
              res = cb([], []);
              feedsPref = {
                $type: "app.bsky.actor.defs#savedFeedsPref",
                saved: res.saved,
                pinned: res.pinned
              };
            }
            return prefs.filter((pref) => !defs_exports5.isSavedFeedsPref(pref)).concat([feedsPref]);
          });
          return res;
        });
      }
    }
  });

  // lib/throttled-async-cache.js
  function throttledAsyncCache(call, { maxConcurrency = 3, interval = 100 } = {}) {
    const cache2 = multikeyMap();
    const outstandingRequests = /* @__PURE__ */ new Set();
    const waitingRequests = /* @__PURE__ */ new Set();
    var scheduleMoreLaterTimeout;
    throttledCall.prepopulate = prepopulate;
    throttledCall.evict = evict;
    return throttledCall;
    function prepopulate(value, ...args) {
      cache2.set(...args, { value });
    }
    function evict(...args) {
      cache2.delete(...args);
    }
    function throttledCall(...args) {
      let result = cache2.get(...args);
      if (result) {
        if (isPromise(result.value))
          result.priority++;
        return result.value;
      }
      let scheduleNow;
      const schedulePromise = new Promise((resolve) => scheduleNow = resolve);
      const entry = {
        priority: 0,
        value: invokeCall(),
        scheduleNow
      };
      cache2.set(...args, entry);
      waitingRequests.add(entry);
      scheduleAsAppropriate();
      return entry.value;
      function invokeCall() {
        return __async(this, null, function* () {
          yield schedulePromise;
          waitingRequests.delete(entry);
          outstandingRequests.add(entry);
          try {
            const result2 = yield call(...args);
            entry.value = result2;
            return result2;
          } finally {
            outstandingRequests.delete(entry);
            scheduleAsAppropriate();
          }
        });
      }
    }
    function scheduleAsAppropriate() {
      return __async(this, null, function* () {
        if (outstandingRequests.size >= maxConcurrency)
          return;
        if (interval) {
          yield new Promise((resolve) => setTimeout(resolve, interval));
          if (outstandingRequests.size >= maxConcurrency)
            return;
        }
        const nextRequest = [...waitingRequests].sort((a, b) => b.priority - a.priority)[0];
        if (!nextRequest)
          return;
        nextRequest.scheduleNow();
        if (outstandingRequests.size < maxConcurrency) {
          clearTimeout(scheduleMoreLaterTimeout);
          scheduleMoreLaterTimeout = setTimeout(scheduleAsAppropriate, interval || 100);
        }
      });
    }
  }
  function multikeyMap() {
    const storeMap = /* @__PURE__ */ new Map();
    const resultMap = {
      get,
      set,
      delete: deleteKeys,
      has,
      clear
    };
    return resultMap;
    function get(...keys) {
      let entry = storeMap;
      for (const key of keys) {
        entry = entry.get(key);
        if (!entry)
          return;
      }
      return entry._value;
    }
    function set(...keys) {
      let entry = storeMap;
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        entry = entry.get(key) || entry.set(key, /* @__PURE__ */ new Map()).get(key);
      }
      entry._value = keys[keys.length - 1];
      return resultMap;
    }
    function deleteKeys(...keys) {
      let entry = storeMap;
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        entry = entry.get(key);
        if (!entry)
          return false;
      }
      return entry.delete(keys[keys.length - 1]);
    }
    function has(...keys) {
      let entry = storeMap;
      for (const key of keys) {
        entry = entry.get(key);
        if (!entry)
          return false;
      }
      return true;
    }
    function clear() {
      return storeMap.clear();
    }
  }
  var init_throttled_async_cache = __esm({
    "lib/throttled-async-cache.js"() {
      init_is_promise();
    }
  });

  // lib/coldsky-agent.js
  function overrideFetch(baseFetch) {
    if (baseFetch._patchedFetch)
      return baseFetch;
    fetchOverride._patchedFetch = true;
    return fetchOverride;
    function fetchOverride(httpUri, httpMethod, httpHeaders, httpReqBody) {
      const useBskyNetwork = httpUri.indexOf("com.atproto.sync.listRepos") >= 0;
      const useHttpUri = useBskyNetwork ? "https://corsproxy.io/?" + httpUri.replace(BSKY_SOCIAL_URL, BSKY_NETWORK_URL) : httpUri;
      const qPos = useHttpUri.indexOf("?");
      const httpUriKey = qPos >= 0 ? useHttpUri.slice(0, qPos) : useHttpUri;
      const headersUnique = JSON.stringify(httpHeaders);
      const httpReqBodyUnique = JSON.stringify(httpReqBody);
      let cache2 = typedCaches[httpUriKey];
      if (!cache2) {
        cache2 = typedCaches[httpUriKey] = throttledAsyncCache(
          fetchWithBase,
          { maxConcurrency: 2, interval: 100 }
        );
      }
      return cache2(useHttpUri, httpMethod, headersUnique, httpReqBodyUnique);
      function fetchWithBase(httpUri2, httpMethod2, httpHeadersStringified, httpReqBodyStringified) {
        const startFetch = Date.now();
        const httpHeaders2 = typeof httpHeadersStringified === "undefined" ? void 0 : JSON.parse(httpHeadersStringified);
        const httpReqBody2 = typeof httpReqBodyStringified === "undefined" ? void 0 : JSON.parse(httpReqBodyStringified);
        return fetchWithRateHandling();
        function fetchWithRateHandling() {
          return baseFetch(httpUri2, httpMethod2, httpHeaders2, httpReqBody2).then(
            (result) => {
              setTimeout(() => {
                cache2.evict(httpUri2, httpMethod2, headersUnique, httpReqBodyUnique);
              }, httpMethod2 === "GET" ? 1e3 : 100);
              return result;
            },
            handleFetchError
          );
        }
        function handleFetchError(error) {
          if (/\brate\b/i.test(error.message || "")) {
            const waitTime = Math.min(
              Math.max(1e3, (Date.now() - startFetch) / 3),
              1e3
            );
            return new Promise((resolve) => setTimeout(resolve, waitTime)).then(() => fetchWithRateHandling());
          } else {
            setTimeout(() => {
              cache2.evict(httpUri2, httpMethod2, headersUnique, httpReqBodyUnique);
            }, 10);
            throw error;
          }
        }
      }
    }
  }
  var import_api, BSKY_SOCIAL_URL, BSKY_NETWORK_URL, ColdskyAgent, typedCaches;
  var init_coldsky_agent = __esm({
    "lib/coldsky-agent.js"() {
      import_api = __toESM(require_dist());
      init_throttled_async_cache();
      BSKY_SOCIAL_URL = "https://bsky.social/";
      BSKY_NETWORK_URL = "https://bsky.network/";
      ColdskyAgent = class extends import_api.BskyAgent {
        /** @param {Omit<ConstructorParameters<typeof BskyAgent>[0], 'service'>} args */
        constructor(args) {
          var _a2, _b;
          super(__spreadProps(__spreadValues({}, args), {
            // most of methods work fine on bsky.social
            service: BSKY_SOCIAL_URL
          }));
          for (const key in this.com.atproto) {
            const ns = this.com.atproto[key];
            const baseClient = (_b = (_a2 = ns._service) == null ? void 0 : _a2.xrpc) == null ? void 0 : _b.baseClient;
            if (baseClient)
              this.patchBaseClient(baseClient);
          }
        }
        /**
         * @param {typeof this.com.atproto.sync._service.xrpc.baseClient} baseClient 
         */
        patchBaseClient(baseClient) {
          baseClient.lex.assertValidXrpcOutput = function(lexUri, value, ...rest) {
            return true;
          };
          if (
            /** @type {*} */
            baseClient.fetch._patchedFetch
          )
            return;
          baseClient.fetch = overrideFetch(baseClient.fetch.bind(baseClient));
        }
      };
      typedCaches = {};
    }
  });

  // node_modules/cbor-x/decode.js
  function checkedRead() {
    try {
      let result = read();
      if (bundledStrings) {
        if (position >= bundledStrings.postBundlePosition) {
          let error = new Error("Unexpected bundle position");
          error.incomplete = true;
          throw error;
        }
        position = bundledStrings.postBundlePosition;
        bundledStrings = null;
      }
      if (position == srcEnd) {
        currentStructures = null;
        src = null;
        if (referenceMap)
          referenceMap = null;
      } else if (position > srcEnd) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      } else if (!sequentialMode) {
        throw new Error("Data read, but end of buffer not reached");
      }
      return result;
    } catch (error) {
      clearSource();
      if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
        error.incomplete = true;
      }
      throw error;
    }
  }
  function read() {
    let token = src[position++];
    let majorType = token >> 5;
    token = token & 31;
    if (token > 23) {
      switch (token) {
        case 24:
          token = src[position++];
          break;
        case 25:
          if (majorType == 7) {
            return getFloat16();
          }
          token = dataView.getUint16(position);
          position += 2;
          break;
        case 26:
          if (majorType == 7) {
            let value = dataView.getFloat32(position);
            if (currentDecoder.useFloat32 > 2) {
              let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
              position += 4;
              return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
            }
            position += 4;
            return value;
          }
          token = dataView.getUint32(position);
          position += 4;
          break;
        case 27:
          if (majorType == 7) {
            let value = dataView.getFloat64(position);
            position += 8;
            return value;
          }
          if (majorType > 1) {
            if (dataView.getUint32(position) > 0)
              throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
            token = dataView.getUint32(position + 4);
          } else if (currentDecoder.int64AsNumber) {
            token = dataView.getUint32(position) * 4294967296;
            token += dataView.getUint32(position + 4);
          } else
            token = dataView.getBigUint64(position);
          position += 8;
          break;
        case 31:
          switch (majorType) {
            case 2:
            case 3:
              throw new Error("Indefinite length not supported for byte or text strings");
            case 4:
              let array = [];
              let value, i = 0;
              while ((value = read()) != STOP_CODE) {
                array[i++] = value;
              }
              return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
            case 5:
              let key;
              if (currentDecoder.mapsAsObjects) {
                let object = {};
                if (currentDecoder.keyMap)
                  while ((key = read()) != STOP_CODE)
                    object[safeKey(currentDecoder.decodeKey(key))] = read();
                else
                  while ((key = read()) != STOP_CODE)
                    object[safeKey(key)] = read();
                return object;
              } else {
                if (restoreMapsAsObject) {
                  currentDecoder.mapsAsObjects = true;
                  restoreMapsAsObject = false;
                }
                let map = /* @__PURE__ */ new Map();
                if (currentDecoder.keyMap)
                  while ((key = read()) != STOP_CODE)
                    map.set(currentDecoder.decodeKey(key), read());
                else
                  while ((key = read()) != STOP_CODE)
                    map.set(key, read());
                return map;
              }
            case 7:
              return STOP_CODE;
            default:
              throw new Error("Invalid major type for indefinite length " + majorType);
          }
        default:
          throw new Error("Unknown token " + token);
      }
    }
    switch (majorType) {
      case 0:
        return token;
      case 1:
        return ~token;
      case 2:
        return readBin(token);
      case 3:
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
        }
        if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
          let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
          if (string != null)
            return string;
        }
        return readFixedString(token);
      case 4:
        let array = new Array(token);
        for (let i = 0; i < token; i++)
          array[i] = read();
        return array;
      case 5:
        if (currentDecoder.mapsAsObjects) {
          let object = {};
          if (currentDecoder.keyMap)
            for (let i = 0; i < token; i++)
              object[safeKey(currentDecoder.decodeKey(read()))] = read();
          else
            for (let i = 0; i < token; i++)
              object[safeKey(read())] = read();
          return object;
        } else {
          if (restoreMapsAsObject) {
            currentDecoder.mapsAsObjects = true;
            restoreMapsAsObject = false;
          }
          let map = /* @__PURE__ */ new Map();
          if (currentDecoder.keyMap)
            for (let i = 0; i < token; i++)
              map.set(currentDecoder.decodeKey(read()), read());
          else
            for (let i = 0; i < token; i++)
              map.set(read(), read());
          return map;
        }
      case 6:
        if (token >= BUNDLED_STRINGS_ID) {
          let structure = currentStructures[token & 8191];
          if (structure) {
            if (!structure.read)
              structure.read = createStructureReader(structure);
            return structure.read();
          }
          if (token < 65536) {
            if (token == RECORD_INLINE_ID) {
              let length2 = readJustLength();
              let id = read();
              let structure2 = read();
              recordDefinition(id, structure2);
              let object = {};
              if (currentDecoder.keyMap)
                for (let i = 2; i < length2; i++) {
                  let key = currentDecoder.decodeKey(structure2[i - 2]);
                  object[safeKey(key)] = read();
                }
              else
                for (let i = 2; i < length2; i++) {
                  let key = structure2[i - 2];
                  object[safeKey(key)] = read();
                }
              return object;
            } else if (token == RECORD_DEFINITIONS_ID) {
              let length2 = readJustLength();
              let id = read();
              for (let i = 2; i < length2; i++) {
                recordDefinition(id++, read());
              }
              return read();
            } else if (token == BUNDLED_STRINGS_ID) {
              return readBundleExt();
            }
            if (currentDecoder.getShared) {
              loadShared();
              structure = currentStructures[token & 8191];
              if (structure) {
                if (!structure.read)
                  structure.read = createStructureReader(structure);
                return structure.read();
              }
            }
          }
        }
        let extension = currentExtensions[token];
        if (extension) {
          if (extension.handlesRead)
            return extension(read);
          else
            return extension(read());
        } else {
          let input = read();
          for (let i = 0; i < currentExtensionRanges.length; i++) {
            let value = currentExtensionRanges[i](token, input);
            if (value !== void 0)
              return value;
          }
          return new Tag(input, token);
        }
      case 7:
        switch (token) {
          case 20:
            return false;
          case 21:
            return true;
          case 22:
            return null;
          case 23:
            return;
          case 31:
          default:
            let packedValue = (packedValues || getPackedValues())[token];
            if (packedValue !== void 0)
              return packedValue;
            throw new Error("Unknown token " + token);
        }
      default:
        if (isNaN(token)) {
          let error = new Error("Unexpected end of CBOR data");
          error.incomplete = true;
          throw error;
        }
        throw new Error("Unknown CBOR token " + token);
    }
  }
  function createStructureReader(structure) {
    function readObject() {
      let length2 = src[position++];
      length2 = length2 & 31;
      if (length2 > 23) {
        switch (length2) {
          case 24:
            length2 = src[position++];
            break;
          case 25:
            length2 = dataView.getUint16(position);
            position += 2;
            break;
          case 26:
            length2 = dataView.getUint32(position);
            position += 4;
            break;
          default:
            throw new Error("Expected array header, but got " + src[position - 1]);
        }
      }
      let compiledReader = this.compiledReader;
      while (compiledReader) {
        if (compiledReader.propertyCount === length2)
          return compiledReader(read);
        compiledReader = compiledReader.next;
      }
      if (this.slowReads++ >= inlineObjectReadThreshold) {
        let array = this.length == length2 ? this : this.slice(0, length2);
        compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
        if (this.compiledReader)
          compiledReader.next = this.compiledReader;
        compiledReader.propertyCount = length2;
        this.compiledReader = compiledReader;
        return compiledReader(read);
      }
      let object = {};
      if (currentDecoder.keyMap)
        for (let i = 0; i < length2; i++)
          object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
      else
        for (let i = 0; i < length2; i++) {
          object[safeKey(this[i])] = read();
        }
      return object;
    }
    structure.slowReads = 0;
    return readObject;
  }
  function safeKey(key) {
    if (typeof key === "string")
      return key === "__proto__" ? "__proto_" : key;
    if (typeof key !== "object")
      return key.toString();
    throw new Error("Invalid property name type " + typeof key);
  }
  function readStringJS(length2) {
    let result;
    if (length2 < 16) {
      if (result = shortStringInJS(length2))
        return result;
    }
    if (length2 > 64 && decoder)
      return decoder.decode(src.subarray(position, position += length2));
    const end = position + length2;
    const units = [];
    result = "";
    while (position < end) {
      const byte1 = src[position++];
      if ((byte1 & 128) === 0) {
        units.push(byte1);
      } else if ((byte1 & 224) === 192) {
        const byte2 = src[position++] & 63;
        units.push((byte1 & 31) << 6 | byte2);
      } else if ((byte1 & 240) === 224) {
        const byte2 = src[position++] & 63;
        const byte3 = src[position++] & 63;
        units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
      } else if ((byte1 & 248) === 240) {
        const byte2 = src[position++] & 63;
        const byte3 = src[position++] & 63;
        const byte4 = src[position++] & 63;
        let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (unit > 65535) {
          unit -= 65536;
          units.push(unit >>> 10 & 1023 | 55296);
          unit = 56320 | unit & 1023;
        }
        units.push(unit);
      } else {
        units.push(byte1);
      }
      if (units.length >= 4096) {
        result += fromCharCode.apply(String, units);
        units.length = 0;
      }
    }
    if (units.length > 0) {
      result += fromCharCode.apply(String, units);
    }
    return result;
  }
  function longStringInJS(length2) {
    let start = position;
    let bytes = new Array(length2);
    for (let i = 0; i < length2; i++) {
      const byte = src[position++];
      if ((byte & 128) > 0) {
        position = start;
        return;
      }
      bytes[i] = byte;
    }
    return fromCharCode.apply(String, bytes);
  }
  function shortStringInJS(length2) {
    if (length2 < 4) {
      if (length2 < 2) {
        if (length2 === 0)
          return "";
        else {
          let a = src[position++];
          if ((a & 128) > 1) {
            position -= 1;
            return;
          }
          return fromCharCode(a);
        }
      } else {
        let a = src[position++];
        let b = src[position++];
        if ((a & 128) > 0 || (b & 128) > 0) {
          position -= 2;
          return;
        }
        if (length2 < 3)
          return fromCharCode(a, b);
        let c = src[position++];
        if ((c & 128) > 0) {
          position -= 3;
          return;
        }
        return fromCharCode(a, b, c);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      let c = src[position++];
      let d = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
        position -= 4;
        return;
      }
      if (length2 < 6) {
        if (length2 === 4)
          return fromCharCode(a, b, c, d);
        else {
          let e = src[position++];
          if ((e & 128) > 0) {
            position -= 5;
            return;
          }
          return fromCharCode(a, b, c, d, e);
        }
      } else if (length2 < 8) {
        let e = src[position++];
        let f = src[position++];
        if ((e & 128) > 0 || (f & 128) > 0) {
          position -= 6;
          return;
        }
        if (length2 < 7)
          return fromCharCode(a, b, c, d, e, f);
        let g = src[position++];
        if ((g & 128) > 0) {
          position -= 7;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g);
      } else {
        let e = src[position++];
        let f = src[position++];
        let g = src[position++];
        let h = src[position++];
        if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
          position -= 8;
          return;
        }
        if (length2 < 10) {
          if (length2 === 8)
            return fromCharCode(a, b, c, d, e, f, g, h);
          else {
            let i = src[position++];
            if ((i & 128) > 0) {
              position -= 9;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i);
          }
        } else if (length2 < 12) {
          let i = src[position++];
          let j = src[position++];
          if ((i & 128) > 0 || (j & 128) > 0) {
            position -= 10;
            return;
          }
          if (length2 < 11)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j);
          let k = src[position++];
          if ((k & 128) > 0) {
            position -= 11;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
        } else {
          let i = src[position++];
          let j = src[position++];
          let k = src[position++];
          let l = src[position++];
          if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
            position -= 12;
            return;
          }
          if (length2 < 14) {
            if (length2 === 12)
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
            else {
              let m = src[position++];
              if ((m & 128) > 0) {
                position -= 13;
                return;
              }
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
            }
          } else {
            let m = src[position++];
            let n = src[position++];
            if ((m & 128) > 0 || (n & 128) > 0) {
              position -= 14;
              return;
            }
            if (length2 < 15)
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
            let o = src[position++];
            if ((o & 128) > 0) {
              position -= 15;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
          }
        }
      }
    }
  }
  function readBin(length2) {
    return currentDecoder.copyBuffers ? (
      // specifically use the copying slice (not the node one)
      Uint8Array.prototype.slice.call(src, position, position += length2)
    ) : src.subarray(position, position += length2);
  }
  function getFloat16() {
    let byte0 = src[position++];
    let byte1 = src[position++];
    let exponent = (byte0 & 127) >> 2;
    if (exponent === 31) {
      if (byte1 || byte0 & 3)
        return NaN;
      return byte0 & 128 ? -Infinity : Infinity;
    }
    if (exponent === 0) {
      let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
      return byte0 & 128 ? -abs : abs;
    }
    u8Array[3] = byte0 & 128 | // sign bit
    (exponent >> 1) + 56;
    u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
    byte1 >> 3;
    u8Array[1] = byte1 << 5;
    u8Array[0] = 0;
    return f32Array[0];
  }
  function combine(a, b) {
    if (typeof a === "string")
      return a + b;
    if (a instanceof Array)
      return a.concat(b);
    return Object.assign({}, a, b);
  }
  function getPackedValues() {
    if (!packedValues) {
      if (currentDecoder.getShared)
        loadShared();
      else
        throw new Error("No packed values available");
    }
    return packedValues;
  }
  function registerTypedArray(TypedArray, tag) {
    let dvMethod = "get" + TypedArray.name.slice(0, -5);
    let bytesPerElement;
    if (typeof TypedArray === "function")
      bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
    else
      TypedArray = null;
    for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
      if (!littleEndian && bytesPerElement == 1)
        continue;
      let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
      currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer2) => {
        if (!TypedArray)
          throw new Error("Could not find typed array for code " + tag);
        if (!currentDecoder.copyBuffers) {
          if (bytesPerElement === 1 || bytesPerElement === 2 && !(buffer2.byteOffset & 1) || bytesPerElement === 4 && !(buffer2.byteOffset & 3) || bytesPerElement === 8 && !(buffer2.byteOffset & 7))
            return new TypedArray(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
        }
        return new TypedArray(Uint8Array.prototype.slice.call(buffer2, 0).buffer);
      } : (buffer2) => {
        if (!TypedArray)
          throw new Error("Could not find typed array for code " + tag);
        let dv = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
        let elements = buffer2.length >> sizeShift;
        let ta = new TypedArray(elements);
        let method = dv[dvMethod];
        for (let i = 0; i < elements; i++) {
          ta[i] = method.call(dv, i << sizeShift, littleEndian);
        }
        return ta;
      };
    }
  }
  function readBundleExt() {
    let length2 = readJustLength();
    let bundlePosition = position + read();
    for (let i = 2; i < length2; i++) {
      let bundleLength = readJustLength();
      position += bundleLength;
    }
    let dataPosition = position;
    position = bundlePosition;
    bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
    bundledStrings.position0 = 0;
    bundledStrings.position1 = 0;
    bundledStrings.postBundlePosition = position;
    position = dataPosition;
    return read();
  }
  function readJustLength() {
    let token = src[position++] & 31;
    if (token > 23) {
      switch (token) {
        case 24:
          token = src[position++];
          break;
        case 25:
          token = dataView.getUint16(position);
          position += 2;
          break;
        case 26:
          token = dataView.getUint32(position);
          position += 4;
          break;
      }
    }
    return token;
  }
  function loadShared() {
    if (currentDecoder.getShared) {
      let sharedData = saveState(() => {
        src = null;
        return currentDecoder.getShared();
      }) || {};
      let updatedStructures = sharedData.structures || [];
      currentDecoder.sharedVersion = sharedData.version;
      packedValues = currentDecoder.sharedValues = sharedData.packedValues;
      if (currentStructures === true)
        currentDecoder.structures = currentStructures = updatedStructures;
      else
        currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
  function saveState(callback) {
    let savedSrcEnd = srcEnd;
    let savedPosition = position;
    let savedStringPosition = stringPosition;
    let savedSrcStringStart = srcStringStart;
    let savedSrcStringEnd = srcStringEnd;
    let savedSrcString = srcString;
    let savedStrings = strings;
    let savedReferenceMap = referenceMap;
    let savedBundledStrings = bundledStrings;
    let savedSrc = new Uint8Array(src.slice(0, srcEnd));
    let savedStructures = currentStructures;
    let savedDecoder = currentDecoder;
    let savedSequentialMode = sequentialMode;
    let value = callback();
    srcEnd = savedSrcEnd;
    position = savedPosition;
    stringPosition = savedStringPosition;
    srcStringStart = savedSrcStringStart;
    srcStringEnd = savedSrcStringEnd;
    srcString = savedSrcString;
    strings = savedStrings;
    referenceMap = savedReferenceMap;
    bundledStrings = savedBundledStrings;
    src = savedSrc;
    sequentialMode = savedSequentialMode;
    currentStructures = savedStructures;
    currentDecoder = savedDecoder;
    dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
    return value;
  }
  function clearSource() {
    src = null;
    referenceMap = null;
    currentStructures = null;
  }
  function addExtension(extension) {
    currentExtensions[extension.tag] = extension.decode;
  }
  var decoder, src, srcEnd, position, EMPTY_ARRAY, LEGACY_RECORD_INLINE_ID, RECORD_DEFINITIONS_ID, RECORD_INLINE_ID, BUNDLED_STRINGS_ID, PACKED_REFERENCE_TAG_ID, STOP_CODE, strings, stringPosition, currentDecoder, currentStructures, srcString, srcStringStart, srcStringEnd, bundledStrings, referenceMap, currentExtensions, currentExtensionRanges, packedValues, dataView, restoreMapsAsObject, defaultOptions, sequentialMode, inlineObjectReadThreshold, Decoder, validName, readFixedString, fromCharCode, f32Array, u8Array, keyCache, Tag, recordDefinition, glbl, packedTable, SHARED_DATA_TAG_ID, isLittleEndianMachine, typedArrays, typedArrayTags, mult10, defaultDecoder, decode, decodeMultiple, FLOAT32_OPTIONS;
  var init_decode = __esm({
    "node_modules/cbor-x/decode.js"() {
      try {
        decoder = new TextDecoder();
      } catch (error) {
      }
      position = 0;
      EMPTY_ARRAY = [];
      LEGACY_RECORD_INLINE_ID = 105;
      RECORD_DEFINITIONS_ID = 57342;
      RECORD_INLINE_ID = 57343;
      BUNDLED_STRINGS_ID = 57337;
      PACKED_REFERENCE_TAG_ID = 6;
      STOP_CODE = {};
      strings = EMPTY_ARRAY;
      stringPosition = 0;
      currentDecoder = {};
      srcStringStart = 0;
      srcStringEnd = 0;
      currentExtensions = [];
      currentExtensionRanges = [];
      defaultOptions = {
        useRecords: false,
        mapsAsObjects: true
      };
      sequentialMode = false;
      inlineObjectReadThreshold = 2;
      try {
        new Function("");
      } catch (error) {
        inlineObjectReadThreshold = Infinity;
      }
      Decoder = class _Decoder {
        constructor(options) {
          if (options) {
            if ((options.keyMap || options._keyMap) && !options.useRecords) {
              options.useRecords = false;
              options.mapsAsObjects = true;
            }
            if (options.useRecords === false && options.mapsAsObjects === void 0)
              options.mapsAsObjects = true;
            if (options.getStructures)
              options.getShared = options.getStructures;
            if (options.getShared && !options.structures)
              (options.structures = []).uninitialized = true;
            if (options.keyMap) {
              this.mapKey = /* @__PURE__ */ new Map();
              for (let [k, v] of Object.entries(options.keyMap))
                this.mapKey.set(v, k);
            }
          }
          Object.assign(this, options);
        }
        /*
        decodeKey(key) {
        	return this.keyMap
        		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
        		: key
        }
        */
        decodeKey(key) {
          return this.keyMap ? this.mapKey.get(key) || key : key;
        }
        encodeKey(key) {
          return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
        }
        encodeKeys(rec) {
          if (!this._keyMap)
            return rec;
          let map = /* @__PURE__ */ new Map();
          for (let [k, v] of Object.entries(rec))
            map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
          return map;
        }
        decodeKeys(map) {
          if (!this._keyMap || map.constructor.name != "Map")
            return map;
          if (!this._mapKey) {
            this._mapKey = /* @__PURE__ */ new Map();
            for (let [k, v] of Object.entries(this._keyMap))
              this._mapKey.set(v, k);
          }
          let res = {};
          map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
          return res;
        }
        mapDecode(source, end) {
          let res = this.decode(source);
          if (this._keyMap) {
            switch (res.constructor.name) {
              case "Array":
                return res.map((r) => this.decodeKeys(r));
            }
          }
          return res;
        }
        decode(source, end) {
          if (src) {
            return saveState(() => {
              clearSource();
              return this ? this.decode(source, end) : _Decoder.prototype.decode.call(defaultOptions, source, end);
            });
          }
          srcEnd = end > -1 ? end : source.length;
          position = 0;
          stringPosition = 0;
          srcStringEnd = 0;
          srcString = null;
          strings = EMPTY_ARRAY;
          bundledStrings = null;
          src = source;
          try {
            dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
          } catch (error) {
            src = null;
            if (source instanceof Uint8Array)
              throw error;
            throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
          }
          if (this instanceof _Decoder) {
            currentDecoder = this;
            packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
            if (this.structures) {
              currentStructures = this.structures;
              return checkedRead();
            } else if (!currentStructures || currentStructures.length > 0) {
              currentStructures = [];
            }
          } else {
            currentDecoder = defaultOptions;
            if (!currentStructures || currentStructures.length > 0)
              currentStructures = [];
            packedValues = null;
          }
          return checkedRead();
        }
        decodeMultiple(source, forEach) {
          let values, lastPosition = 0;
          try {
            let size = source.length;
            sequentialMode = true;
            let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
            if (forEach) {
              if (forEach(value) === false) {
                return;
              }
              while (position < size) {
                lastPosition = position;
                if (forEach(checkedRead()) === false) {
                  return;
                }
              }
            } else {
              values = [value];
              while (position < size) {
                lastPosition = position;
                values.push(checkedRead());
              }
              return values;
            }
          } catch (error) {
            error.lastPosition = lastPosition;
            error.values = values;
            throw error;
          } finally {
            sequentialMode = false;
            clearSource();
          }
        }
      };
      validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
      readFixedString = readStringJS;
      fromCharCode = String.fromCharCode;
      f32Array = new Float32Array(1);
      u8Array = new Uint8Array(f32Array.buffer, 0, 4);
      keyCache = new Array(4096);
      Tag = class {
        constructor(value, tag) {
          this.value = value;
          this.tag = tag;
        }
      };
      currentExtensions[0] = (dateString) => {
        return new Date(dateString);
      };
      currentExtensions[1] = (epochSec) => {
        return new Date(Math.round(epochSec * 1e3));
      };
      currentExtensions[2] = (buffer2) => {
        let value = BigInt(0);
        for (let i = 0, l = buffer2.byteLength; i < l; i++) {
          value = BigInt(buffer2[i]) + value << BigInt(8);
        }
        return value;
      };
      currentExtensions[3] = (buffer2) => {
        return BigInt(-1) - currentExtensions[2](buffer2);
      };
      currentExtensions[4] = (fraction) => {
        return +(fraction[1] + "e" + fraction[0]);
      };
      currentExtensions[5] = (fraction) => {
        return fraction[1] * Math.exp(fraction[0] * Math.log(2));
      };
      recordDefinition = (id, structure) => {
        id = id - 57344;
        let existingStructure = currentStructures[id];
        if (existingStructure && existingStructure.isShared) {
          (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
        }
        currentStructures[id] = structure;
        structure.read = createStructureReader(structure);
      };
      currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
        let length2 = data.length;
        let structure = data[1];
        recordDefinition(data[0], structure);
        let object = {};
        for (let i = 2; i < length2; i++) {
          let key = structure[i - 2];
          object[safeKey(key)] = data[i];
        }
        return object;
      };
      currentExtensions[14] = (value) => {
        if (bundledStrings)
          return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
        return new Tag(value, 14);
      };
      currentExtensions[15] = (value) => {
        if (bundledStrings)
          return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
        return new Tag(value, 15);
      };
      glbl = { Error, RegExp };
      currentExtensions[27] = (data) => {
        return (glbl[data[0]] || Error)(data[1], data[2]);
      };
      packedTable = (read3) => {
        if (src[position++] != 132) {
          let error = new Error("Packed values structure must be followed by a 4 element array");
          if (src.length < position)
            error.incomplete = true;
          throw error;
        }
        let newPackedValues = read3();
        if (!newPackedValues || !newPackedValues.length) {
          let error = new Error("Packed values structure must be followed by a 4 element array");
          error.incomplete = true;
          throw error;
        }
        packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
        packedValues.prefixes = read3();
        packedValues.suffixes = read3();
        return read3();
      };
      packedTable.handlesRead = true;
      currentExtensions[51] = packedTable;
      currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
        if (!packedValues) {
          if (currentDecoder.getShared)
            loadShared();
          else
            return new Tag(data, PACKED_REFERENCE_TAG_ID);
        }
        if (typeof data == "number")
          return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
        let error = new Error("No support for non-integer packed references yet");
        if (data === void 0)
          error.incomplete = true;
        throw error;
      };
      currentExtensions[28] = (read3) => {
        if (!referenceMap) {
          referenceMap = /* @__PURE__ */ new Map();
          referenceMap.id = 0;
        }
        let id = referenceMap.id++;
        let token = src[position];
        let target2;
        if (token >> 5 == 4)
          target2 = [];
        else
          target2 = {};
        let refEntry = { target: target2 };
        referenceMap.set(id, refEntry);
        let targetProperties = read3();
        if (refEntry.used)
          return Object.assign(target2, targetProperties);
        refEntry.target = targetProperties;
        return targetProperties;
      };
      currentExtensions[28].handlesRead = true;
      currentExtensions[29] = (id) => {
        let refEntry = referenceMap.get(id);
        refEntry.used = true;
        return refEntry.target;
      };
      currentExtensions[258] = (array) => new Set(array);
      (currentExtensions[259] = (read3) => {
        if (currentDecoder.mapsAsObjects) {
          currentDecoder.mapsAsObjects = false;
          restoreMapsAsObject = true;
        }
        return read3();
      }).handlesRead = true;
      SHARED_DATA_TAG_ID = 1399353956;
      currentExtensionRanges.push((tag, input) => {
        if (tag >= 225 && tag <= 255)
          return combine(getPackedValues().prefixes[tag - 224], input);
        if (tag >= 28704 && tag <= 32767)
          return combine(getPackedValues().prefixes[tag - 28672], input);
        if (tag >= 1879052288 && tag <= 2147483647)
          return combine(getPackedValues().prefixes[tag - 1879048192], input);
        if (tag >= 216 && tag <= 223)
          return combine(input, getPackedValues().suffixes[tag - 216]);
        if (tag >= 27647 && tag <= 28671)
          return combine(input, getPackedValues().suffixes[tag - 27639]);
        if (tag >= 1811940352 && tag <= 1879048191)
          return combine(input, getPackedValues().suffixes[tag - 1811939328]);
        if (tag == SHARED_DATA_TAG_ID) {
          return {
            packedValues,
            structures: currentStructures.slice(0),
            version: input
          };
        }
        if (tag == 55799)
          return input;
      });
      isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
      typedArrays = [
        Uint8Array,
        Uint8ClampedArray,
        Uint16Array,
        Uint32Array,
        typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
        Int8Array,
        Int16Array,
        Int32Array,
        typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
        Float32Array,
        Float64Array
      ];
      typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
      for (let i = 0; i < typedArrays.length; i++) {
        registerTypedArray(typedArrays[i], typedArrayTags[i]);
      }
      mult10 = new Array(147);
      for (let i = 0; i < 256; i++) {
        mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
      }
      defaultDecoder = new Decoder({ useRecords: false });
      decode = defaultDecoder.decode;
      decodeMultiple = defaultDecoder.decodeMultiple;
      FLOAT32_OPTIONS = {
        NEVER: 0,
        ALWAYS: 1,
        DECIMAL_ROUND: 3,
        DECIMAL_FIT: 4
      };
    }
  });

  // node_modules/cbor-x/encode.js
  function writeEntityLength(length2, majorValue) {
    if (length2 < 24)
      target[position2++] = majorValue | length2;
    else if (length2 < 256) {
      target[position2++] = majorValue | 24;
      target[position2++] = length2;
    } else if (length2 < 65536) {
      target[position2++] = majorValue | 25;
      target[position2++] = length2 >> 8;
      target[position2++] = length2 & 255;
    } else {
      target[position2++] = majorValue | 26;
      targetView.setUint32(position2, length2);
      position2 += 4;
    }
  }
  function writeArrayHeader(length2) {
    if (length2 < 24)
      target[position2++] = 128 | length2;
    else if (length2 < 256) {
      target[position2++] = 152;
      target[position2++] = length2;
    } else if (length2 < 65536) {
      target[position2++] = 153;
      target[position2++] = length2 >> 8;
      target[position2++] = length2 & 255;
    } else {
      target[position2++] = 154;
      targetView.setUint32(position2, length2);
      position2 += 4;
    }
  }
  function isBlob(object) {
    if (object instanceof BlobConstructor)
      return true;
    let tag = object[Symbol.toStringTag];
    return tag === "Blob" || tag === "File";
  }
  function findRepetitiveStrings(value, packedValues2) {
    switch (typeof value) {
      case "string":
        if (value.length > 3) {
          if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
            return;
          let packedStatus = packedValues2.get(value);
          if (packedStatus) {
            if (++packedStatus.count == 2) {
              packedValues2.values.push(value);
            }
          } else {
            packedValues2.set(value, {
              count: 1
            });
            if (packedValues2.samplingPackedValues) {
              let status = packedValues2.samplingPackedValues.get(value);
              if (status)
                status.count++;
              else
                packedValues2.samplingPackedValues.set(value, {
                  count: 1
                });
            }
          }
        }
        break;
      case "object":
        if (value) {
          if (value instanceof Array) {
            for (let i = 0, l = value.length; i < l; i++) {
              findRepetitiveStrings(value[i], packedValues2);
            }
          } else {
            let includeKeys = !packedValues2.encoder.useRecords;
            for (var key in value) {
              if (value.hasOwnProperty(key)) {
                if (includeKeys)
                  findRepetitiveStrings(key, packedValues2);
                findRepetitiveStrings(value[key], packedValues2);
              }
            }
          }
        }
        break;
      case "function":
        console.log(value);
    }
  }
  function typedArrayEncoder(tag, size) {
    if (!isLittleEndianMachine2 && size > 1)
      tag -= 4;
    return {
      tag,
      encode: function writeExtBuffer(typedArray, encode5) {
        let length2 = typedArray.byteLength;
        let offset = typedArray.byteOffset || 0;
        let buffer2 = typedArray.buffer || typedArray;
        encode5(hasNodeBuffer ? Buffer2.from(buffer2, offset, length2) : new Uint8Array(buffer2, offset, length2));
      }
    };
  }
  function writeBuffer(buffer2, makeRoom) {
    let length2 = buffer2.byteLength;
    if (length2 < 24) {
      target[position2++] = 64 + length2;
    } else if (length2 < 256) {
      target[position2++] = 88;
      target[position2++] = length2;
    } else if (length2 < 65536) {
      target[position2++] = 89;
      target[position2++] = length2 >> 8;
      target[position2++] = length2 & 255;
    } else {
      target[position2++] = 90;
      targetView.setUint32(position2, length2);
      position2 += 4;
    }
    if (position2 + length2 >= target.length) {
      makeRoom(position2 + length2);
    }
    target.set(buffer2.buffer ? buffer2 : new Uint8Array(buffer2), position2);
    position2 += length2;
  }
  function insertIds(serialized, idsToInsert) {
    let nextId;
    let distanceToMove = idsToInsert.length * 2;
    let lastEnd = serialized.length - distanceToMove;
    idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
    for (let id = 0; id < idsToInsert.length; id++) {
      let referee = idsToInsert[id];
      referee.id = id;
      for (let position3 of referee.references) {
        serialized[position3++] = id >> 8;
        serialized[position3] = id & 255;
      }
    }
    while (nextId = idsToInsert.pop()) {
      let offset = nextId.offset;
      serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
      distanceToMove -= 2;
      let position3 = offset + distanceToMove;
      serialized[position3++] = 216;
      serialized[position3++] = 28;
      lastEnd = offset;
    }
    return serialized;
  }
  function writeBundles(start, encode5) {
    targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);
    let writeStrings = bundledStrings2;
    bundledStrings2 = null;
    encode5(writeStrings[0]);
    encode5(writeStrings[1]);
  }
  function addExtension2(extension) {
    if (extension.Class) {
      if (!extension.encode)
        throw new Error("Extension has no encode function");
      extensionClasses.unshift(extension.Class);
      extensions.unshift(extension);
    }
    addExtension(extension);
  }
  var textEncoder, extensions, extensionClasses, Buffer2, hasNodeBuffer, ByteArrayAllocate, ByteArray, MAX_STRUCTURES, MAX_BUFFER_SIZE, throwOnIterable, target, targetView, position2, safeEnd, bundledStrings2, MAX_BUNDLE_SIZE, hasNonLatin, RECORD_SYMBOL, Encoder, SharedData, BlobConstructor, isLittleEndianMachine2, defaultEncoder, encode, encodeAsIterable, encodeAsAsyncIterable, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE, RESET_BUFFER_MODE, THROW_ON_ITERABLE;
  var init_encode = __esm({
    "node_modules/cbor-x/encode.js"() {
      init_decode();
      init_decode();
      init_decode();
      try {
        textEncoder = new TextEncoder();
      } catch (error) {
      }
      Buffer2 = typeof globalThis === "object" && globalThis.Buffer;
      hasNodeBuffer = typeof Buffer2 !== "undefined";
      ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;
      ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;
      MAX_STRUCTURES = 256;
      MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
      position2 = 0;
      bundledStrings2 = null;
      MAX_BUNDLE_SIZE = 61440;
      hasNonLatin = /[\u0080-\uFFFF]/;
      RECORD_SYMBOL = Symbol("record-id");
      Encoder = class extends Decoder {
        constructor(options) {
          super(options);
          this.offset = 0;
          let typeBuffer;
          let start;
          let sharedStructures;
          let hasSharedUpdate;
          let structures;
          let referenceMap2;
          options = options || {};
          let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position3, maxBytes) {
            return target.utf8Write(string, position3, maxBytes);
          } : textEncoder && textEncoder.encodeInto ? function(string, position3) {
            return textEncoder.encodeInto(string, target.subarray(position3)).written;
          } : false;
          let encoder = this;
          let hasSharedStructures = options.structures || options.saveStructures;
          let maxSharedStructures = options.maxSharedStructures;
          if (maxSharedStructures == null)
            maxSharedStructures = hasSharedStructures ? 128 : 0;
          if (maxSharedStructures > 8190)
            throw new Error("Maximum maxSharedStructure is 8190");
          let isSequential = options.sequential;
          if (isSequential) {
            maxSharedStructures = 0;
          }
          if (!this.structures)
            this.structures = [];
          if (this.saveStructures)
            this.saveShared = this.saveStructures;
          let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;
          let sharedPackedObjectMap2;
          if (sharedValues) {
            sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
            for (let i = 0, l = sharedValues.length; i < l; i++) {
              sharedPackedObjectMap2[sharedValues[i]] = i;
            }
          }
          let recordIdsToRemove = [];
          let transitionsCount = 0;
          let serializationsSinceTransitionRebuild = 0;
          this.mapEncode = function(value, encodeOptions) {
            if (this._keyMap && !this._mapped) {
              switch (value.constructor.name) {
                case "Array":
                  value = value.map((r) => this.encodeKeys(r));
                  break;
              }
            }
            return this.encode(value, encodeOptions);
          };
          this.encode = function(value, encodeOptions) {
            if (!target) {
              target = new ByteArrayAllocate(8192);
              targetView = new DataView(target.buffer, 0, 8192);
              position2 = 0;
            }
            safeEnd = target.length - 10;
            if (safeEnd - position2 < 2048) {
              target = new ByteArrayAllocate(target.length);
              targetView = new DataView(target.buffer, 0, target.length);
              safeEnd = target.length - 10;
              position2 = 0;
            } else if (encodeOptions === REUSE_BUFFER_MODE)
              position2 = position2 + 7 & 2147483640;
            start = position2;
            if (encoder.useSelfDescribedHeader) {
              targetView.setUint32(position2, 3654940416);
              position2 += 3;
            }
            referenceMap2 = encoder.structuredClone ? /* @__PURE__ */ new Map() : null;
            if (encoder.bundleStrings && typeof value !== "string") {
              bundledStrings2 = [];
              bundledStrings2.size = Infinity;
            } else
              bundledStrings2 = null;
            sharedStructures = encoder.structures;
            if (sharedStructures) {
              if (sharedStructures.uninitialized) {
                let sharedData = encoder.getShared() || {};
                encoder.structures = sharedStructures = sharedData.structures || [];
                encoder.sharedVersion = sharedData.version;
                let sharedValues2 = encoder.sharedValues = sharedData.packedValues;
                if (sharedValues2) {
                  sharedPackedObjectMap2 = {};
                  for (let i = 0, l = sharedValues2.length; i < l; i++)
                    sharedPackedObjectMap2[sharedValues2[i]] = i;
                }
              }
              let sharedStructuresLength = sharedStructures.length;
              if (sharedStructuresLength > maxSharedStructures && !isSequential)
                sharedStructuresLength = maxSharedStructures;
              if (!sharedStructures.transitions) {
                sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
                for (let i = 0; i < sharedStructuresLength; i++) {
                  let keys = sharedStructures[i];
                  if (!keys)
                    continue;
                  let nextTransition, transition = sharedStructures.transitions;
                  for (let j = 0, l = keys.length; j < l; j++) {
                    if (transition[RECORD_SYMBOL] === void 0)
                      transition[RECORD_SYMBOL] = i;
                    let key = keys[j];
                    nextTransition = transition[key];
                    if (!nextTransition) {
                      nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                    }
                    transition = nextTransition;
                  }
                  transition[RECORD_SYMBOL] = i | 1048576;
                }
              }
              if (!isSequential)
                sharedStructures.nextId = sharedStructuresLength;
            }
            if (hasSharedUpdate)
              hasSharedUpdate = false;
            structures = sharedStructures || [];
            packedObjectMap2 = sharedPackedObjectMap2;
            if (options.pack) {
              let packedValues2 = /* @__PURE__ */ new Map();
              packedValues2.values = [];
              packedValues2.encoder = encoder;
              packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
              packedValues2.objectMap = sharedPackedObjectMap2 || false;
              packedValues2.samplingPackedValues = samplingPackedValues;
              findRepetitiveStrings(value, packedValues2);
              if (packedValues2.values.length > 0) {
                target[position2++] = 216;
                target[position2++] = 51;
                writeArrayHeader(4);
                let valuesArray = packedValues2.values;
                encode5(valuesArray);
                writeArrayHeader(0);
                writeArrayHeader(0);
                packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
                for (let i = 0, l = valuesArray.length; i < l; i++) {
                  packedObjectMap2[valuesArray[i]] = i;
                }
              }
            }
            throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
            try {
              if (throwOnIterable)
                return;
              encode5(value);
              if (bundledStrings2) {
                writeBundles(start, encode5);
              }
              encoder.offset = position2;
              if (referenceMap2 && referenceMap2.idsToInsert) {
                position2 += referenceMap2.idsToInsert.length * 2;
                if (position2 > safeEnd)
                  makeRoom(position2);
                encoder.offset = position2;
                let serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);
                referenceMap2 = null;
                return serialized;
              }
              if (encodeOptions & REUSE_BUFFER_MODE) {
                target.start = start;
                target.end = position2;
                return target;
              }
              return target.subarray(start, position2);
            } finally {
              if (sharedStructures) {
                if (serializationsSinceTransitionRebuild < 10)
                  serializationsSinceTransitionRebuild++;
                if (sharedStructures.length > maxSharedStructures)
                  sharedStructures.length = maxSharedStructures;
                if (transitionsCount > 1e4) {
                  sharedStructures.transitions = null;
                  serializationsSinceTransitionRebuild = 0;
                  transitionsCount = 0;
                  if (recordIdsToRemove.length > 0)
                    recordIdsToRemove = [];
                } else if (recordIdsToRemove.length > 0 && !isSequential) {
                  for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
                    recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
                  }
                  recordIdsToRemove = [];
                }
              }
              if (hasSharedUpdate && encoder.saveShared) {
                if (encoder.structures.length > maxSharedStructures) {
                  encoder.structures = encoder.structures.slice(0, maxSharedStructures);
                }
                let returnBuffer = target.subarray(start, position2);
                if (encoder.updateSharedData() === false)
                  return encoder.encode(value);
                return returnBuffer;
              }
              if (encodeOptions & RESET_BUFFER_MODE)
                position2 = start;
            }
          };
          this.findCommonStringsToPack = () => {
            samplingPackedValues = /* @__PURE__ */ new Map();
            if (!sharedPackedObjectMap2)
              sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
            return (options2) => {
              let threshold = options2 && options2.threshold || 4;
              let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
              if (!sharedValues)
                sharedValues = this.sharedValues = [];
              for (let [key, status] of samplingPackedValues) {
                if (status.count > threshold) {
                  sharedPackedObjectMap2[key] = position3++;
                  sharedValues.push(key);
                  hasSharedUpdate = true;
                }
              }
              while (this.saveShared && this.updateSharedData() === false) {
              }
              samplingPackedValues = null;
            };
          };
          const encode5 = (value) => {
            if (position2 > safeEnd)
              target = makeRoom(position2);
            var type = typeof value;
            var length2;
            if (type === "string") {
              if (packedObjectMap2) {
                let packedPosition = packedObjectMap2[value];
                if (packedPosition >= 0) {
                  if (packedPosition < 16)
                    target[position2++] = packedPosition + 224;
                  else {
                    target[position2++] = 198;
                    if (packedPosition & 1)
                      encode5(15 - packedPosition >> 1);
                    else
                      encode5(packedPosition - 16 >> 1);
                  }
                  return;
                } else if (samplingPackedValues && !options.pack) {
                  let status = samplingPackedValues.get(value);
                  if (status)
                    status.count++;
                  else
                    samplingPackedValues.set(value, {
                      count: 1
                    });
                }
              }
              let strLength = value.length;
              if (bundledStrings2 && strLength >= 4 && strLength < 1024) {
                if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
                  let extStart;
                  let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
                  if (position2 + maxBytes2 > safeEnd)
                    target = makeRoom(position2 + maxBytes2);
                  target[position2++] = 217;
                  target[position2++] = 223;
                  target[position2++] = 249;
                  target[position2++] = bundledStrings2.position ? 132 : 130;
                  target[position2++] = 26;
                  extStart = position2 - start;
                  position2 += 4;
                  if (bundledStrings2.position) {
                    writeBundles(start, encode5);
                  }
                  bundledStrings2 = ["", ""];
                  bundledStrings2.size = 0;
                  bundledStrings2.position = extStart;
                }
                let twoByte = hasNonLatin.test(value);
                bundledStrings2[twoByte ? 0 : 1] += value;
                target[position2++] = twoByte ? 206 : 207;
                encode5(strLength);
                return;
              }
              let headerSize;
              if (strLength < 32) {
                headerSize = 1;
              } else if (strLength < 256) {
                headerSize = 2;
              } else if (strLength < 65536) {
                headerSize = 3;
              } else {
                headerSize = 5;
              }
              let maxBytes = strLength * 3;
              if (position2 + maxBytes > safeEnd)
                target = makeRoom(position2 + maxBytes);
              if (strLength < 64 || !encodeUtf8) {
                let i, c1, c2, strPosition = position2 + headerSize;
                for (i = 0; i < strLength; i++) {
                  c1 = value.charCodeAt(i);
                  if (c1 < 128) {
                    target[strPosition++] = c1;
                  } else if (c1 < 2048) {
                    target[strPosition++] = c1 >> 6 | 192;
                    target[strPosition++] = c1 & 63 | 128;
                  } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
                    c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                    i++;
                    target[strPosition++] = c1 >> 18 | 240;
                    target[strPosition++] = c1 >> 12 & 63 | 128;
                    target[strPosition++] = c1 >> 6 & 63 | 128;
                    target[strPosition++] = c1 & 63 | 128;
                  } else {
                    target[strPosition++] = c1 >> 12 | 224;
                    target[strPosition++] = c1 >> 6 & 63 | 128;
                    target[strPosition++] = c1 & 63 | 128;
                  }
                }
                length2 = strPosition - position2 - headerSize;
              } else {
                length2 = encodeUtf8(value, position2 + headerSize, maxBytes);
              }
              if (length2 < 24) {
                target[position2++] = 96 | length2;
              } else if (length2 < 256) {
                if (headerSize < 2) {
                  target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length2);
                }
                target[position2++] = 120;
                target[position2++] = length2;
              } else if (length2 < 65536) {
                if (headerSize < 3) {
                  target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length2);
                }
                target[position2++] = 121;
                target[position2++] = length2 >> 8;
                target[position2++] = length2 & 255;
              } else {
                if (headerSize < 5) {
                  target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length2);
                }
                target[position2++] = 122;
                targetView.setUint32(position2, length2);
                position2 += 4;
              }
              position2 += length2;
            } else if (type === "number") {
              if (!this.alwaysUseFloat && value >>> 0 === value) {
                if (value < 24) {
                  target[position2++] = value;
                } else if (value < 256) {
                  target[position2++] = 24;
                  target[position2++] = value;
                } else if (value < 65536) {
                  target[position2++] = 25;
                  target[position2++] = value >> 8;
                  target[position2++] = value & 255;
                } else {
                  target[position2++] = 26;
                  targetView.setUint32(position2, value);
                  position2 += 4;
                }
              } else if (!this.alwaysUseFloat && value >> 0 === value) {
                if (value >= -24) {
                  target[position2++] = 31 - value;
                } else if (value >= -256) {
                  target[position2++] = 56;
                  target[position2++] = ~value;
                } else if (value >= -65536) {
                  target[position2++] = 57;
                  targetView.setUint16(position2, ~value);
                  position2 += 2;
                } else {
                  target[position2++] = 58;
                  targetView.setUint32(position2, ~value);
                  position2 += 4;
                }
              } else {
                let useFloat32;
                if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
                  target[position2++] = 250;
                  targetView.setFloat32(position2, value);
                  let xShifted;
                  if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
                  (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
                    position2 += 4;
                    return;
                  } else
                    position2--;
                }
                target[position2++] = 251;
                targetView.setFloat64(position2, value);
                position2 += 8;
              }
            } else if (type === "object") {
              if (!value)
                target[position2++] = 246;
              else {
                if (referenceMap2) {
                  let referee = referenceMap2.get(value);
                  if (referee) {
                    target[position2++] = 216;
                    target[position2++] = 29;
                    target[position2++] = 25;
                    if (!referee.references) {
                      let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                      referee.references = [];
                      idsToInsert.push(referee);
                    }
                    referee.references.push(position2 - start);
                    position2 += 2;
                    return;
                  } else
                    referenceMap2.set(value, { offset: position2 - start });
                }
                let constructor = value.constructor;
                if (constructor === Object) {
                  writeObject(value, true);
                } else if (constructor === Array) {
                  length2 = value.length;
                  if (length2 < 24) {
                    target[position2++] = 128 | length2;
                  } else {
                    writeArrayHeader(length2);
                  }
                  for (let i = 0; i < length2; i++) {
                    encode5(value[i]);
                  }
                } else if (constructor === Map) {
                  if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                    target[position2++] = 217;
                    target[position2++] = 1;
                    target[position2++] = 3;
                  }
                  length2 = value.size;
                  if (length2 < 24) {
                    target[position2++] = 160 | length2;
                  } else if (length2 < 256) {
                    target[position2++] = 184;
                    target[position2++] = length2;
                  } else if (length2 < 65536) {
                    target[position2++] = 185;
                    target[position2++] = length2 >> 8;
                    target[position2++] = length2 & 255;
                  } else {
                    target[position2++] = 186;
                    targetView.setUint32(position2, length2);
                    position2 += 4;
                  }
                  if (encoder.keyMap) {
                    for (let [key, entryValue] of value) {
                      encode5(encoder.encodeKey(key));
                      encode5(entryValue);
                    }
                  } else {
                    for (let [key, entryValue] of value) {
                      encode5(key);
                      encode5(entryValue);
                    }
                  }
                } else {
                  for (let i = 0, l = extensions.length; i < l; i++) {
                    let extensionClass = extensionClasses[i];
                    if (value instanceof extensionClass) {
                      let extension = extensions[i];
                      let tag = extension.tag;
                      if (tag == void 0)
                        tag = extension.getTag && extension.getTag.call(this, value);
                      if (tag < 24) {
                        target[position2++] = 192 | tag;
                      } else if (tag < 256) {
                        target[position2++] = 216;
                        target[position2++] = tag;
                      } else if (tag < 65536) {
                        target[position2++] = 217;
                        target[position2++] = tag >> 8;
                        target[position2++] = tag & 255;
                      } else if (tag > -1) {
                        target[position2++] = 218;
                        targetView.setUint32(position2, tag);
                        position2 += 4;
                      }
                      extension.encode.call(this, value, encode5, makeRoom);
                      return;
                    }
                  }
                  if (value[Symbol.iterator]) {
                    if (throwOnIterable) {
                      let error = new Error("Iterable should be serialized as iterator");
                      error.iteratorNotHandled = true;
                      throw error;
                    }
                    target[position2++] = 159;
                    for (let entry of value) {
                      encode5(entry);
                    }
                    target[position2++] = 255;
                    return;
                  }
                  if (value[Symbol.asyncIterator] || isBlob(value)) {
                    let error = new Error("Iterable/blob should be serialized as iterator");
                    error.iteratorNotHandled = true;
                    throw error;
                  }
                  if (this.useToJSON && value.toJSON) {
                    const json = value.toJSON();
                    if (json !== value)
                      return encode5(json);
                  }
                  writeObject(value, !value.hasOwnProperty);
                }
              }
            } else if (type === "boolean") {
              target[position2++] = value ? 245 : 244;
            } else if (type === "bigint") {
              if (value < BigInt(1) << BigInt(64) && value >= 0) {
                target[position2++] = 27;
                targetView.setBigUint64(position2, value);
              } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
                target[position2++] = 59;
                targetView.setBigUint64(position2, -value - BigInt(1));
              } else {
                if (this.largeBigIntToFloat) {
                  target[position2++] = 251;
                  targetView.setFloat64(position2, Number(value));
                } else {
                  throw new RangeError(value + " was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");
                }
              }
              position2 += 8;
            } else if (type === "undefined") {
              target[position2++] = 247;
            } else {
              throw new Error("Unknown type: " + type);
            }
          };
          const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
            let keys = Object.keys(object);
            let vals = Object.values(object);
            let length2 = keys.length;
            if (length2 < 24) {
              target[position2++] = 160 | length2;
            } else if (length2 < 256) {
              target[position2++] = 184;
              target[position2++] = length2;
            } else if (length2 < 65536) {
              target[position2++] = 185;
              target[position2++] = length2 >> 8;
              target[position2++] = length2 & 255;
            } else {
              target[position2++] = 186;
              targetView.setUint32(position2, length2);
              position2 += 4;
            }
            let key;
            if (encoder.keyMap) {
              for (let i = 0; i < length2; i++) {
                encode5(encoder.encodeKey(keys[i]));
                encode5(vals[i]);
              }
            } else {
              for (let i = 0; i < length2; i++) {
                encode5(keys[i]);
                encode5(vals[i]);
              }
            }
          } : (object, safePrototype) => {
            target[position2++] = 185;
            let objectOffset = position2 - start;
            position2 += 2;
            let size = 0;
            if (encoder.keyMap) {
              for (let key in object)
                if (safePrototype || object.hasOwnProperty(key)) {
                  encode5(encoder.encodeKey(key));
                  encode5(object[key]);
                  size++;
                }
            } else {
              for (let key in object)
                if (safePrototype || object.hasOwnProperty(key)) {
                  encode5(key);
                  encode5(object[key]);
                  size++;
                }
            }
            target[objectOffset++ + start] = size >> 8;
            target[objectOffset + start] = size & 255;
          } : (object, safePrototype) => {
            let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
            let newTransitions = 0;
            let length2 = 0;
            let parentRecordId;
            let keys;
            if (this.keyMap) {
              keys = Object.keys(object).map((k) => this.encodeKey(k));
              length2 = keys.length;
              for (let i = 0; i < length2; i++) {
                let key = keys[i];
                nextTransition = transition[key];
                if (!nextTransition) {
                  nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
              }
            } else {
              for (let key in object)
                if (safePrototype || object.hasOwnProperty(key)) {
                  nextTransition = transition[key];
                  if (!nextTransition) {
                    if (transition[RECORD_SYMBOL] & 1048576) {
                      parentRecordId = transition[RECORD_SYMBOL] & 65535;
                    }
                    nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                    newTransitions++;
                  }
                  transition = nextTransition;
                  length2++;
                }
            }
            let recordId = transition[RECORD_SYMBOL];
            if (recordId !== void 0) {
              recordId &= 65535;
              target[position2++] = 217;
              target[position2++] = recordId >> 8 | 224;
              target[position2++] = recordId & 255;
            } else {
              if (!keys)
                keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
              if (parentRecordId === void 0) {
                recordId = structures.nextId++;
                if (!recordId) {
                  recordId = 0;
                  structures.nextId = 1;
                }
                if (recordId >= MAX_STRUCTURES) {
                  structures.nextId = (recordId = maxSharedStructures) + 1;
                }
              } else {
                recordId = parentRecordId;
              }
              structures[recordId] = keys;
              if (recordId < maxSharedStructures) {
                target[position2++] = 217;
                target[position2++] = recordId >> 8 | 224;
                target[position2++] = recordId & 255;
                transition = structures.transitions;
                for (let i = 0; i < length2; i++) {
                  if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
                    transition[RECORD_SYMBOL] = recordId;
                  transition = transition[keys[i]];
                }
                transition[RECORD_SYMBOL] = recordId | 1048576;
                hasSharedUpdate = true;
              } else {
                transition[RECORD_SYMBOL] = recordId;
                targetView.setUint32(position2, 3655335680);
                position2 += 3;
                if (newTransitions)
                  transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
                if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
                  recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
                recordIdsToRemove.push(transition);
                writeArrayHeader(length2 + 2);
                encode5(57344 + recordId);
                encode5(keys);
                if (safePrototype === null)
                  return;
                for (let key in object)
                  if (safePrototype || object.hasOwnProperty(key))
                    encode5(object[key]);
                return;
              }
            }
            if (length2 < 24) {
              target[position2++] = 128 | length2;
            } else {
              writeArrayHeader(length2);
            }
            if (safePrototype === null)
              return;
            for (let key in object)
              if (safePrototype || object.hasOwnProperty(key))
                encode5(object[key]);
          };
          const makeRoom = (end) => {
            let newSize;
            if (end > 16777216) {
              if (end - start > MAX_BUFFER_SIZE)
                throw new Error("Encoded buffer would be larger than maximum buffer size");
              newSize = Math.min(
                MAX_BUFFER_SIZE,
                Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
              );
            } else
              newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
            let newBuffer = new ByteArrayAllocate(newSize);
            targetView = new DataView(newBuffer.buffer, 0, newSize);
            if (target.copy)
              target.copy(newBuffer, 0, start, end);
            else
              newBuffer.set(target.slice(start, end));
            position2 -= start;
            start = 0;
            safeEnd = newBuffer.length - 10;
            return target = newBuffer;
          };
          let chunkThreshold = 100;
          let continuedChunkThreshold = 1e3;
          this.encodeAsIterable = function(value, options2) {
            return startEncoding(value, options2, encodeObjectAsIterable);
          };
          this.encodeAsAsyncIterable = function(value, options2) {
            return startEncoding(value, options2, encodeObjectAsAsyncIterable);
          };
          function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
            let constructor = object.constructor;
            if (constructor === Object) {
              let useRecords = encoder.useRecords !== false;
              if (useRecords)
                writeObject(object, null);
              else
                writeEntityLength(Object.keys(object).length, 160);
              for (let key in object) {
                let value = object[key];
                if (!useRecords)
                  encode5(key);
                if (value && typeof value === "object") {
                  if (iterateProperties[key])
                    yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties[key]));
                  else
                    yield* __yieldStar(tryEncode(value, iterateProperties, key));
                } else
                  encode5(value);
              }
            } else if (constructor === Array) {
              let length2 = object.length;
              writeArrayHeader(length2);
              for (let i = 0; i < length2; i++) {
                let value = object[i];
                if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
                  if (iterateProperties.element)
                    yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties.element));
                  else
                    yield* __yieldStar(tryEncode(value, iterateProperties, "element"));
                } else
                  encode5(value);
              }
            } else if (object[Symbol.iterator]) {
              target[position2++] = 159;
              for (let value of object) {
                if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
                  if (iterateProperties.element)
                    yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties.element));
                  else
                    yield* __yieldStar(tryEncode(value, iterateProperties, "element"));
                } else
                  encode5(value);
              }
              target[position2++] = 255;
            } else if (isBlob(object)) {
              writeEntityLength(object.size, 64);
              yield target.subarray(start, position2);
              yield object;
              restartEncoding();
            } else if (object[Symbol.asyncIterator]) {
              target[position2++] = 159;
              yield target.subarray(start, position2);
              yield object;
              restartEncoding();
              target[position2++] = 255;
            } else {
              encode5(object);
            }
            if (finalIterable && position2 > start)
              yield target.subarray(start, position2);
            else if (position2 - start > chunkThreshold) {
              yield target.subarray(start, position2);
              restartEncoding();
            }
          }
          function* tryEncode(value, iterateProperties, key) {
            let restart = position2 - start;
            try {
              encode5(value);
              if (position2 - start > chunkThreshold) {
                yield target.subarray(start, position2);
                restartEncoding();
              }
            } catch (error) {
              if (error.iteratorNotHandled) {
                iterateProperties[key] = {};
                position2 = start + restart;
                yield* __yieldStar(encodeObjectAsIterable.call(this, value, iterateProperties[key]));
              } else
                throw error;
            }
          }
          function restartEncoding() {
            chunkThreshold = continuedChunkThreshold;
            encoder.encode(null, THROW_ON_ITERABLE);
          }
          function startEncoding(value, options2, encodeIterable) {
            if (options2 && options2.chunkThreshold)
              chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
            else
              chunkThreshold = 100;
            if (value && typeof value === "object") {
              encoder.encode(null, THROW_ON_ITERABLE);
              return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
            }
            return [encoder.encode(value)];
          }
          function encodeObjectAsAsyncIterable(value, iterateProperties) {
            return __asyncGenerator(this, null, function* () {
              for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
                let constructor = encodedValue.constructor;
                if (constructor === ByteArray || constructor === Uint8Array)
                  yield encodedValue;
                else if (isBlob(encodedValue)) {
                  let reader = encodedValue.stream().getReader();
                  let next;
                  while (!(next = yield new __await(reader.read())).done) {
                    yield next.value;
                  }
                } else if (encodedValue[Symbol.asyncIterator]) {
                  try {
                    for (var iter = __forAwait(encodedValue), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                      let asyncValue = temp.value;
                      restartEncoding();
                      if (asyncValue)
                        yield* __yieldStar(encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {})));
                      else
                        yield encoder.encode(asyncValue);
                    }
                  } catch (temp) {
                    error = [temp];
                  } finally {
                    try {
                      more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                    } finally {
                      if (error)
                        throw error[0];
                    }
                  }
                } else {
                  yield encodedValue;
                }
              }
            });
          }
        }
        useBuffer(buffer2) {
          target = buffer2;
          targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
          position2 = 0;
        }
        clearSharedData() {
          if (this.structures)
            this.structures = [];
          if (this.sharedValues)
            this.sharedValues = void 0;
        }
        updateSharedData() {
          let lastVersion = this.sharedVersion || 0;
          this.sharedVersion = lastVersion + 1;
          let structuresCopy = this.structures.slice(0);
          let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
          let saveResults = this.saveShared(
            sharedData,
            (existingShared) => (existingShared && existingShared.version || 0) == lastVersion
          );
          if (saveResults === false) {
            sharedData = this.getShared() || {};
            this.structures = sharedData.structures || [];
            this.sharedValues = sharedData.packedValues;
            this.sharedVersion = sharedData.version;
            this.structures.nextId = this.structures.length;
          } else {
            structuresCopy.forEach((structure, i) => this.structures[i] = structure);
          }
          return saveResults;
        }
      };
      SharedData = class {
        constructor(structures, values, version) {
          this.structures = structures;
          this.packedValues = values;
          this.version = version;
        }
      };
      BlobConstructor = typeof Blob === "undefined" ? function() {
      } : Blob;
      isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
      extensionClasses = [
        Date,
        Set,
        Error,
        RegExp,
        Tag,
        ArrayBuffer,
        Uint8Array,
        Uint8ClampedArray,
        Uint16Array,
        Uint32Array,
        typeof BigUint64Array == "undefined" ? function() {
        } : BigUint64Array,
        Int8Array,
        Int16Array,
        Int32Array,
        typeof BigInt64Array == "undefined" ? function() {
        } : BigInt64Array,
        Float32Array,
        Float64Array,
        SharedData
      ];
      extensions = [
        {
          // Date
          tag: 1,
          encode(date, encode5) {
            let seconds = date.getTime() / 1e3;
            if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
              target[position2++] = 26;
              targetView.setUint32(position2, seconds);
              position2 += 4;
            } else {
              target[position2++] = 251;
              targetView.setFloat64(position2, seconds);
              position2 += 8;
            }
          }
        },
        {
          // Set
          tag: 258,
          // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
          encode(set, encode5) {
            let array = Array.from(set);
            encode5(array);
          }
        },
        {
          // Error
          tag: 27,
          // http://cbor.schmorp.de/generic-object
          encode(error, encode5) {
            encode5([error.name, error.message]);
          }
        },
        {
          // RegExp
          tag: 27,
          // http://cbor.schmorp.de/generic-object
          encode(regex, encode5) {
            encode5(["RegExp", regex.source, regex.flags]);
          }
        },
        {
          // Tag
          getTag(tag) {
            return tag.tag;
          },
          encode(tag, encode5) {
            encode5(tag.value);
          }
        },
        {
          // ArrayBuffer
          encode(arrayBuffer, encode5, makeRoom) {
            writeBuffer(arrayBuffer, makeRoom);
          }
        },
        {
          // Uint8Array
          getTag(typedArray) {
            if (typedArray.constructor === Uint8Array) {
              if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
                return 64;
            }
          },
          encode(typedArray, encode5, makeRoom) {
            writeBuffer(typedArray, makeRoom);
          }
        },
        typedArrayEncoder(68, 1),
        typedArrayEncoder(69, 2),
        typedArrayEncoder(70, 4),
        typedArrayEncoder(71, 8),
        typedArrayEncoder(72, 1),
        typedArrayEncoder(77, 2),
        typedArrayEncoder(78, 4),
        typedArrayEncoder(79, 8),
        typedArrayEncoder(85, 4),
        typedArrayEncoder(86, 8),
        {
          encode(sharedData, encode5) {
            let packedValues2 = sharedData.packedValues || [];
            let sharedStructures = sharedData.structures || [];
            if (packedValues2.values.length > 0) {
              target[position2++] = 216;
              target[position2++] = 51;
              writeArrayHeader(4);
              let valuesArray = packedValues2.values;
              encode5(valuesArray);
              writeArrayHeader(0);
              writeArrayHeader(0);
              packedObjectMap = Object.create(sharedPackedObjectMap || null);
              for (let i = 0, l = valuesArray.length; i < l; i++) {
                packedObjectMap[valuesArray[i]] = i;
              }
            }
            if (sharedStructures) {
              targetView.setUint32(position2, 3655335424);
              position2 += 3;
              let definitions = sharedStructures.slice(0);
              definitions.unshift(57344);
              definitions.push(new Tag(sharedData.version, 1399353956));
              encode5(definitions);
            } else
              encode5(new Tag(sharedData.version, 1399353956));
          }
        }
      ];
      defaultEncoder = new Encoder({ useRecords: false });
      encode = defaultEncoder.encode;
      encodeAsIterable = defaultEncoder.encodeAsIterable;
      encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
      ({ NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS);
      REUSE_BUFFER_MODE = 512;
      RESET_BUFFER_MODE = 1024;
      THROW_ON_ITERABLE = 2048;
    }
  });

  // node_modules/cbor-x/iterators.js
  var init_iterators = __esm({
    "node_modules/cbor-x/iterators.js"() {
      init_encode();
      init_decode();
    }
  });

  // node_modules/cbor-x/index.js
  var init_cbor_x = __esm({
    "node_modules/cbor-x/index.js"() {
      init_encode();
      init_decode();
      init_iterators();
    }
  });

  // node_modules/multiformats/dist/src/bytes.js
  function equals(aa, bb) {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  var empty;
  var init_bytes = __esm({
    "node_modules/multiformats/dist/src/bytes.js"() {
      empty = new Uint8Array(0);
    }
  });

  // node_modules/multiformats/dist/src/vendor/base-x.js
  function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode5(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode8(string) {
      var buffer2 = decodeUnsafe(string);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name} character`);
    }
    return {
      encode: encode5,
      decodeUnsafe,
      decode: decode8
    };
  }
  var src2, _brrp__multiformats_scope_baseX, base_x_default;
  var init_base_x = __esm({
    "node_modules/multiformats/dist/src/vendor/base-x.js"() {
      src2 = base;
      _brrp__multiformats_scope_baseX = src2;
      base_x_default = _brrp__multiformats_scope_baseX;
    }
  });

  // node_modules/multiformats/dist/src/bases/base.js
  function or(left, right) {
    var _a2, _b;
    return new ComposedDecoder(__spreadValues(__spreadValues({}, (_a2 = left.decoders) != null ? _a2 : { [left.prefix]: left }), (_b = right.decoders) != null ? _b : { [right.prefix]: right }));
  }
  function from({ name, prefix, encode: encode5, decode: decode8 }) {
    return new Codec(name, prefix, encode5, decode8);
  }
  function baseX({ name, prefix, alphabet }) {
    const { encode: encode5, decode: decode8 } = base_x_default(alphabet, name);
    return from({
      prefix,
      name,
      encode: encode5,
      decode: (text) => coerce(decode8(text))
    });
  }
  function decode2(string, alphabet, bitsPerChar, name) {
    const codes = {};
    for (let i = 0; i < alphabet.length; ++i) {
      codes[alphabet[i]] = i;
    }
    let end = string.length;
    while (string[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = codes[string[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode2(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer2 = buffer2 << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet[mask & buffer2 >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
    return from({
      prefix,
      name,
      encode(input) {
        return encode2(input, alphabet, bitsPerChar);
      },
      decode(input) {
        return decode2(input, alphabet, bitsPerChar, name);
      }
    });
  }
  var Encoder2, Decoder2, ComposedDecoder, Codec;
  var init_base = __esm({
    "node_modules/multiformats/dist/src/bases/base.js"() {
      init_bytes();
      init_base_x();
      Encoder2 = class {
        constructor(name, prefix, baseEncode) {
          __publicField(this, "name");
          __publicField(this, "prefix");
          __publicField(this, "baseEncode");
          this.name = name;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes) {
          if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      Decoder2 = class {
        constructor(name, prefix, baseDecode) {
          __publicField(this, "name");
          __publicField(this, "prefix");
          __publicField(this, "baseDecode");
          __publicField(this, "prefixCodePoint");
          this.name = name;
          this.prefix = prefix;
          if (prefix.codePointAt(0) === void 0) {
            throw new Error("Invalid prefix character");
          }
          this.prefixCodePoint = prefix.codePointAt(0);
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder2) {
          return or(this, decoder2);
        }
      };
      ComposedDecoder = class {
        constructor(decoders) {
          __publicField(this, "decoders");
          this.decoders = decoders;
        }
        or(decoder2) {
          return or(this, decoder2);
        }
        decode(input) {
          const prefix = input[0];
          const decoder2 = this.decoders[prefix];
          if (decoder2 != null) {
            return decoder2.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      Codec = class {
        constructor(name, prefix, baseEncode, baseDecode) {
          __publicField(this, "name");
          __publicField(this, "prefix");
          __publicField(this, "baseEncode");
          __publicField(this, "baseDecode");
          __publicField(this, "encoder");
          __publicField(this, "decoder");
          this.name = name;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder2(name, prefix, baseEncode);
          this.decoder = new Decoder2(name, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
    }
  });

  // node_modules/multiformats/dist/src/bases/base32.js
  var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
  var init_base32 = __esm({
    "node_modules/multiformats/dist/src/bases/base32.js"() {
      init_base();
      base32 = rfc4648({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      });
      base32upper = rfc4648({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      });
      base32pad = rfc4648({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      });
      base32padupper = rfc4648({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      });
      base32hex = rfc4648({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      });
      base32hexupper = rfc4648({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      });
      base32hexpad = rfc4648({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      });
      base32hexpadupper = rfc4648({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      });
      base32z = rfc4648({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
    }
  });

  // node_modules/multiformats/dist/src/bases/base58.js
  var base58btc, base58flickr;
  var init_base58 = __esm({
    "node_modules/multiformats/dist/src/bases/base58.js"() {
      init_base();
      base58btc = baseX({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      base58flickr = baseX({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
    }
  });

  // node_modules/multiformats/dist/src/vendor/varint.js
  function encode3(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode3.bytes = offset - oldOffset + 1;
    return out;
  }
  function read2(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
    do {
      if (counter >= l) {
        read2.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf2[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read2.bytes = counter - offset;
    return res;
  }
  var encode_1, MSB, REST, MSBALL, INT, decode3, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
  var init_varint = __esm({
    "node_modules/multiformats/dist/src/vendor/varint.js"() {
      encode_1 = encode3;
      MSB = 128;
      REST = 127;
      MSBALL = ~REST;
      INT = Math.pow(2, 31);
      decode3 = read2;
      MSB$1 = 128;
      REST$1 = 127;
      N1 = Math.pow(2, 7);
      N2 = Math.pow(2, 14);
      N3 = Math.pow(2, 21);
      N4 = Math.pow(2, 28);
      N5 = Math.pow(2, 35);
      N6 = Math.pow(2, 42);
      N7 = Math.pow(2, 49);
      N8 = Math.pow(2, 56);
      N9 = Math.pow(2, 63);
      length = function(value) {
        return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
      };
      varint = {
        encode: encode_1,
        decode: decode3,
        encodingLength: length
      };
      _brrp_varint = varint;
      varint_default = _brrp_varint;
    }
  });

  // node_modules/multiformats/dist/src/varint.js
  function decode4(data, offset = 0) {
    const code = varint_default.decode(data, offset);
    return [code, varint_default.decode.bytes];
  }
  function encodeTo(int, target2, offset = 0) {
    varint_default.encode(int, target2, offset);
    return target2;
  }
  function encodingLength(int) {
    return varint_default.encodingLength(int);
  }
  var init_varint2 = __esm({
    "node_modules/multiformats/dist/src/varint.js"() {
      init_varint();
    }
  });

  // node_modules/multiformats/dist/src/hashes/digest.js
  function create(code, digest) {
    const size = digest.byteLength;
    const sizeOffset = encodingLength(code);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
  }
  function decode5(multihash) {
    const bytes = coerce(multihash);
    const [code, sizeOffset] = decode4(bytes);
    const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code, size, digest, bytes);
  }
  function equals2(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
    }
  }
  var Digest;
  var init_digest = __esm({
    "node_modules/multiformats/dist/src/hashes/digest.js"() {
      init_bytes();
      init_varint2();
      Digest = class {
        /**
         * Creates a multihash digest.
         */
        constructor(code, size, digest, bytes) {
          __publicField(this, "code");
          __publicField(this, "size");
          __publicField(this, "digest");
          __publicField(this, "bytes");
          this.code = code;
          this.size = size;
          this.digest = digest;
          this.bytes = bytes;
        }
      };
    }
  });

  // node_modules/multiformats/dist/src/link/interface.js
  var init_interface = __esm({
    "node_modules/multiformats/dist/src/link/interface.js"() {
    }
  });

  // node_modules/multiformats/dist/src/cid.js
  function format(link, base2) {
    const { bytes, version } = link;
    switch (version) {
      case 0:
        return toStringV0(bytes, baseCache(link), base2 != null ? base2 : base58btc.encoder);
      default:
        return toStringV1(bytes, baseCache(link), base2 != null ? base2 : base32.encoder);
    }
  }
  function baseCache(cid) {
    const baseCache2 = cache.get(cid);
    if (baseCache2 == null) {
      const baseCache3 = /* @__PURE__ */ new Map();
      cache.set(cid, baseCache3);
      return baseCache3;
    }
    return baseCache2;
  }
  function parseCIDtoBytes(source, base2) {
    switch (source[0]) {
      case "Q": {
        const decoder2 = base2 != null ? base2 : base58btc;
        return [
          base58btc.prefix,
          decoder2.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder2 = base2 != null ? base2 : base58btc;
        return [base58btc.prefix, decoder2.decode(source)];
      }
      case base32.prefix: {
        const decoder2 = base2 != null ? base2 : base32;
        return [base32.prefix, decoder2.decode(source)];
      }
      default: {
        if (base2 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base2.decode(source)];
      }
    }
  }
  function toStringV0(bytes, cache2, base2) {
    const { prefix } = base2;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base2.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base2.encode(bytes).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV1(bytes, cache2, base2) {
    const { prefix } = base2;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base2.encode(bytes);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function encodeCID(version, code, multihash) {
    const codeOffset = encodingLength(version);
    const hashOffset = codeOffset + encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version, bytes, 0);
    encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  }
  var cache, _a, CID, DAG_PB_CODE, SHA_256_CODE, cidSymbol;
  var init_cid = __esm({
    "node_modules/multiformats/dist/src/cid.js"() {
      init_base32();
      init_base58();
      init_bytes();
      init_digest();
      init_varint2();
      init_interface();
      cache = /* @__PURE__ */ new WeakMap();
      CID = class _CID {
        /**
         * @param version - Version of the CID
         * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
         * @param multihash - (Multi)hash of the of the content.
         */
        constructor(version, code, multihash, bytes) {
          __publicField(this, "code");
          __publicField(this, "version");
          __publicField(this, "multihash");
          __publicField(this, "bytes");
          __publicField(this, "/");
          __publicField(this, _a, "CID");
          this.code = code;
          this.version = version;
          this.multihash = multihash;
          this.bytes = bytes;
          this["/"] = bytes;
        }
        /**
         * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
         * please either use `CID.asCID(cid)` or switch to new signalling mechanism
         *
         * @deprecated
         */
        get asCID() {
          return this;
        }
        // ArrayBufferView
        get byteOffset() {
          return this.bytes.byteOffset;
        }
        // ArrayBufferView
        get byteLength() {
          return this.bytes.byteLength;
        }
        toV0() {
          switch (this.version) {
            case 0: {
              return this;
            }
            case 1: {
              const { code, multihash } = this;
              if (code !== DAG_PB_CODE) {
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              }
              if (multihash.code !== SHA_256_CODE) {
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              }
              return _CID.createV0(multihash);
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              const { code, digest } = this.multihash;
              const multihash = create(code, digest);
              return _CID.createV1(this.code, multihash);
            }
            case 1: {
              return this;
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
            }
          }
        }
        equals(other) {
          return _CID.equals(this, other);
        }
        static equals(self, other) {
          const unknown = other;
          return unknown != null && self.code === unknown.code && self.version === unknown.version && equals2(self.multihash, unknown.multihash);
        }
        toString(base2) {
          return format(this, base2);
        }
        toJSON() {
          return { "/": format(this) };
        }
        link() {
          return this;
        }
        // Legacy
        [(_a = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
          return `CID(${this.toString()})`;
        }
        /**
         * Takes any input `value` and returns a `CID` instance if it was
         * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
         * it will return value back. If `value` is not instance of this CID
         * class, but is compatible CID it will return new instance of this
         * `CID` class. Otherwise returns null.
         *
         * This allows two different incompatible versions of CID library to
         * co-exist and interop as long as binary interface is compatible.
         */
        static asCID(input) {
          if (input == null) {
            return null;
          }
          const value = input;
          if (value instanceof _CID) {
            return value;
          } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
            const { version, code, multihash, bytes } = value;
            return new _CID(version, code, multihash, bytes != null ? bytes : encodeCID(version, code, multihash.bytes));
          } else if (value[cidSymbol] === true) {
            const { version, multihash, code } = value;
            const digest = decode5(multihash);
            return _CID.create(version, code, digest);
          } else {
            return null;
          }
        }
        /**
         * @param version - Version of the CID
         * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
         * @param digest - (Multi)hash of the of the content.
         */
        static create(version, code, digest) {
          if (typeof code !== "number") {
            throw new Error("String codecs are no longer supported");
          }
          if (!(digest.bytes instanceof Uint8Array)) {
            throw new Error("Invalid digest");
          }
          switch (version) {
            case 0: {
              if (code !== DAG_PB_CODE) {
                throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
              } else {
                return new _CID(version, code, digest, digest.bytes);
              }
            }
            case 1: {
              const bytes = encodeCID(version, code, digest.bytes);
              return new _CID(version, code, digest, bytes);
            }
            default: {
              throw new Error("Invalid version");
            }
          }
        }
        /**
         * Simplified version of `create` for CIDv0.
         */
        static createV0(digest) {
          return _CID.create(0, DAG_PB_CODE, digest);
        }
        /**
         * Simplified version of `create` for CIDv1.
         *
         * @param code - Content encoding format code.
         * @param digest - Multihash of the content.
         */
        static createV1(code, digest) {
          return _CID.create(1, code, digest);
        }
        /**
         * Decoded a CID from its binary representation. The byte array must contain
         * only the CID with no additional bytes.
         *
         * An error will be thrown if the bytes provided do not contain a valid
         * binary representation of a CID.
         */
        static decode(bytes) {
          const [cid, remainder] = _CID.decodeFirst(bytes);
          if (remainder.length !== 0) {
            throw new Error("Incorrect length");
          }
          return cid;
        }
        /**
         * Decoded a CID from its binary representation at the beginning of a byte
         * array.
         *
         * Returns an array with the first element containing the CID and the second
         * element containing the remainder of the original byte array. The remainder
         * will be a zero-length byte array if the provided bytes only contained a
         * binary CID representation.
         */
        static decodeFirst(bytes) {
          const specs = _CID.inspectBytes(bytes);
          const prefixSize = specs.size - specs.multihashSize;
          const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
          if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
          }
          const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
          const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
          const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
          return [cid, bytes.subarray(specs.size)];
        }
        /**
         * Inspect the initial bytes of a CID to determine its properties.
         *
         * Involves decoding up to 4 varints. Typically this will require only 4 to 6
         * bytes but for larger multicodec code values and larger multihash digest
         * lengths these varints can be quite large. It is recommended that at least
         * 10 bytes be made available in the `initialBytes` argument for a complete
         * inspection.
         */
        static inspectBytes(initialBytes) {
          let offset = 0;
          const next = () => {
            const [i, length2] = decode4(initialBytes.subarray(offset));
            offset += length2;
            return i;
          };
          let version = next();
          let codec = DAG_PB_CODE;
          if (version === 18) {
            version = 0;
            offset = 0;
          } else {
            codec = next();
          }
          if (version !== 0 && version !== 1) {
            throw new RangeError(`Invalid CID version ${version}`);
          }
          const prefixSize = offset;
          const multihashCode = next();
          const digestSize = next();
          const size = offset + digestSize;
          const multihashSize = size - prefixSize;
          return { version, codec, multihashCode, digestSize, multihashSize, size };
        }
        /**
         * Takes cid in a string representation and creates an instance. If `base`
         * decoder is not provided will use a default from the configuration. It will
         * throw an error if encoding of the CID is not compatible with supplied (or
         * a default decoder).
         */
        static parse(source, base2) {
          const [prefix, bytes] = parseCIDtoBytes(source, base2);
          const cid = _CID.decode(bytes);
          if (cid.version === 0 && source[0] !== "Q") {
            throw Error("Version 0 CID string must not include multibase prefix");
          }
          baseCache(cid).set(prefix, source);
          return cid;
        }
      };
      DAG_PB_CODE = 112;
      SHA_256_CODE = 18;
      cidSymbol = Symbol.for("@ipld/js-cid/CID");
    }
  });

  // node_modules/multiformats/dist/src/hashes/hasher.js
  var init_hasher = __esm({
    "node_modules/multiformats/dist/src/hashes/hasher.js"() {
      init_digest();
    }
  });

  // node_modules/multiformats/dist/src/bases/interface.js
  var init_interface2 = __esm({
    "node_modules/multiformats/dist/src/bases/interface.js"() {
    }
  });

  // node_modules/multiformats/dist/src/hashes/interface.js
  var init_interface3 = __esm({
    "node_modules/multiformats/dist/src/hashes/interface.js"() {
    }
  });

  // node_modules/multiformats/dist/src/codecs/interface.js
  var init_interface4 = __esm({
    "node_modules/multiformats/dist/src/codecs/interface.js"() {
    }
  });

  // node_modules/multiformats/dist/src/block/interface.js
  var init_interface5 = __esm({
    "node_modules/multiformats/dist/src/block/interface.js"() {
    }
  });

  // node_modules/multiformats/dist/src/interface.js
  var init_interface6 = __esm({
    "node_modules/multiformats/dist/src/interface.js"() {
      init_interface2();
      init_interface3();
      init_interface4();
      init_interface();
      init_interface5();
    }
  });

  // node_modules/multiformats/dist/src/index.js
  var init_src = __esm({
    "node_modules/multiformats/dist/src/index.js"() {
      init_bytes();
      init_cid();
      init_digest();
      init_hasher();
      init_varint2();
      init_interface6();
    }
  });

  // node_modules/cborg/lib/is.js
  function is(value) {
    if (value === null) {
      return "null";
    }
    if (value === void 0) {
      return "undefined";
    }
    if (value === true || value === false) {
      return "boolean";
    }
    const typeOf = typeof value;
    if (typeofs.includes(typeOf)) {
      return typeOf;
    }
    if (typeOf === "function") {
      return "Function";
    }
    if (Array.isArray(value)) {
      return "Array";
    }
    if (isBuffer(value)) {
      return "Buffer";
    }
    const objectType = getObjectType(value);
    if (objectType) {
      return objectType;
    }
    return "Object";
  }
  function isBuffer(value) {
    return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
  }
  function getObjectType(value) {
    const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
    if (objectTypeNames.includes(objectTypeName)) {
      return objectTypeName;
    }
    return void 0;
  }
  var typeofs, objectTypeNames;
  var init_is = __esm({
    "node_modules/cborg/lib/is.js"() {
      typeofs = [
        "string",
        "number",
        "bigint",
        "symbol"
      ];
      objectTypeNames = [
        "Function",
        "Generator",
        "AsyncGenerator",
        "GeneratorFunction",
        "AsyncGeneratorFunction",
        "AsyncFunction",
        "Observable",
        "Array",
        "Buffer",
        "Object",
        "RegExp",
        "Date",
        "Error",
        "Map",
        "Set",
        "WeakMap",
        "WeakSet",
        "ArrayBuffer",
        "SharedArrayBuffer",
        "DataView",
        "Promise",
        "URL",
        "HTMLElement",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array"
      ];
    }
  });

  // node_modules/cborg/lib/token.js
  var Type, Token;
  var init_token = __esm({
    "node_modules/cborg/lib/token.js"() {
      Type = class {
        /**
         * @param {number} major
         * @param {string} name
         * @param {boolean} terminal
         */
        constructor(major, name, terminal) {
          this.major = major;
          this.majorEncoded = major << 5;
          this.name = name;
          this.terminal = terminal;
        }
        /* c8 ignore next 3 */
        toString() {
          return `Type[${this.major}].${this.name}`;
        }
        /**
         * @param {Type} typ
         * @returns {number}
         */
        compare(typ) {
          return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
        }
      };
      Type.uint = new Type(0, "uint", true);
      Type.negint = new Type(1, "negint", true);
      Type.bytes = new Type(2, "bytes", true);
      Type.string = new Type(3, "string", true);
      Type.array = new Type(4, "array", false);
      Type.map = new Type(5, "map", false);
      Type.tag = new Type(6, "tag", false);
      Type.float = new Type(7, "float", true);
      Type.false = new Type(7, "false", true);
      Type.true = new Type(7, "true", true);
      Type.null = new Type(7, "null", true);
      Type.undefined = new Type(7, "undefined", true);
      Type.break = new Type(7, "break", true);
      Token = class {
        /**
         * @param {Type} type
         * @param {any} [value]
         * @param {number} [encodedLength]
         */
        constructor(type, value, encodedLength) {
          this.type = type;
          this.value = value;
          this.encodedLength = encodedLength;
          this.encodedBytes = void 0;
          this.byteValue = void 0;
        }
        /* c8 ignore next 3 */
        toString() {
          return `Token[${this.type}].${this.value}`;
        }
      };
    }
  });

  // node_modules/cborg/lib/byte-utils.js
  function isBuffer2(buf2) {
    return useBuffer && globalThis.Buffer.isBuffer(buf2);
  }
  function asU8A(buf2) {
    if (!(buf2 instanceof Uint8Array)) {
      return Uint8Array.from(buf2);
    }
    return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
  }
  function compare(b1, b2) {
    if (isBuffer2(b1) && isBuffer2(b2)) {
      return b1.compare(b2);
    }
    for (let i = 0; i < b1.length; i++) {
      if (b1[i] === b2[i]) {
        continue;
      }
      return b1[i] < b2[i] ? -1 : 1;
    }
    return 0;
  }
  function utf8ToBytes(str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
      let c = str.charCodeAt(i);
      if (c < 128) {
        out[p++] = c;
      } else if (c < 2048) {
        out[p++] = c >> 6 | 192;
        out[p++] = c & 63 | 128;
      } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        out[p++] = c >> 18 | 240;
        out[p++] = c >> 12 & 63 | 128;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      } else {
        out[p++] = c >> 12 | 224;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      }
    }
    return out;
  }
  function utf8Slice(buf2, offset, end) {
    const res = [];
    while (offset < end) {
      const firstByte = buf2[offset];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (offset + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[offset + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[offset + 1];
            thirdByte = buf2[offset + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[offset + 1];
            thirdByte = buf2[offset + 2];
            fourthByte = buf2[offset + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      offset += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  var useBuffer, textDecoder, textEncoder2, toString, fromString, slice, concat, alloc, MAX_ARGUMENTS_LENGTH;
  var init_byte_utils = __esm({
    "node_modules/cborg/lib/byte-utils.js"() {
      useBuffer = globalThis.process && // @ts-ignore
      !globalThis.process.browser && // @ts-ignore
      globalThis.Buffer && // @ts-ignore
      typeof globalThis.Buffer.isBuffer === "function";
      textDecoder = new TextDecoder();
      textEncoder2 = new TextEncoder();
      toString = useBuffer ? (
        // eslint-disable-line operator-linebreak
        /**
         * @param {Uint8Array} bytes
         * @param {number} start
         * @param {number} end
         */
        (bytes, start, end) => {
          return end - start > 64 ? (
            // eslint-disable-line operator-linebreak
            // @ts-ignore
            globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8")
          ) : utf8Slice(bytes, start, end);
        }
      ) : (
        // eslint-disable-line operator-linebreak
        /**
         * @param {Uint8Array} bytes
         * @param {number} start
         * @param {number} end
         */
        (bytes, start, end) => {
          return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
        }
      );
      fromString = useBuffer ? (
        // eslint-disable-line operator-linebreak
        /**
         * @param {string} string
         */
        (string) => {
          return string.length > 64 ? (
            // eslint-disable-line operator-linebreak
            // @ts-ignore
            globalThis.Buffer.from(string)
          ) : utf8ToBytes(string);
        }
      ) : (
        // eslint-disable-line operator-linebreak
        /**
         * @param {string} string
         */
        (string) => {
          return string.length > 64 ? textEncoder2.encode(string) : utf8ToBytes(string);
        }
      );
      slice = useBuffer ? (
        // eslint-disable-line operator-linebreak
        /**
         * @param {Uint8Array} bytes
         * @param {number} start
         * @param {number} end
         */
        (bytes, start, end) => {
          if (isBuffer2(bytes)) {
            return new Uint8Array(bytes.subarray(start, end));
          }
          return bytes.slice(start, end);
        }
      ) : (
        // eslint-disable-line operator-linebreak
        /**
         * @param {Uint8Array} bytes
         * @param {number} start
         * @param {number} end
         */
        (bytes, start, end) => {
          return bytes.slice(start, end);
        }
      );
      concat = useBuffer ? (
        // eslint-disable-line operator-linebreak
        /**
         * @param {Uint8Array[]} chunks
         * @param {number} length
         * @returns {Uint8Array}
         */
        (chunks, length2) => {
          chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
            // eslint-disable-line operator-linebreak
            // @ts-ignore
            globalThis.Buffer.from(c)
          ));
          return asU8A(globalThis.Buffer.concat(chunks, length2));
        }
      ) : (
        // eslint-disable-line operator-linebreak
        /**
         * @param {Uint8Array[]} chunks
         * @param {number} length
         * @returns {Uint8Array}
         */
        (chunks, length2) => {
          const out = new Uint8Array(length2);
          let off = 0;
          for (let b of chunks) {
            if (off + b.length > out.length) {
              b = b.subarray(0, out.length - off);
            }
            out.set(b, off);
            off += b.length;
          }
          return out;
        }
      );
      alloc = useBuffer ? (
        // eslint-disable-line operator-linebreak
        /**
         * @param {number} size
         * @returns {Uint8Array}
         */
        (size) => {
          return globalThis.Buffer.allocUnsafe(size);
        }
      ) : (
        // eslint-disable-line operator-linebreak
        /**
         * @param {number} size
         * @returns {Uint8Array}
         */
        (size) => {
          return new Uint8Array(size);
        }
      );
      MAX_ARGUMENTS_LENGTH = 4096;
    }
  });

  // node_modules/cborg/lib/bl.js
  var defaultChunkSize, Bl;
  var init_bl = __esm({
    "node_modules/cborg/lib/bl.js"() {
      init_byte_utils();
      defaultChunkSize = 256;
      Bl = class {
        /**
         * @param {number} [chunkSize]
         */
        constructor(chunkSize = defaultChunkSize) {
          this.chunkSize = chunkSize;
          this.cursor = 0;
          this.maxCursor = -1;
          this.chunks = [];
          this._initReuseChunk = null;
        }
        reset() {
          this.cursor = 0;
          this.maxCursor = -1;
          if (this.chunks.length) {
            this.chunks = [];
          }
          if (this._initReuseChunk !== null) {
            this.chunks.push(this._initReuseChunk);
            this.maxCursor = this._initReuseChunk.length - 1;
          }
        }
        /**
         * @param {Uint8Array|number[]} bytes
         */
        push(bytes) {
          let topChunk = this.chunks[this.chunks.length - 1];
          const newMax = this.cursor + bytes.length;
          if (newMax <= this.maxCursor + 1) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            topChunk.set(bytes, chunkPos);
          } else {
            if (topChunk) {
              const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
              if (chunkPos < topChunk.length) {
                this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
                this.maxCursor = this.cursor - 1;
              }
            }
            if (bytes.length < 64 && bytes.length < this.chunkSize) {
              topChunk = alloc(this.chunkSize);
              this.chunks.push(topChunk);
              this.maxCursor += topChunk.length;
              if (this._initReuseChunk === null) {
                this._initReuseChunk = topChunk;
              }
              topChunk.set(bytes, 0);
            } else {
              this.chunks.push(bytes);
              this.maxCursor += bytes.length;
            }
          }
          this.cursor += bytes.length;
        }
        /**
         * @param {boolean} [reset]
         * @returns {Uint8Array}
         */
        toBytes(reset = false) {
          let byts;
          if (this.chunks.length === 1) {
            const chunk = this.chunks[0];
            if (reset && this.cursor > chunk.length / 2) {
              byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
              this._initReuseChunk = null;
              this.chunks = [];
            } else {
              byts = slice(chunk, 0, this.cursor);
            }
          } else {
            byts = concat(this.chunks, this.cursor);
          }
          if (reset) {
            this.reset();
          }
          return byts;
        }
      };
    }
  });

  // node_modules/cborg/lib/common.js
  function assertEnoughData(data, pos, need) {
    if (data.length - pos < need) {
      throw new Error(`${decodeErrPrefix} not enough data for type`);
    }
  }
  var decodeErrPrefix, encodeErrPrefix, uintMinorPrefixBytes;
  var init_common = __esm({
    "node_modules/cborg/lib/common.js"() {
      decodeErrPrefix = "CBOR decode error:";
      encodeErrPrefix = "CBOR encode error:";
      uintMinorPrefixBytes = [];
      uintMinorPrefixBytes[23] = 1;
      uintMinorPrefixBytes[24] = 2;
      uintMinorPrefixBytes[25] = 3;
      uintMinorPrefixBytes[26] = 5;
      uintMinorPrefixBytes[27] = 9;
    }
  });

  // node_modules/cborg/lib/0uint.js
  function readUint8(data, offset, options) {
    assertEnoughData(data, offset, 1);
    const value = data[offset];
    if (options.strict === true && value < uintBoundaries[0]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint16(data, offset, options) {
    assertEnoughData(data, offset, 2);
    const value = data[offset] << 8 | data[offset + 1];
    if (options.strict === true && value < uintBoundaries[1]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint32(data, offset, options) {
    assertEnoughData(data, offset, 4);
    const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    if (options.strict === true && value < uintBoundaries[2]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint64(data, offset, options) {
    assertEnoughData(data, offset, 8);
    const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
    const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
    if (options.strict === true && value < uintBoundaries[3]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    if (value <= Number.MAX_SAFE_INTEGER) {
      return Number(value);
    }
    if (options.allowBigInt === true) {
      return value;
    }
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  function decodeUint8(data, pos, _minor, options) {
    return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
  }
  function decodeUint16(data, pos, _minor, options) {
    return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
  }
  function decodeUint32(data, pos, _minor, options) {
    return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
  }
  function decodeUint64(data, pos, _minor, options) {
    return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
  }
  function encodeUint(buf2, token) {
    return encodeUintValue(buf2, 0, token.value);
  }
  function encodeUintValue(buf2, major, uint) {
    if (uint < uintBoundaries[0]) {
      const nuint = Number(uint);
      buf2.push([major | nuint]);
    } else if (uint < uintBoundaries[1]) {
      const nuint = Number(uint);
      buf2.push([major | 24, nuint]);
    } else if (uint < uintBoundaries[2]) {
      const nuint = Number(uint);
      buf2.push([major | 25, nuint >>> 8, nuint & 255]);
    } else if (uint < uintBoundaries[3]) {
      const nuint = Number(uint);
      buf2.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
    } else {
      const buint = BigInt(uint);
      if (buint < uintBoundaries[4]) {
        const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
        let lo = Number(buint & BigInt(4294967295));
        let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
        set[8] = lo & 255;
        lo = lo >> 8;
        set[7] = lo & 255;
        lo = lo >> 8;
        set[6] = lo & 255;
        lo = lo >> 8;
        set[5] = lo & 255;
        set[4] = hi & 255;
        hi = hi >> 8;
        set[3] = hi & 255;
        hi = hi >> 8;
        set[2] = hi & 255;
        hi = hi >> 8;
        set[1] = hi & 255;
        buf2.push(set);
      } else {
        throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
      }
    }
  }
  var uintBoundaries;
  var init_uint = __esm({
    "node_modules/cborg/lib/0uint.js"() {
      init_token();
      init_common();
      uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
      encodeUint.encodedSize = function encodedSize(token) {
        return encodeUintValue.encodedSize(token.value);
      };
      encodeUintValue.encodedSize = function encodedSize2(uint) {
        if (uint < uintBoundaries[0]) {
          return 1;
        }
        if (uint < uintBoundaries[1]) {
          return 2;
        }
        if (uint < uintBoundaries[2]) {
          return 3;
        }
        if (uint < uintBoundaries[3]) {
          return 5;
        }
        return 9;
      };
      encodeUint.compareTokens = function compareTokens(tok1, tok2) {
        return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
          /* c8 ignore next */
          0
        );
      };
    }
  });

  // node_modules/cborg/lib/1negint.js
  function decodeNegint8(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
  }
  function decodeNegint16(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
  }
  function decodeNegint32(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
  }
  function decodeNegint64(data, pos, _minor, options) {
    const int = readUint64(data, pos + 1, options);
    if (typeof int !== "bigint") {
      const value = -1 - int;
      if (value >= Number.MIN_SAFE_INTEGER) {
        return new Token(Type.negint, value, 9);
      }
    }
    if (options.allowBigInt !== true) {
      throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
    }
    return new Token(Type.negint, neg1b - BigInt(int), 9);
  }
  function encodeNegint(buf2, token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    encodeUintValue(buf2, token.type.majorEncoded, unsigned);
  }
  var neg1b, pos1b;
  var init_negint = __esm({
    "node_modules/cborg/lib/1negint.js"() {
      init_token();
      init_uint();
      init_common();
      neg1b = BigInt(-1);
      pos1b = BigInt(1);
      encodeNegint.encodedSize = function encodedSize3(token) {
        const negint = token.value;
        const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
        if (unsigned < uintBoundaries[0]) {
          return 1;
        }
        if (unsigned < uintBoundaries[1]) {
          return 2;
        }
        if (unsigned < uintBoundaries[2]) {
          return 3;
        }
        if (unsigned < uintBoundaries[3]) {
          return 5;
        }
        return 9;
      };
      encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
        return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
          /* c8 ignore next */
          0
        );
      };
    }
  });

  // node_modules/cborg/lib/2bytes.js
  function toToken(data, pos, prefix, length2) {
    assertEnoughData(data, pos, prefix + length2);
    const buf2 = slice(data, pos + prefix, pos + prefix + length2);
    return new Token(Type.bytes, buf2, prefix + length2);
  }
  function decodeBytesCompact(data, pos, minor, _options) {
    return toToken(data, pos, 1, minor);
  }
  function decodeBytes8(data, pos, _minor, options) {
    return toToken(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeBytes16(data, pos, _minor, options) {
    return toToken(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeBytes32(data, pos, _minor, options) {
    return toToken(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeBytes64(data, pos, _minor, options) {
    const l = readUint64(data, pos + 1, options);
    if (typeof l === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
    }
    return toToken(data, pos, 9, l);
  }
  function tokenBytes(token) {
    if (token.encodedBytes === void 0) {
      token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;
    }
    return token.encodedBytes;
  }
  function encodeBytes(buf2, token) {
    const bytes = tokenBytes(token);
    encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
    buf2.push(bytes);
  }
  function compareBytes(b1, b2) {
    return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
  }
  var init_bytes2 = __esm({
    "node_modules/cborg/lib/2bytes.js"() {
      init_token();
      init_common();
      init_uint();
      init_byte_utils();
      encodeBytes.encodedSize = function encodedSize4(token) {
        const bytes = tokenBytes(token);
        return encodeUintValue.encodedSize(bytes.length) + bytes.length;
      };
      encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
        return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
      };
    }
  });

  // node_modules/cborg/lib/3string.js
  function toToken2(data, pos, prefix, length2, options) {
    const totLength = prefix + length2;
    assertEnoughData(data, pos, totLength);
    const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);
    if (options.retainStringBytes === true) {
      tok.byteValue = slice(data, pos + prefix, pos + totLength);
    }
    return tok;
  }
  function decodeStringCompact(data, pos, minor, options) {
    return toToken2(data, pos, 1, minor, options);
  }
  function decodeString8(data, pos, _minor, options) {
    return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
  }
  function decodeString16(data, pos, _minor, options) {
    return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
  }
  function decodeString32(data, pos, _minor, options) {
    return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
  }
  function decodeString64(data, pos, _minor, options) {
    const l = readUint64(data, pos + 1, options);
    if (typeof l === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
    }
    return toToken2(data, pos, 9, l, options);
  }
  var encodeString;
  var init_string = __esm({
    "node_modules/cborg/lib/3string.js"() {
      init_token();
      init_common();
      init_uint();
      init_bytes2();
      init_byte_utils();
      encodeString = encodeBytes;
    }
  });

  // node_modules/cborg/lib/4array.js
  function toToken3(_data, _pos, prefix, length2) {
    return new Token(Type.array, length2, prefix);
  }
  function decodeArrayCompact(data, pos, minor, _options) {
    return toToken3(data, pos, 1, minor);
  }
  function decodeArray8(data, pos, _minor, options) {
    return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeArray16(data, pos, _minor, options) {
    return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeArray32(data, pos, _minor, options) {
    return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeArray64(data, pos, _minor, options) {
    const l = readUint64(data, pos + 1, options);
    if (typeof l === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
    }
    return toToken3(data, pos, 9, l);
  }
  function decodeArrayIndefinite(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken3(data, pos, 1, Infinity);
  }
  function encodeArray(buf2, token) {
    encodeUintValue(buf2, Type.array.majorEncoded, token.value);
  }
  var init_array = __esm({
    "node_modules/cborg/lib/4array.js"() {
      init_token();
      init_uint();
      init_common();
      encodeArray.compareTokens = encodeUint.compareTokens;
      encodeArray.encodedSize = function encodedSize5(token) {
        return encodeUintValue.encodedSize(token.value);
      };
    }
  });

  // node_modules/cborg/lib/5map.js
  function toToken4(_data, _pos, prefix, length2) {
    return new Token(Type.map, length2, prefix);
  }
  function decodeMapCompact(data, pos, minor, _options) {
    return toToken4(data, pos, 1, minor);
  }
  function decodeMap8(data, pos, _minor, options) {
    return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeMap16(data, pos, _minor, options) {
    return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeMap32(data, pos, _minor, options) {
    return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeMap64(data, pos, _minor, options) {
    const l = readUint64(data, pos + 1, options);
    if (typeof l === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
    }
    return toToken4(data, pos, 9, l);
  }
  function decodeMapIndefinite(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken4(data, pos, 1, Infinity);
  }
  function encodeMap(buf2, token) {
    encodeUintValue(buf2, Type.map.majorEncoded, token.value);
  }
  var init_map = __esm({
    "node_modules/cborg/lib/5map.js"() {
      init_token();
      init_uint();
      init_common();
      encodeMap.compareTokens = encodeUint.compareTokens;
      encodeMap.encodedSize = function encodedSize6(token) {
        return encodeUintValue.encodedSize(token.value);
      };
    }
  });

  // node_modules/cborg/lib/6tag.js
  function decodeTagCompact(_data, _pos, minor, _options) {
    return new Token(Type.tag, minor, 1);
  }
  function decodeTag8(data, pos, _minor, options) {
    return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
  }
  function decodeTag16(data, pos, _minor, options) {
    return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
  }
  function decodeTag32(data, pos, _minor, options) {
    return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
  }
  function decodeTag64(data, pos, _minor, options) {
    return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
  }
  function encodeTag(buf2, token) {
    encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
  }
  var init_tag = __esm({
    "node_modules/cborg/lib/6tag.js"() {
      init_token();
      init_uint();
      encodeTag.compareTokens = encodeUint.compareTokens;
      encodeTag.encodedSize = function encodedSize7(token) {
        return encodeUintValue.encodedSize(token.value);
      };
    }
  });

  // node_modules/cborg/lib/7float.js
  function decodeUndefined(_data, _pos, _minor, options) {
    if (options.allowUndefined === false) {
      throw new Error(`${decodeErrPrefix} undefined values are not supported`);
    } else if (options.coerceUndefinedToNull === true) {
      return new Token(Type.null, null, 1);
    }
    return new Token(Type.undefined, void 0, 1);
  }
  function decodeBreak(_data, _pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return new Token(Type.break, void 0, 1);
  }
  function createToken(value, bytes, options) {
    if (options) {
      if (options.allowNaN === false && Number.isNaN(value)) {
        throw new Error(`${decodeErrPrefix} NaN values are not supported`);
      }
      if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
        throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
      }
    }
    return new Token(Type.float, value, bytes);
  }
  function decodeFloat16(data, pos, _minor, options) {
    return createToken(readFloat16(data, pos + 1), 3, options);
  }
  function decodeFloat32(data, pos, _minor, options) {
    return createToken(readFloat32(data, pos + 1), 5, options);
  }
  function decodeFloat64(data, pos, _minor, options) {
    return createToken(readFloat64(data, pos + 1), 9, options);
  }
  function encodeFloat(buf2, token, options) {
    const float = token.value;
    if (float === false) {
      buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
    } else if (float === true) {
      buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
    } else if (float === null) {
      buf2.push([Type.float.majorEncoded | MINOR_NULL]);
    } else if (float === void 0) {
      buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
    } else {
      let decoded;
      let success = false;
      if (!options || options.float64 !== true) {
        encodeFloat16(float);
        decoded = readFloat16(ui8a, 1);
        if (float === decoded || Number.isNaN(float)) {
          ui8a[0] = 249;
          buf2.push(ui8a.slice(0, 3));
          success = true;
        } else {
          encodeFloat32(float);
          decoded = readFloat32(ui8a, 1);
          if (float === decoded) {
            ui8a[0] = 250;
            buf2.push(ui8a.slice(0, 5));
            success = true;
          }
        }
      }
      if (!success) {
        encodeFloat64(float);
        decoded = readFloat64(ui8a, 1);
        ui8a[0] = 251;
        buf2.push(ui8a.slice(0, 9));
      }
    }
  }
  function encodeFloat16(inp) {
    if (inp === Infinity) {
      dataView2.setUint16(0, 31744, false);
    } else if (inp === -Infinity) {
      dataView2.setUint16(0, 64512, false);
    } else if (Number.isNaN(inp)) {
      dataView2.setUint16(0, 32256, false);
    } else {
      dataView2.setFloat32(0, inp);
      const valu32 = dataView2.getUint32(0);
      const exponent = (valu32 & 2139095040) >> 23;
      const mantissa = valu32 & 8388607;
      if (exponent === 255) {
        dataView2.setUint16(0, 31744, false);
      } else if (exponent === 0) {
        dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
      } else {
        const logicalExponent = exponent - 127;
        if (logicalExponent < -24) {
          dataView2.setUint16(0, 0);
        } else if (logicalExponent < -14) {
          dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
          1 << 24 + logicalExponent, false);
        } else {
          dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
        }
      }
    }
  }
  function readFloat16(ui8a2, pos) {
    if (ui8a2.length - pos < 2) {
      throw new Error(`${decodeErrPrefix} not enough data for float16`);
    }
    const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
    if (half === 31744) {
      return Infinity;
    }
    if (half === 64512) {
      return -Infinity;
    }
    if (half === 32256) {
      return NaN;
    }
    const exp = half >> 10 & 31;
    const mant = half & 1023;
    let val;
    if (exp === 0) {
      val = mant * __pow(2, -24);
    } else if (exp !== 31) {
      val = (mant + 1024) * __pow(2, exp - 25);
    } else {
      val = mant === 0 ? Infinity : NaN;
    }
    return half & 32768 ? -val : val;
  }
  function encodeFloat32(inp) {
    dataView2.setFloat32(0, inp, false);
  }
  function readFloat32(ui8a2, pos) {
    if (ui8a2.length - pos < 4) {
      throw new Error(`${decodeErrPrefix} not enough data for float32`);
    }
    const offset = (ui8a2.byteOffset || 0) + pos;
    return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
  }
  function encodeFloat64(inp) {
    dataView2.setFloat64(0, inp, false);
  }
  function readFloat64(ui8a2, pos) {
    if (ui8a2.length - pos < 8) {
      throw new Error(`${decodeErrPrefix} not enough data for float64`);
    }
    const offset = (ui8a2.byteOffset || 0) + pos;
    return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
  }
  var MINOR_FALSE, MINOR_TRUE, MINOR_NULL, MINOR_UNDEFINED, buffer, dataView2, ui8a;
  var init_float = __esm({
    "node_modules/cborg/lib/7float.js"() {
      init_token();
      init_common();
      init_uint();
      MINOR_FALSE = 20;
      MINOR_TRUE = 21;
      MINOR_NULL = 22;
      MINOR_UNDEFINED = 23;
      encodeFloat.encodedSize = function encodedSize8(token, options) {
        const float = token.value;
        if (float === false || float === true || float === null || float === void 0) {
          return 1;
        }
        if (!options || options.float64 !== true) {
          encodeFloat16(float);
          let decoded = readFloat16(ui8a, 1);
          if (float === decoded || Number.isNaN(float)) {
            return 3;
          }
          encodeFloat32(float);
          decoded = readFloat32(ui8a, 1);
          if (float === decoded) {
            return 5;
          }
        }
        return 9;
      };
      buffer = new ArrayBuffer(9);
      dataView2 = new DataView(buffer, 1);
      ui8a = new Uint8Array(buffer, 0);
      encodeFloat.compareTokens = encodeUint.compareTokens;
    }
  });

  // node_modules/cborg/lib/jump.js
  function invalidMinor(data, pos, minor) {
    throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
  }
  function errorer(msg) {
    return () => {
      throw new Error(`${decodeErrPrefix} ${msg}`);
    };
  }
  var jump, quick;
  var init_jump = __esm({
    "node_modules/cborg/lib/jump.js"() {
      init_token();
      init_uint();
      init_negint();
      init_bytes2();
      init_string();
      init_array();
      init_map();
      init_tag();
      init_float();
      init_common();
      init_byte_utils();
      jump = [];
      for (let i = 0; i <= 23; i++) {
        jump[i] = invalidMinor;
      }
      jump[24] = decodeUint8;
      jump[25] = decodeUint16;
      jump[26] = decodeUint32;
      jump[27] = decodeUint64;
      jump[28] = invalidMinor;
      jump[29] = invalidMinor;
      jump[30] = invalidMinor;
      jump[31] = invalidMinor;
      for (let i = 32; i <= 55; i++) {
        jump[i] = invalidMinor;
      }
      jump[56] = decodeNegint8;
      jump[57] = decodeNegint16;
      jump[58] = decodeNegint32;
      jump[59] = decodeNegint64;
      jump[60] = invalidMinor;
      jump[61] = invalidMinor;
      jump[62] = invalidMinor;
      jump[63] = invalidMinor;
      for (let i = 64; i <= 87; i++) {
        jump[i] = decodeBytesCompact;
      }
      jump[88] = decodeBytes8;
      jump[89] = decodeBytes16;
      jump[90] = decodeBytes32;
      jump[91] = decodeBytes64;
      jump[92] = invalidMinor;
      jump[93] = invalidMinor;
      jump[94] = invalidMinor;
      jump[95] = errorer("indefinite length bytes/strings are not supported");
      for (let i = 96; i <= 119; i++) {
        jump[i] = decodeStringCompact;
      }
      jump[120] = decodeString8;
      jump[121] = decodeString16;
      jump[122] = decodeString32;
      jump[123] = decodeString64;
      jump[124] = invalidMinor;
      jump[125] = invalidMinor;
      jump[126] = invalidMinor;
      jump[127] = errorer("indefinite length bytes/strings are not supported");
      for (let i = 128; i <= 151; i++) {
        jump[i] = decodeArrayCompact;
      }
      jump[152] = decodeArray8;
      jump[153] = decodeArray16;
      jump[154] = decodeArray32;
      jump[155] = decodeArray64;
      jump[156] = invalidMinor;
      jump[157] = invalidMinor;
      jump[158] = invalidMinor;
      jump[159] = decodeArrayIndefinite;
      for (let i = 160; i <= 183; i++) {
        jump[i] = decodeMapCompact;
      }
      jump[184] = decodeMap8;
      jump[185] = decodeMap16;
      jump[186] = decodeMap32;
      jump[187] = decodeMap64;
      jump[188] = invalidMinor;
      jump[189] = invalidMinor;
      jump[190] = invalidMinor;
      jump[191] = decodeMapIndefinite;
      for (let i = 192; i <= 215; i++) {
        jump[i] = decodeTagCompact;
      }
      jump[216] = decodeTag8;
      jump[217] = decodeTag16;
      jump[218] = decodeTag32;
      jump[219] = decodeTag64;
      jump[220] = invalidMinor;
      jump[221] = invalidMinor;
      jump[222] = invalidMinor;
      jump[223] = invalidMinor;
      for (let i = 224; i <= 243; i++) {
        jump[i] = errorer("simple values are not supported");
      }
      jump[244] = invalidMinor;
      jump[245] = invalidMinor;
      jump[246] = invalidMinor;
      jump[247] = decodeUndefined;
      jump[248] = errorer("simple values are not supported");
      jump[249] = decodeFloat16;
      jump[250] = decodeFloat32;
      jump[251] = decodeFloat64;
      jump[252] = invalidMinor;
      jump[253] = invalidMinor;
      jump[254] = invalidMinor;
      jump[255] = decodeBreak;
      quick = [];
      for (let i = 0; i < 24; i++) {
        quick[i] = new Token(Type.uint, i, 1);
      }
      for (let i = -1; i >= -24; i--) {
        quick[31 - i] = new Token(Type.negint, i, 1);
      }
      quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
      quick[96] = new Token(Type.string, "", 1);
      quick[128] = new Token(Type.array, 0, 1);
      quick[160] = new Token(Type.map, 0, 1);
      quick[244] = new Token(Type.false, false, 1);
      quick[245] = new Token(Type.true, true, 1);
      quick[246] = new Token(Type.null, null, 1);
    }
  });

  // node_modules/cborg/lib/encode.js
  function makeCborEncoders() {
    const encoders = [];
    encoders[Type.uint.major] = encodeUint;
    encoders[Type.negint.major] = encodeNegint;
    encoders[Type.bytes.major] = encodeBytes;
    encoders[Type.string.major] = encodeString;
    encoders[Type.array.major] = encodeArray;
    encoders[Type.map.major] = encodeMap;
    encoders[Type.tag.major] = encodeTag;
    encoders[Type.float.major] = encodeFloat;
    return encoders;
  }
  function objectToTokens(obj, options = {}, refStack) {
    const typ = is(obj);
    const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
    options.typeEncoders[typ] || typeEncoders[typ];
    if (typeof customTypeEncoder === "function") {
      const tokens = customTypeEncoder(obj, typ, options, refStack);
      if (tokens != null) {
        return tokens;
      }
    }
    const typeEncoder = typeEncoders[typ];
    if (!typeEncoder) {
      throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
    }
    return typeEncoder(obj, typ, options, refStack);
  }
  function sortMapEntries(entries, options) {
    if (options.mapSorter) {
      entries.sort(options.mapSorter);
    }
  }
  var cborEncoders, buf, Ref, simpleTokens, typeEncoders;
  var init_encode2 = __esm({
    "node_modules/cborg/lib/encode.js"() {
      init_is();
      init_token();
      init_bl();
      init_common();
      init_jump();
      init_byte_utils();
      init_uint();
      init_negint();
      init_bytes2();
      init_string();
      init_array();
      init_map();
      init_tag();
      init_float();
      cborEncoders = makeCborEncoders();
      buf = new Bl();
      Ref = class _Ref {
        /**
         * @param {object|any[]} obj
         * @param {Reference|undefined} parent
         */
        constructor(obj, parent) {
          this.obj = obj;
          this.parent = parent;
        }
        /**
         * @param {object|any[]} obj
         * @returns {boolean}
         */
        includes(obj) {
          let p = this;
          do {
            if (p.obj === obj) {
              return true;
            }
          } while (p = p.parent);
          return false;
        }
        /**
         * @param {Reference|undefined} stack
         * @param {object|any[]} obj
         * @returns {Reference}
         */
        static createCheck(stack, obj) {
          if (stack && stack.includes(obj)) {
            throw new Error(`${encodeErrPrefix} object contains circular references`);
          }
          return new _Ref(obj, stack);
        }
      };
      simpleTokens = {
        null: new Token(Type.null, null),
        undefined: new Token(Type.undefined, void 0),
        true: new Token(Type.true, true),
        false: new Token(Type.false, false),
        emptyArray: new Token(Type.array, 0),
        emptyMap: new Token(Type.map, 0)
      };
      typeEncoders = {
        /**
         * @param {any} obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        number(obj, _typ, _options, _refStack) {
          if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
            return new Token(Type.float, obj);
          } else if (obj >= 0) {
            return new Token(Type.uint, obj);
          } else {
            return new Token(Type.negint, obj);
          }
        },
        /**
         * @param {any} obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        bigint(obj, _typ, _options, _refStack) {
          if (obj >= BigInt(0)) {
            return new Token(Type.uint, obj);
          } else {
            return new Token(Type.negint, obj);
          }
        },
        /**
         * @param {any} obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        Uint8Array(obj, _typ, _options, _refStack) {
          return new Token(Type.bytes, obj);
        },
        /**
         * @param {any} obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        string(obj, _typ, _options, _refStack) {
          return new Token(Type.string, obj);
        },
        /**
         * @param {any} obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        boolean(obj, _typ, _options, _refStack) {
          return obj ? simpleTokens.true : simpleTokens.false;
        },
        /**
         * @param {any} _obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        null(_obj, _typ, _options, _refStack) {
          return simpleTokens.null;
        },
        /**
         * @param {any} _obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        undefined(_obj, _typ, _options, _refStack) {
          return simpleTokens.undefined;
        },
        /**
         * @param {any} obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        ArrayBuffer(obj, _typ, _options, _refStack) {
          return new Token(Type.bytes, new Uint8Array(obj));
        },
        /**
         * @param {any} obj
         * @param {string} _typ
         * @param {EncodeOptions} _options
         * @param {Reference} [_refStack]
         * @returns {TokenOrNestedTokens}
         */
        DataView(obj, _typ, _options, _refStack) {
          return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
        },
        /**
         * @param {any} obj
         * @param {string} _typ
         * @param {EncodeOptions} options
         * @param {Reference} [refStack]
         * @returns {TokenOrNestedTokens}
         */
        Array(obj, _typ, options, refStack) {
          if (!obj.length) {
            if (options.addBreakTokens === true) {
              return [simpleTokens.emptyArray, new Token(Type.break)];
            }
            return simpleTokens.emptyArray;
          }
          refStack = Ref.createCheck(refStack, obj);
          const entries = [];
          let i = 0;
          for (const e of obj) {
            entries[i++] = objectToTokens(e, options, refStack);
          }
          if (options.addBreakTokens) {
            return [new Token(Type.array, obj.length), entries, new Token(Type.break)];
          }
          return [new Token(Type.array, obj.length), entries];
        },
        /**
         * @param {any} obj
         * @param {string} typ
         * @param {EncodeOptions} options
         * @param {Reference} [refStack]
         * @returns {TokenOrNestedTokens}
         */
        Object(obj, typ, options, refStack) {
          const isMap = typ !== "Object";
          const keys = isMap ? obj.keys() : Object.keys(obj);
          const length2 = isMap ? obj.size : keys.length;
          if (!length2) {
            if (options.addBreakTokens === true) {
              return [simpleTokens.emptyMap, new Token(Type.break)];
            }
            return simpleTokens.emptyMap;
          }
          refStack = Ref.createCheck(refStack, obj);
          const entries = [];
          let i = 0;
          for (const key of keys) {
            entries[i++] = [
              objectToTokens(key, options, refStack),
              objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
            ];
          }
          sortMapEntries(entries, options);
          if (options.addBreakTokens) {
            return [new Token(Type.map, length2), entries, new Token(Type.break)];
          }
          return [new Token(Type.map, length2), entries];
        }
      };
      typeEncoders.Map = typeEncoders.Object;
      typeEncoders.Buffer = typeEncoders.Uint8Array;
      for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
        typeEncoders[`${typ}Array`] = typeEncoders.DataView;
      }
    }
  });

  // node_modules/cborg/lib/decode.js
  function tokenToArray(token, tokeniser, options) {
    const arr = [];
    for (let i = 0; i < token.value; i++) {
      const value = tokensToObject(tokeniser, options);
      if (value === BREAK) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
      }
      if (value === DONE) {
        throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
      }
      arr[i] = value;
    }
    return arr;
  }
  function tokenToMap(token, tokeniser, options) {
    const useMaps = options.useMaps === true;
    const obj = useMaps ? void 0 : {};
    const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
    for (let i = 0; i < token.value; i++) {
      const key = tokensToObject(tokeniser, options);
      if (key === BREAK) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
      }
      if (key === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
      }
      if (useMaps !== true && typeof key !== "string") {
        throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
      }
      if (options.rejectDuplicateMapKeys === true) {
        if (useMaps && m.has(key) || !useMaps && key in obj) {
          throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
        }
      }
      const value = tokensToObject(tokeniser, options);
      if (value === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
      }
      if (useMaps) {
        m.set(key, value);
      } else {
        obj[key] = value;
      }
    }
    return useMaps ? m : obj;
  }
  function tokensToObject(tokeniser, options) {
    if (tokeniser.done()) {
      return DONE;
    }
    const token = tokeniser.next();
    if (token.type === Type.break) {
      return BREAK;
    }
    if (token.type.terminal) {
      return token.value;
    }
    if (token.type === Type.array) {
      return tokenToArray(token, tokeniser, options);
    }
    if (token.type === Type.map) {
      return tokenToMap(token, tokeniser, options);
    }
    if (token.type === Type.tag) {
      if (options.tags && typeof options.tags[token.value] === "function") {
        const tagged = tokensToObject(tokeniser, options);
        return options.tags[token.value](tagged);
      }
      throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
    }
    throw new Error("unsupported");
  }
  function decodeFirst(data, options) {
    if (!(data instanceof Uint8Array)) {
      throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
    }
    options = Object.assign({}, defaultDecodeOptions, options);
    const tokeniser = options.tokenizer || new Tokeniser(data, options);
    const decoded = tokensToObject(tokeniser, options);
    if (decoded === DONE) {
      throw new Error(`${decodeErrPrefix} did not find any content to decode`);
    }
    if (decoded === BREAK) {
      throw new Error(`${decodeErrPrefix} got unexpected break`);
    }
    return [decoded, data.subarray(tokeniser.pos())];
  }
  function decode6(data, options) {
    const [decoded, remainder] = decodeFirst(data, options);
    if (remainder.length > 0) {
      throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
    }
    return decoded;
  }
  var defaultDecodeOptions, Tokeniser, DONE, BREAK;
  var init_decode2 = __esm({
    "node_modules/cborg/lib/decode.js"() {
      init_common();
      init_token();
      init_jump();
      defaultDecodeOptions = {
        strict: false,
        allowIndefinite: true,
        allowUndefined: true,
        allowBigInt: true
      };
      Tokeniser = class {
        /**
         * @param {Uint8Array} data
         * @param {DecodeOptions} options
         */
        constructor(data, options = {}) {
          this._pos = 0;
          this.data = data;
          this.options = options;
        }
        pos() {
          return this._pos;
        }
        done() {
          return this._pos >= this.data.length;
        }
        next() {
          const byt = this.data[this._pos];
          let token = quick[byt];
          if (token === void 0) {
            const decoder2 = jump[byt];
            if (!decoder2) {
              throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
            }
            const minor = byt & 31;
            token = decoder2(this.data, this._pos, minor, this.options);
          }
          this._pos += token.encodedLength;
          return token;
        }
      };
      DONE = Symbol.for("DONE");
      BREAK = Symbol.for("BREAK");
    }
  });

  // node_modules/cborg/cborg.js
  var init_cborg = __esm({
    "node_modules/cborg/cborg.js"() {
      init_encode2();
      init_decode2();
      init_token();
    }
  });

  // node_modules/@ipld/dag-cbor/src/index.js
  function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
      throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
    }
    return CID.decode(bytes.subarray(1));
  }
  var CID_CBOR_TAG, decodeOptions, decode7;
  var init_src2 = __esm({
    "node_modules/@ipld/dag-cbor/src/index.js"() {
      init_cborg();
      init_cid();
      CID_CBOR_TAG = 42;
      decodeOptions = {
        allowIndefinite: false,
        coerceUndefinedToNull: true,
        allowNaN: false,
        allowInfinity: false,
        allowBigInt: true,
        // this will lead to BigInt for ints outside of
        // safe-integer range, which may surprise users
        strict: true,
        useMaps: false,
        rejectDuplicateMapKeys: true,
        /** @type {import('cborg').TagDecoder[]} */
        tags: []
      };
      decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
      decode7 = (data) => decode6(data, decodeOptions);
    }
  });

  // node_modules/varint/encode.js
  var require_encode = __commonJS({
    "node_modules/varint/encode.js"(exports, module) {
      module.exports = encode5;
      var MSB2 = 128;
      var REST2 = 127;
      var MSBALL2 = ~REST2;
      var INT2 = Math.pow(2, 31);
      function encode5(num, out, offset) {
        if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
          encode5.bytes = 0;
          throw new RangeError("Could not encode varint");
        }
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT2) {
          out[offset++] = num & 255 | MSB2;
          num /= 128;
        }
        while (num & MSBALL2) {
          out[offset++] = num & 255 | MSB2;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode5.bytes = offset - oldOffset + 1;
        return out;
      }
    }
  });

  // node_modules/varint/decode.js
  var require_decode = __commonJS({
    "node_modules/varint/decode.js"(exports, module) {
      module.exports = read3;
      var MSB2 = 128;
      var REST2 = 127;
      function read3(buf2, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
        do {
          if (counter >= l || shift > 49) {
            read3.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf2[counter++];
          res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB2);
        read3.bytes = counter - offset;
        return res;
      }
    }
  });

  // node_modules/varint/length.js
  var require_length = __commonJS({
    "node_modules/varint/length.js"(exports, module) {
      var N12 = Math.pow(2, 7);
      var N22 = Math.pow(2, 14);
      var N32 = Math.pow(2, 21);
      var N42 = Math.pow(2, 28);
      var N52 = Math.pow(2, 35);
      var N62 = Math.pow(2, 42);
      var N72 = Math.pow(2, 49);
      var N82 = Math.pow(2, 56);
      var N92 = Math.pow(2, 63);
      module.exports = function(value) {
        return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
      };
    }
  });

  // node_modules/varint/index.js
  var require_varint = __commonJS({
    "node_modules/varint/index.js"(exports, module) {
      module.exports = {
        encode: require_encode(),
        decode: require_decode(),
        encodingLength: require_length()
      };
    }
  });

  // node_modules/@ipld/car/src/decoder-common.js
  function decodeVarint(bytes, seeker) {
    if (!bytes.length) {
      throw new Error("Unexpected end of data");
    }
    const i = import_varint2.default.decode(bytes);
    seeker.seek(
      /** @type {number} */
      import_varint2.default.decode.bytes
    );
    return i;
  }
  function decodeV2Header(bytes) {
    const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;
    const header = {
      version: 2,
      /** @type {[bigint, bigint]} */
      characteristics: [
        dv.getBigUint64(offset, true),
        dv.getBigUint64(offset += 8, true)
      ],
      dataOffset: Number(dv.getBigUint64(offset += 8, true)),
      dataSize: Number(dv.getBigUint64(offset += 8, true)),
      indexOffset: Number(dv.getBigUint64(offset += 8, true))
    };
    return header;
  }
  function getMultihashLength(bytes) {
    import_varint2.default.decode(bytes);
    const codeLength = (
      /** @type {number} */
      import_varint2.default.decode.bytes
    );
    const length2 = import_varint2.default.decode(bytes.subarray(import_varint2.default.decode.bytes));
    const lengthLength = (
      /** @type {number} */
      import_varint2.default.decode.bytes
    );
    const mhLength = codeLength + lengthLength + length2;
    return mhLength;
  }
  var import_varint2, CIDV0_BYTES, V2_HEADER_LENGTH;
  var init_decoder_common = __esm({
    "node_modules/@ipld/car/src/decoder-common.js"() {
      import_varint2 = __toESM(require_varint(), 1);
      CIDV0_BYTES = {
        SHA2_256: 18,
        LENGTH: 32,
        DAG_PB: 112
      };
      V2_HEADER_LENGTH = /* characteristics */
      16 + 8 + 8 + 8;
    }
  });

  // node_modules/@ipld/car/src/header-validator.js
  var Kinds, Types, Reprs, CarV1HeaderOrV2Pragma;
  var init_header_validator = __esm({
    "node_modules/@ipld/car/src/header-validator.js"() {
      Kinds = {
        Null: (
          /** @returns {undefined|null} */
          (obj) => obj === null ? obj : void 0
        ),
        Int: (
          /** @returns {undefined|number} */
          (obj) => Number.isInteger(obj) ? obj : void 0
        ),
        Float: (
          /** @returns {undefined|number} */
          (obj) => typeof obj === "number" && Number.isFinite(obj) ? obj : void 0
        ),
        String: (
          /** @returns {undefined|string} */
          (obj) => typeof obj === "string" ? obj : void 0
        ),
        Bool: (
          /** @returns {undefined|boolean} */
          (obj) => typeof obj === "boolean" ? obj : void 0
        ),
        Bytes: (
          /** @returns {undefined|Uint8Array} */
          (obj) => obj instanceof Uint8Array ? obj : void 0
        ),
        Link: (
          /** @returns {undefined|object} */
          (obj) => obj !== null && typeof obj === "object" && obj.asCID === obj ? obj : void 0
        ),
        List: (
          /** @returns {undefined|Array<any>} */
          (obj) => Array.isArray(obj) ? obj : void 0
        ),
        Map: (
          /** @returns {undefined|object} */
          (obj) => obj !== null && typeof obj === "object" && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : void 0
        )
      };
      Types = {
        "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
        "CarV1HeaderOrV2Pragma > roots (anon)": (
          /** @returns {undefined|any} */
          (obj) => {
            if (Kinds.List(obj) === void 0) {
              return void 0;
            }
            for (let i = 0; i < obj.length; i++) {
              let v = obj[i];
              v = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
              if (v === void 0) {
                return void 0;
              }
              if (v !== obj[i]) {
                const ret = obj.slice(0, i);
                for (let j = i; j < obj.length; j++) {
                  let v2 = obj[j];
                  v2 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
                  if (v2 === void 0) {
                    return void 0;
                  }
                  ret.push(v2);
                }
                return ret;
              }
            }
            return obj;
          }
        ),
        Int: Kinds.Int,
        CarV1HeaderOrV2Pragma: (
          /** @returns {undefined|any} */
          (obj) => {
            if (Kinds.Map(obj) === void 0) {
              return void 0;
            }
            const entries = Object.entries(obj);
            let ret = obj;
            let requiredCount = 1;
            for (let i = 0; i < entries.length; i++) {
              const [key, value] = entries[i];
              switch (key) {
                case "roots":
                  {
                    const v = Types["CarV1HeaderOrV2Pragma > roots (anon)"](obj[key]);
                    if (v === void 0) {
                      return void 0;
                    }
                    if (v !== value || ret !== obj) {
                      if (ret === obj) {
                        ret = {};
                        for (let j = 0; j < i; j++) {
                          ret[entries[j][0]] = entries[j][1];
                        }
                      }
                      ret.roots = v;
                    }
                  }
                  break;
                case "version":
                  {
                    requiredCount--;
                    const v = Types.Int(obj[key]);
                    if (v === void 0) {
                      return void 0;
                    }
                    if (v !== value || ret !== obj) {
                      if (ret === obj) {
                        ret = {};
                        for (let j = 0; j < i; j++) {
                          ret[entries[j][0]] = entries[j][1];
                        }
                      }
                      ret.version = v;
                    }
                  }
                  break;
                default:
                  return void 0;
              }
            }
            if (requiredCount > 0) {
              return void 0;
            }
            return ret;
          }
        )
      };
      Reprs = {
        "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
        "CarV1HeaderOrV2Pragma > roots (anon)": (
          /** @returns {undefined|any} */
          (obj) => {
            if (Kinds.List(obj) === void 0) {
              return void 0;
            }
            for (let i = 0; i < obj.length; i++) {
              let v = obj[i];
              v = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
              if (v === void 0) {
                return void 0;
              }
              if (v !== obj[i]) {
                const ret = obj.slice(0, i);
                for (let j = i; j < obj.length; j++) {
                  let v2 = obj[j];
                  v2 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
                  if (v2 === void 0) {
                    return void 0;
                  }
                  ret.push(v2);
                }
                return ret;
              }
            }
            return obj;
          }
        ),
        Int: Kinds.Int,
        CarV1HeaderOrV2Pragma: (
          /** @returns {undefined|any} */
          (obj) => {
            if (Kinds.Map(obj) === void 0) {
              return void 0;
            }
            const entries = Object.entries(obj);
            let ret = obj;
            let requiredCount = 1;
            for (let i = 0; i < entries.length; i++) {
              const [key, value] = entries[i];
              switch (key) {
                case "roots":
                  {
                    const v = Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](value);
                    if (v === void 0) {
                      return void 0;
                    }
                    if (v !== value || ret !== obj) {
                      if (ret === obj) {
                        ret = {};
                        for (let j = 0; j < i; j++) {
                          ret[entries[j][0]] = entries[j][1];
                        }
                      }
                      ret.roots = v;
                    }
                  }
                  break;
                case "version":
                  {
                    requiredCount--;
                    const v = Reprs.Int(value);
                    if (v === void 0) {
                      return void 0;
                    }
                    if (v !== value || ret !== obj) {
                      if (ret === obj) {
                        ret = {};
                        for (let j = 0; j < i; j++) {
                          ret[entries[j][0]] = entries[j][1];
                        }
                      }
                      ret.version = v;
                    }
                  }
                  break;
                default:
                  return void 0;
              }
            }
            if (requiredCount > 0) {
              return void 0;
            }
            return ret;
          }
        )
      };
      CarV1HeaderOrV2Pragma = {
        toTyped: Types.CarV1HeaderOrV2Pragma,
        toRepresentation: Reprs.CarV1HeaderOrV2Pragma
      };
    }
  });

  // node_modules/@ipld/car/src/decoder.js
  function readHeader(reader, strictVersion) {
    return __async(this, null, function* () {
      const length2 = decodeVarint(yield reader.upTo(8), reader);
      if (length2 === 0) {
        throw new Error("Invalid CAR header (zero length)");
      }
      const header = yield reader.exactly(length2, true);
      const block = decode7(header);
      if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
        throw new Error("Invalid CAR header format");
      }
      if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
      }
      if (block.version === 1) {
        if (!Array.isArray(block.roots)) {
          throw new Error("Invalid CAR header format");
        }
        return block;
      }
      if (block.roots !== void 0) {
        throw new Error("Invalid CAR header format");
      }
      const v2Header = decodeV2Header(yield reader.exactly(V2_HEADER_LENGTH, true));
      reader.seek(v2Header.dataOffset - reader.pos);
      const v1Header = yield readHeader(reader, 1);
      return Object.assign(v1Header, v2Header);
    });
  }
  function readCid(reader) {
    return __async(this, null, function* () {
      const first = yield reader.exactly(2, false);
      if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
        const bytes2 = yield reader.exactly(34, true);
        const multihash2 = decode5(bytes2);
        return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
      }
      const version = decodeVarint(yield reader.upTo(8), reader);
      if (version !== 1) {
        throw new Error(`Unexpected CID version (${version})`);
      }
      const codec = decodeVarint(yield reader.upTo(8), reader);
      const bytes = yield reader.exactly(getMultihashLength(yield reader.upTo(8)), true);
      const multihash = decode5(bytes);
      return CID.create(version, codec, multihash);
    });
  }
  function readBlockHead(reader) {
    return __async(this, null, function* () {
      const start = reader.pos;
      let length2 = decodeVarint(yield reader.upTo(8), reader);
      if (length2 === 0) {
        throw new Error("Invalid CAR section (zero length)");
      }
      length2 += reader.pos - start;
      const cid = yield readCid(reader);
      const blockLength = length2 - Number(reader.pos - start);
      return { cid, length: length2, blockLength };
    });
  }
  function readBlock(reader) {
    return __async(this, null, function* () {
      const { cid, blockLength } = yield readBlockHead(reader);
      const bytes = yield reader.exactly(blockLength, true);
      return { bytes, cid };
    });
  }
  function readBlockIndex(reader) {
    return __async(this, null, function* () {
      const offset = reader.pos;
      const { cid, length: length2, blockLength } = yield readBlockHead(reader);
      const index = { cid, length: length2, blockLength, offset, blockOffset: reader.pos };
      reader.seek(index.blockLength);
      return index;
    });
  }
  function createDecoder(reader) {
    const headerPromise = (() => __async(this, null, function* () {
      const header = yield readHeader(reader);
      if (header.version === 2) {
        const v1length = reader.pos - header.dataOffset;
        reader = limitReader(reader, header.dataSize - v1length);
      }
      return header;
    }))();
    return {
      header: () => headerPromise,
      blocks() {
        return __asyncGenerator(this, null, function* () {
          yield new __await(headerPromise);
          while ((yield new __await(reader.upTo(8))).length > 0) {
            yield yield new __await(readBlock(reader));
          }
        });
      },
      blocksIndex() {
        return __asyncGenerator(this, null, function* () {
          yield new __await(headerPromise);
          while ((yield new __await(reader.upTo(8))).length > 0) {
            yield yield new __await(readBlockIndex(reader));
          }
        });
      }
    };
  }
  function bytesReader(bytes) {
    let pos = 0;
    return {
      upTo(length2) {
        return __async(this, null, function* () {
          const out = bytes.subarray(pos, pos + Math.min(length2, bytes.length - pos));
          return out;
        });
      },
      exactly(length2, seek = false) {
        return __async(this, null, function* () {
          if (length2 > bytes.length - pos) {
            throw new Error("Unexpected end of data");
          }
          const out = bytes.subarray(pos, pos + length2);
          if (seek) {
            pos += length2;
          }
          return out;
        });
      },
      seek(length2) {
        pos += length2;
      },
      get pos() {
        return pos;
      }
    };
  }
  function chunkReader(readChunk) {
    let pos = 0;
    let have = 0;
    let offset = 0;
    let currentChunk = new Uint8Array(0);
    const read3 = (length2) => __async(this, null, function* () {
      have = currentChunk.length - offset;
      const bufa = [currentChunk.subarray(offset)];
      while (have < length2) {
        const chunk = yield readChunk();
        if (chunk == null) {
          break;
        }
        if (have < 0) {
          if (chunk.length > have) {
            bufa.push(chunk.subarray(-have));
          }
        } else {
          bufa.push(chunk);
        }
        have += chunk.length;
      }
      currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
      let off = 0;
      for (const b of bufa) {
        currentChunk.set(b, off);
        off += b.length;
      }
      offset = 0;
    });
    return {
      upTo(length2) {
        return __async(this, null, function* () {
          if (currentChunk.length - offset < length2) {
            yield read3(length2);
          }
          return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
        });
      },
      exactly(length2, seek = false) {
        return __async(this, null, function* () {
          if (currentChunk.length - offset < length2) {
            yield read3(length2);
          }
          if (currentChunk.length - offset < length2) {
            throw new Error("Unexpected end of data");
          }
          const out = currentChunk.subarray(offset, offset + length2);
          if (seek) {
            pos += length2;
            offset += length2;
          }
          return out;
        });
      },
      seek(length2) {
        pos += length2;
        offset += length2;
      },
      get pos() {
        return pos;
      }
    };
  }
  function asyncIterableReader(asyncIterable) {
    const iterator = asyncIterable[Symbol.asyncIterator]();
    function readChunk() {
      return __async(this, null, function* () {
        const next = yield iterator.next();
        if (next.done) {
          return null;
        }
        return next.value;
      });
    }
    return chunkReader(readChunk);
  }
  function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    return {
      upTo(length2) {
        return __async(this, null, function* () {
          let bytes = yield reader.upTo(length2);
          if (bytes.length + bytesRead > byteLimit) {
            bytes = bytes.subarray(0, byteLimit - bytesRead);
          }
          return bytes;
        });
      },
      exactly(length2, seek = false) {
        return __async(this, null, function* () {
          const bytes = yield reader.exactly(length2, seek);
          if (bytes.length + bytesRead > byteLimit) {
            throw new Error("Unexpected end of data");
          }
          if (seek) {
            bytesRead += length2;
          }
          return bytes;
        });
      },
      seek(length2) {
        bytesRead += length2;
        reader.seek(length2);
      },
      get pos() {
        return reader.pos;
      }
    };
  }
  var init_decoder = __esm({
    "node_modules/@ipld/car/src/decoder.js"() {
      init_src2();
      init_cid();
      init_digest();
      init_decoder_common();
      init_header_validator();
    }
  });

  // node_modules/@ipld/car/src/reader-browser.js
  function decodeReaderComplete(reader) {
    return __async(this, null, function* () {
      const decoder2 = createDecoder(reader);
      const header = yield decoder2.header();
      const blocks = [];
      try {
        for (var iter = __forAwait(decoder2.blocks()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const block = temp.value;
          blocks.push(block);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return new CarReader(header, blocks);
    });
  }
  var CarReader;
  var init_reader_browser = __esm({
    "node_modules/@ipld/car/src/reader-browser.js"() {
      init_decoder();
      CarReader = class {
        /**
         * @constructs CarReader
         * @param {CarHeader|CarV2Header} header
         * @param {Block[]} blocks
         */
        constructor(header, blocks) {
          this._header = header;
          this._blocks = blocks;
          this._keys = blocks.map((b) => b.cid.toString());
        }
        /**
         * @property
         * @memberof CarReader
         * @instance
         */
        get version() {
          return this._header.version;
        }
        /**
         * Get the list of roots defined by the CAR referenced by this reader. May be
         * zero or more `CID`s.
         *
         * @function
         * @memberof CarReader
         * @instance
         * @async
         * @returns {Promise<CID[]>}
         */
        getRoots() {
          return __async(this, null, function* () {
            return this._header.roots;
          });
        }
        /**
         * Check whether a given `CID` exists within the CAR referenced by this
         * reader.
         *
         * @function
         * @memberof CarReader
         * @instance
         * @async
         * @param {CID} key
         * @returns {Promise<boolean>}
         */
        has(key) {
          return __async(this, null, function* () {
            return this._keys.indexOf(key.toString()) > -1;
          });
        }
        /**
         * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
         * referenced by this reader matching the provided `CID`. In the case where
         * the provided `CID` doesn't exist within the CAR, `undefined` will be
         * returned.
         *
         * @function
         * @memberof CarReader
         * @instance
         * @async
         * @param {CID} key
         * @returns {Promise<Block | undefined>}
         */
        get(key) {
          return __async(this, null, function* () {
            const index = this._keys.indexOf(key.toString());
            return index > -1 ? this._blocks[index] : void 0;
          });
        }
        /**
         * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all
         * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
         * the CAR referenced by this reader.
         *
         * @function
         * @memberof CarReader
         * @instance
         * @async
         * @generator
         * @returns {AsyncGenerator<Block>}
         */
        blocks() {
          return __asyncGenerator(this, null, function* () {
            for (const block of this._blocks) {
              yield block;
            }
          });
        }
        /**
         * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of
         * the `CID`s contained within the CAR referenced by this reader.
         *
         * @function
         * @memberof CarReader
         * @instance
         * @async
         * @generator
         * @returns {AsyncGenerator<CID>}
         */
        cids() {
          return __asyncGenerator(this, null, function* () {
            for (const block of this._blocks) {
              yield block.cid;
            }
          });
        }
        /**
         * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a
         * decode fully in memory and maintains the decoded state in memory for full
         * access to the data via the `CarReader` API.
         *
         * @async
         * @static
         * @memberof CarReader
         * @param {Uint8Array} bytes
         * @returns {Promise<CarReader>}
         */
        static fromBytes(bytes) {
          return __async(this, null, function* () {
            if (!(bytes instanceof Uint8Array)) {
              throw new TypeError("fromBytes() requires a Uint8Array");
            }
            return decodeReaderComplete(bytesReader(bytes));
          });
        }
        /**
         * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as
         * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
         * This performs a decode fully in memory and maintains the decoded state in
         * memory for full access to the data via the `CarReader` API.
         *
         * Care should be taken for large archives; this API may not be appropriate
         * where memory is a concern or the archive is potentially larger than the
         * amount of memory that the runtime can handle.
         *
         * @async
         * @static
         * @memberof CarReader
         * @param {AsyncIterable<Uint8Array>} asyncIterable
         * @returns {Promise<CarReader>}
         */
        static fromIterable(asyncIterable) {
          return __async(this, null, function* () {
            if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
              throw new TypeError("fromIterable() requires an async iterable");
            }
            return decodeReaderComplete(asyncIterableReader(asyncIterable));
          });
        }
      };
    }
  });

  // lib/firehose.js
  function firehose() {
    return __asyncGenerator(this, null, function* () {
      ensureCborXExtended();
      const WebSocketImpl = typeof WebSocket === "function" ? WebSocket : (
        /** @type {typeof WebSocket} */
        __require("ws")
      );
      const wsAddress = "wss://bsky.network/xrpc/com.atproto.sync.subscribeRepos";
      const ws = new WebSocketImpl(wsAddress);
      ws.addEventListener("message", handleMessage);
      ws.addEventListener("error", handleError);
      ws.addEventListener("close", handleClose);
      let buf2 = createAwaitPromise();
      let closed = false;
      try {
        while (true) {
          yield new __await(buf2.promise);
          const blocks = buf2.blocks;
          buf2 = createAwaitPromise();
          if (closed) {
            if (blocks.length)
              yield blocks;
            break;
          }
          yield blocks;
        }
      } finally {
        if (!closed) {
          try {
            ws.close();
          } catch (error) {
          }
        }
      }
      function handleClose() {
        closed = true;
        buf2.resolve();
      }
      function handleMessage(event) {
        var _a2, _b;
        const receiveTimestamp = Date.now();
        if (typeof ((_a2 = event.data) == null ? void 0 : _a2.arrayBuffer) === "function")
          return event.data.arrayBuffer().then((arrayBuf) => convertMessageBuf(receiveTimestamp, arrayBuf));
        else if (typeof ((_b = event.data) == null ? void 0 : _b.byteLength) === "number")
          return convertMessageBuf(receiveTimestamp, event.data);
      }
      function convertMessageBuf(receiveTimestamp, messageBuf) {
        return __async(this, null, function* () {
          var _a2, _b;
          const entry = (
            /** @type {any[]} */
            decodeMultiple(new Uint8Array(messageBuf))
          );
          if (!entry || ((_a2 = entry[0]) == null ? void 0 : _a2.op) !== 1)
            return;
          const commit = entry[1];
          if (!commit.blocks)
            return;
          if (!((_b = commit.ops) == null ? void 0 : _b.length))
            return;
          const car = yield CarReader.fromBytes(commit.blocks);
          const blockEntry = {
            receiveTimestamp,
            since: commit.since,
            time: commit.time,
            messages: []
          };
          for (const op of commit.ops) {
            const block = op.cid && (yield car.get(
              /** @type {*} */
              op.cid
            ));
            if (!block)
              continue;
            const record = decode(block.bytes);
            record.repo = commit.repo;
            record.cid = op.cid && String(op.cid);
            record.path = op.path;
            record.action = op.action;
            let unexpected = op.action !== "create" && op.action !== "update" && op.action !== "delete" || knownTypes.indexOf(record.$type) < 0;
            if (unexpected) {
              if (!blockEntry.unexpected)
                blockEntry.unexpected = [];
              blockEntry.unexpected.push(record);
            } else if (op.action === "delete") {
              if (!blockEntry.deletes)
                blockEntry.deletes = [];
              blockEntry.deletes.push(record);
            } else {
              blockEntry.messages.push(record);
            }
          }
          buf2.blocks.push(blockEntry);
          buf2.resolve();
        });
      }
      function handleError(error) {
        console.error(error);
        const errorText = error.message || "WebSocket error " + error;
        buf2.reject(new Error(errorText));
      }
    });
  }
  function createAwaitPromise() {
    const result = { blocks: [] };
    result.promise = new Promise((resolve, reject) => {
      result.resolve = resolve;
      result.reject = reject;
    });
    return (
      /** @type {*} */
      result
    );
  }
  function ensureCborXExtended() {
    if (cbor_x_extended)
      return;
    addExtension2({
      Class: CID,
      tag: 42,
      encode: () => {
        throw new Error("cannot encode cids");
      },
      decode: (bytes) => {
        if (bytes[0] !== 0)
          throw new Error("invalid cid for cbor tag 42");
        return CID.decode(bytes.subarray(1));
      }
    });
    cbor_x_extended = true;
  }
  var knownTypes, cbor_x_extended;
  var init_firehose = __esm({
    "lib/firehose.js"() {
      init_cbor_x();
      init_src();
      init_coldsky_agent();
      init_reader_browser();
      init_shorten();
      knownTypes = [
        "app.bsky.feed.like",
        "app.bsky.feed.post",
        "app.bsky.feed.repost",
        "app.bsky.feed.threadgate",
        "app.bsky.graph.follow",
        "app.bsky.graph.block",
        "app.bsky.graph.list",
        "app.bsky.graph.listitem",
        "app.bsky.actor.profile"
      ];
      cbor_x_extended = false;
    }
  });

  // lib/index.js
  var require_lib = __commonJS({
    "lib/index.js"(exports, module) {
      init_shorten();
      init_is_promise();
      init_coldsky_agent();
      init_firehose();
      var all = {
        likelyDID,
        shortenDID,
        shortenHandle,
        unwrapShortDID,
        unwrapShortHandle,
        breakFeedUri,
        breakPostURL,
        isPromise,
        ColdskyAgent,
        firehose
      };
      checkApplyGlobal();
      function checkApplyGlobal() {
        if (typeof process !== "undefined" && typeof (process == null ? void 0 : process.exit) === "function") {
          if (typeof module !== "undefined" && (module == null ? void 0 : module.exports)) {
            for (const key in all) {
              module.exports[key] = all[key];
            }
          }
          return;
        }
        if (typeof window !== "undefined" && window) {
          for (const key in all) {
            window[key] = all[key];
          }
        } else if (typeof global !== "undefined" && global) {
          for (const key in all) {
            global[key] = all[key];
          }
        }
      }
    }
  });
  var req=require_lib();
  if (typeof module!=='undefined' && module && module.exports) module.exports=req;
})();
//# sourceMappingURL=libs.js.map
